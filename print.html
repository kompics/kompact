<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Kompact Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the Kompact actor-component-hybrid systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/components.html"><strong aria-hidden="true">1.1.</strong> Components</a></li><li class="chapter-item expanded "><a href="introduction/actors.html"><strong aria-hidden="true">1.2.</strong> Actors</a></li><li class="chapter-item expanded "><a href="introduction/state.html"><strong aria-hidden="true">1.3.</strong> Internal State</a></li></ol></li><li class="chapter-item expanded "><a href="local/index.html"><strong aria-hidden="true">2.</strong> Local Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="local/communication/index.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="local/communication/messagesandevents.html"><strong aria-hidden="true">2.1.1.</strong> Messages and Events</a></li><li class="chapter-item expanded "><a href="local/communication/state.html"><strong aria-hidden="true">2.1.2.</strong> State</a></li><li class="chapter-item expanded "><a href="local/communication/handlers.html"><strong aria-hidden="true">2.1.3.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="local/communication/ask.html"><strong aria-hidden="true">2.1.4.</strong> Ask</a></li><li class="chapter-item expanded "><a href="local/communication/system.html"><strong aria-hidden="true">2.1.5.</strong> System</a></li><li class="chapter-item expanded "><a href="local/communication/senders.html"><strong aria-hidden="true">2.1.6.</strong> Senders</a></li></ol></li><li class="chapter-item expanded "><a href="local/timers.html"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="local/schedulers.html"><strong aria-hidden="true">2.3.</strong> Schedulers</a></li><li class="chapter-item expanded "><a href="local/logging.html"><strong aria-hidden="true">2.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="local/configuration.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="local/faultrecovery.html"><strong aria-hidden="true">2.6.</strong> Fault Recovery</a></li><li class="chapter-item expanded "><a href="local/dynamic-components.html"><strong aria-hidden="true">2.7.</strong> Dynamic Components</a></li></ol></li><li class="chapter-item expanded "><a href="distributed/index.html"><strong aria-hidden="true">3.</strong> Distributed Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="distributed/basiccommunication.html"><strong aria-hidden="true">3.1.</strong> Basic Communication</a></li><li class="chapter-item expanded "><a href="distributed/namedservices.html"><strong aria-hidden="true">3.2.</strong> Named Services</a></li><li class="chapter-item expanded "><a href="distributed/pathrouting.html"><strong aria-hidden="true">3.3.</strong> Path Routing</a></li><li class="chapter-item expanded "><a href="distributed/serialisation.html"><strong aria-hidden="true">3.4.</strong> Serialisation</a></li><li class="chapter-item expanded "><a href="distributed/networkbuffers.html"><strong aria-hidden="true">3.5.</strong> Configuring Buffers</a></li><li class="chapter-item expanded "><a href="distributed/networkstatusport.html"><strong aria-hidden="true">3.6.</strong> Network Status Port</a></li></ol></li><li class="chapter-item expanded "><a href="async/index.html"><strong aria-hidden="true">4.</strong> Async/Await Interaction</a></li><li class="chapter-item expanded affix "><a href="project.html">Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Kompact Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/kompics/kompact" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>In this document we will describe how to use the Kompact component-actor hybrid framework. We begin by introducing the model, which is novel in its hybrid nature, but should feel sufficiently familiar to previous users of other Actor frameworks (such as <a href="https://akka.io/">Akka</a>, for example) or <a href="https://kompics.github.io/kompics-scala/">Kompics</a> implementations. We then continue with a detailed tutorial for both local and distributed deployments of the Kompact implementation in the <a href="https://www.rust-lang.org/">Rust</a> language.</p>
<p>In addition to the tutorial style presentation in this book, many examples of Kompact uses can be found in the <a href="https://docs.rs/kompact/latest/kompact/">docs</a> and in the <a href="https://github.com/kompics/kompicsbenches/tree/master/kompact">benchmarks</a>.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="setting-up-rust"><a class="header" href="#setting-up-rust">Setting up Rust</a></h2>
<p>It is recommmended to run Kompact on a <em>nightly</em> version of the rust toolchain, but since <code>0.9</code> it also runs alright on stable Rust.</p>
<p>We recommend using the <a href="https://rustup.rs/">rustup</a> tool to easily install the latest nightly version of rust and keep it updated. Instructions should be on screen once rustup is downloaded.</p>
<blockquote>
<p><strong>Using the nightly toolchain:</strong> Rustup can be configured to default to the nightly toolchain by running <code>rustup default nightly</code>.</p>
</blockquote>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>Add Kompact to your cargo project as a dependency:</p>
<pre><code class="language-toml">[dependencies]
kompact = &quot;LATEST_VERSION&quot;
</code></pre>
<p>The latest version can be found on <a href="https://crates.io/crates/kompact">crates.io</a>.</p>
<h3 id="github-master"><a class="header" href="#github-master">Github master</a></h3>
<p>You can also point cargo to the latest <a href="https://github.com/kompics/kompact">Github</a> master version, instead of a release.
To do so add the following to your Cargo.toml instead:</p>
<pre><code class="language-toml">[dependencies]
kompact = { git = &quot;https://github.com/kompics/kompact&quot; }
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>With the above, you are set to run the simplest of Kompact projects, the venerable “Hello World”.</p>
<p>Create a new executable file, such as <code>main.rs</code>, and write a very simple component that just logs “Hello World” at the <code>info</code> level when it’s started and ignores all other messages and events: </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span>use kompact::prelude::*;

#[derive(ComponentDefinition, Actor)]
struct HelloWorldComponent {
    ctx: ComponentContext&lt;Self&gt;,
}
impl HelloWorldComponent {
    pub fn new() -&gt; Self {
        HelloWorldComponent {
            ctx: ComponentContext::uninitialised(),
        }
    }
}
impl ComponentLifecycle for HelloWorldComponent {
    fn on_start(&amp;mut self) -&gt; Handled {
        info!(self.log(), &quot;Hello World!&quot;);
        self.ctx.system().shutdown_async();
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(HelloWorldComponent::new);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In order to start our component, we need a Kompact system, which we will create from a default configuration.
And then we just wait for the component to do its work and shut the system down again:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct HelloWorldComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl HelloWorldComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        HelloWorldComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ComponentLifecycle for HelloWorldComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Hello World!&quot;);
</span><span class="boring">        self.ctx.system().shutdown_async();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let component = system.create(HelloWorldComponent::new);
    system.start(&amp;component);
    system.await_termination();
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The <code>await_termination()</code> call blocks the main-thread while the Kompact system is operating on its own thread pool. We will get into more details on scheduling and thread pools a bit later in this tutorial. For now it is sufficient to know, that once the Kompact system has been shut down by our <code>HelloWorldComponent</code> using <code>shutdown_async()</code>, the main-thread will eventually continue.</p>
<p>We can run this code, depending on how you set up your project, with:</p>
<pre><code class="language-bash">cargo run --release
</code></pre>
<p>This will give us something like the following output:</p>
<pre><code class="language-bash">lkroll $ cargo run --release --bin helloworld
    Finished release [optimized] target(s) in 0.09s
     Running `/Users/lkroll/Programming/Kompics/kompact/target/release/helloworld`
Jul 07 16:28:45.870 INFO Hello World!, ctype: HelloWorldComponent, cid: 804ed483-54d5-41ab-ad8f-145f90bc7b45, system: kompact-runtime-1, location: docs/examples/src/bin/helloworld.rs:17
</code></pre>
<p>We can see the “Hello World” being logged, alongside a bunch of other contextual information that is automatically inserted by the runtime, such as the type name of the component doing the logging (<code>ctype</code>), the unique id of the component (<code>cid</code>) which differentiates from other instances of the same type, the name of the Kompact <code>system</code>, as well as the concrete location in the file where the logging statement occurs.</p>
<p>If we run in debug mode, instead of release, using the simple <code>cargo run</code> we get a lot of additional output at the <code>debug</code> level, concerning system and component lifecycle – more on that later.</p>
<blockquote>
<p><strong>Note:</strong> If you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> and are trying to run from there, you need to specify the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin helloworld
</code></pre>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this section of the tutorial we will discuss the model assumptions and concepts that are underlying the implementation of Kompact. We will look at message-passing programming models, the ideas of actor references and <em>channels</em> with <em>ports</em>, and the notion of <em>exclusive local state</em>.</p>
<p>At a high level, Kompact is simply a merger of the Actor model of programming with the (Kompics) component model of programming. In both models light-weight processes with their own internal state communicate by exchanging discrete pieces of information (<em>messages</em> or <em>events</em>) instead of accessing shared memory structures or each other’s internal state. </p>
<p>While both models are formally equivalent, that is each model can be expressed in terms of the other, their different semantics can have significant impact on the performance of any implementation. Kompact thus allows programmers to express services and application in a mix of both models, thus taking advantage of their respective strengths and weaknesses as appropriate.</p>
<h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>In the Kompics component model, the term for a <em>light-weight process with internal state</em> is a “component”.
This notion can be further subdivided into the process-part of a component, a <em>component core</em>, and the state-part of a component, which is called a <em>component definition</em>. The <em>core</em> basically just interacts with the runtime of the system, while the <em>definition</em> contains the state variables and behaviours, in the form of <em>ports</em> and <em>event handlers</em>, which we will discuss below.</p>
<p>The execution model of a component model always ensures that the state variables of a component definition can be accessed safely without any synchronisation.</p>
<p>In the Kompact implementation, a <em>component definition</em> is simply a Rust struct that contains a <code>ComponentContext</code> as a field and implements the <code>ComponentDefinition</code> trait, which is typically just derived automatically, as we saw in the “Hello World”-example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
struct HelloWorldComponent {
    ctx: ComponentContext&lt;Self&gt;,
}
<span class="boring">impl HelloWorldComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        HelloWorldComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ComponentLifecycle for HelloWorldComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Hello World!&quot;);
</span><span class="boring">        self.ctx.system().shutdown_async();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(HelloWorldComponent::new);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The <em>component core</em> itself is hidden from us in Kompact, but we can interact with it using the <code>ComponentContext</code> field from within a component. When we actually instantiate a component as part of a Kompact system, we are given an <code>Arc&lt;Component&gt;</code>, which is a combined reference to the component definition and core. The creation of this structure is what really happened when we invoked <code>system.create(...)</code> in the “Hello World”-example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct HelloWorldComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl HelloWorldComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        HelloWorldComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ComponentLifecycle for HelloWorldComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Hello World!&quot;);
</span><span class="boring">        self.ctx.system().shutdown_async();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span>    let component = system.create(HelloWorldComponent::new);
<span class="boring">    system.start(&amp;component);
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="events-and-ports"><a class="header" href="#events-and-ports">Events and Ports</a></h2>
<p>Components communicate via <em>events</em> that are propagated along channels to a set of target components. The Kompics model is very strict about which events may travel on which channels, which it formalises with the concept of a <em>port</em>. Ports basically just state which events may travel in which way through the channels connected to it. You can think of a port as an API specification. If a component <em>C</em> <em>provides</em> the API of a port <em>P</em>, then it will accept all events of types that are marked as <em>request</em> in <em>P</em>, and it will only send events of the types that are marked as <em>indication</em> in <em>P</em>. Since components communicate with each other, the dual notion to providing a port is <em>requiring</em> it, and channels may only connect opposite variants of ports. That is, if one end of a channel is connected to a <em>provided</em> port of type <em>P</em> then the other side <strong>must</strong> be connected to a <em>required</em> port of type <em>P</em>. This setup ensures that messages which are sent through the channel are also accepted on the other side.</p>
<p>In Kompact each port is limited to a single <em>indication</em> and a single <em>request</em> type. If more types are needed in either direction, they must be wrapped into an enum, which is facilitated easily in Rust using the <code>From</code> and <code>Into</code> traits. </p>
<p>For example, a simplified version of Kompact’s internal <code>ControlPort</code>, which could be defined something like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ControlEvent {
    Start,
    Stop,
    Kill,
}

pub struct ControlPort;

impl Port for ControlPort {
    type Indication = Never; // alias for the ! bottom type
    type Request = ControlEvent;
}
</code></pre>
<p>It has a single <em>request</em> event of type <code>ControlEvent</code>, which provides three different variants, invoked at particular points in a component’s lifecycle. It does not send any <em>indication</em> events, however, which is marked by the <code>Never</code> type, which is uninhabited.</p>
<p>In order to react to the events of a port we must implement an trait appropriate trait for the direction of the events. For the control port above, for example, we might want to implement <code>Provide&lt;ControlPort&gt;</code> to react to <code>ControlEvent</code> instances. This could look as follows, for example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">impl Provide&lt;ControlPort&gt; for HelloWorldComponent {
	fn handle(&amp;mut self, event: ControlEvent) -&gt; Handled {
		match event {
			ControlEvent::Start =&gt; {
				info!(self.log(), &quot;Hello World!&quot;);
        		self.ctx.system().shutdown_async();
        		Handled::Ok
			}
			ControlEvent::Stop | ControlEvent::Kill =&gt; Handled::Ok,
		}
	}
}
</code></pre>
<p>This mechanism is similar to the concept of <em>event handlers</em> in the Kompics model, except that you can only have a single handler in Kompact and it is <em>always</em> (statically) <em>subscribed</em>. In this way the compiler can statically ensure that any component providing (or requiring) a port also accepts the appropriate events.</p>
<p>In Kompact, however, the <code>ControlPort</code> is not exposed (anymore since version <code>0.10.0</code>), but instead we must implement the <code>ComponentLifecycle</code> trait to react to (some of) its events, as we did in the <code>HelloWorldComponent</code> example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct HelloWorldComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl HelloWorldComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        HelloWorldComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>impl ComponentLifecycle for HelloWorldComponent {
    fn on_start(&amp;mut self) -&gt; Handled {
        info!(self.log(), &quot;Hello World!&quot;);
        self.ctx.system().shutdown_async();
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(HelloWorldComponent::new);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<p>We haven’t seen an example of channels, yet, but we will get there, when we are talking about local Kompact execution. Suffice to say here, that channels do not actually have a corresponding Rust struct in Kompact, but are simply a mental concept to think about how ports are connected to each other. Each port really just maintains a list of other ports it is connected to, and broadcasts all outgoing events to all of the connected ports. This is also why Kompact requires all events to implement the <code>Clone</code> trait. If cloning of an event for each connected component would be too expensive, it can often be a good alternative to simply share it immutably behind an <code>Arc</code>. Sharing events mutably behind an <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> is of course also possible, but generally discouraged, as contention on the <code>Mutex</code> could drag down system performance significantly.</p>
<p>These “broadcast by default”-semantics are probably the most fundamental difference between the Kompics component model, and the Actor model we will talk about in the next section.</p>
<h1 id="actors"><a class="header" href="#actors">Actors</a></h1>
<p>The Actor model is an old concept introduced by Carl Hewitt in 1973, but it only really has become popular with the Erlang language, as well as the Akka framework. In this model, the term for a <em>light-weight process with internal state</em> is “an actor”, though we will stick to calling the equivalents in Kompact a “component” to avoid having two names for the same thing.</p>
<h3 id="messages-and-references"><a class="header" href="#messages-and-references">Messages and References</a></h3>
<p>Actors communicate via <em>messages</em>, which really are the same things as <em>events</em>, except they are addressed to a particular actor. This addressing is done via a concept called <em>actor reference</em>, which is a shareable datastruct that identifies an actor in a way that messages can be sent directly to it. In Erlang this is implemented as a “pid”, while in actor there is a class <code>ActorRef</code>. Kompact also has a struct called <code>ActorRef</code>, which fulfills the same purpose on a local Kompact system. However, as we will discuss later in more details, Kompact explicitly differentiates possible remote actors at the type level. References to them are instances of <code>ActorPath</code> instead of <code>ActorRef</code>.</p>
<p>In Kompact, actors are statically typed with respect to the messages they can receive. That is, whenever you are implementing the <code>Actor</code> trait in Kompact for a component, you <strong>must</strong> specify a concrete <code>Message</code> type (as an associated type). Consequently, references to actors are also typed, so senders can only send valid messages to an actor. Thus a Kompact component which implements <code>Actor</code> with <code>type Message = M;</code> for some type <code>M</code> is referenced locally by an <code>ActorRef&lt;M&gt;</code>. The same is not true for <code>ActorPath</code>, as it is generally not possible to control what things are sent over a network, and so networked actors may have to deal with a wider range of possible incoming messages.</p>
<h3 id="actors-and-components"><a class="header" href="#actors-and-components">Actors and Components</a></h3>
<p>In Kompact every component is an actor and vice versa. Both the <code>Actor</code> (actually <code>ActorRaw</code>) and the <code>ComponentDefinition</code> trait need to be implemented in either case. But as we saw in the “Hello World”-example, the <code>Actor</code> trait can simply be derived when it’s not used by a component:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
struct HelloWorldComponent {
    ctx: ComponentContext&lt;Self&gt;,
}
<span class="boring">impl HelloWorldComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        HelloWorldComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ComponentLifecycle for HelloWorldComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Hello World!&quot;);
</span><span class="boring">        self.ctx.system().shutdown_async();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(HelloWorldComponent::new);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The derived code will produce an actor implementation with <code>type Message = Never;</code>, indicating that no local messages can be sent to it. However, network messages still can, but will simply be discarded. This avoids a common issue encountered in Erlang, where unhandled messages keep queuing up on ports forever.</p>
<p>If, say, we wanted to implement an actor variant of the “Hello World”-example, we could do so by implementing the <code>Actor</code> trait ourselves with some trivial type (e.g., the unit type <code>()</code>), as in:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span>use kompact::prelude::*;
use std::sync::Arc;

#[derive(ComponentDefinition)]
struct HelloWorldActor {
    ctx: ComponentContext&lt;Self&gt;,
}
impl HelloWorldActor {
    pub fn new() -&gt; Self {
        HelloWorldActor {
            ctx: ComponentContext::uninitialised(),
        }
    }
}
ignore_lifecycle!(HelloWorldActor);

impl Actor for HelloWorldActor {
    type Message = ();

    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
        info!(self.ctx.log(), &quot;Hello World!&quot;);
        self.ctx().system().shutdown_async();
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;We are ignoring network messages for now.&quot;);
    }
}
<span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let actor: Arc&lt;Component&lt;HelloWorldActor&gt;&gt; = system.create(HelloWorldActor::new);
</span><span class="boring">    system.start(&amp;actor);
</span><span class="boring">    let actor_ref: ActorRef&lt;()&gt; = actor.actor_ref();
</span><span class="boring">    actor_ref.tell(()); // send a unit type message to our actor
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_actor_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Of course, a unit message is not going to be produced by the Kompact runtime as a lifecycle event, so we must send it to our component after creating it, using the <code>tell(...)</code> function:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct HelloWorldActor {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl HelloWorldActor {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        HelloWorldActor {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(HelloWorldActor);
</span><span class="boring">
</span><span class="boring">impl Actor for HelloWorldActor {
</span><span class="boring">    type Message = ();
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Hello World!&quot;);
</span><span class="boring">        self.ctx().system().shutdown_async();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are ignoring network messages for now.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let actor: Arc&lt;Component&lt;HelloWorldActor&gt;&gt; = system.create(HelloWorldActor::new);
    system.start(&amp;actor);
    let actor_ref: ActorRef&lt;()&gt; = actor.actor_ref();
    actor_ref.tell(()); // send a unit type message to our actor
    system.await_termination();
}
<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_actor_helloworld() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Just to point out some of the particularities described above, we have annotated some types in the previous example. You can see that our <code>HelloWorldActor</code> is still created as an <code>Arc&lt;Component&lt;HelloWorldActor&gt;&gt;</code>, and also that the actor reference it produces is appropriately typed as <code>ActorRef&lt;()&gt;</code>.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin actor_helloworld
</code></pre>
</blockquote>
<h1 id="internal-state"><a class="header" href="#internal-state">Internal State</a></h1>
<p>Now that we have looked at the fundamental ideas of components and actors in isolation, let us look at something both our models share: The idea that every component/actor has its own internal state, which it has exclusive access to, without the need for synchronisation.</p>
<p>Access to internal state is what separates our components from being simple producers and consumers of messages and events, and makes them a powerful abstraction to build complicated systems, services, and applications with. But so far, our examples have not used any internal state at all – they simply terminated after the first event or message. In this chapter we will build something slightly less boring: a “Counter”.</p>
<h2 id="a-counter-example"><a class="header" href="#a-counter-example">A Counter Example</a></h2>
<p>(The pun in the title is mostly intended ;)</p>
<p>In this example we will make use of the simplest of state variables, that is integer counters. We count both messages and events separately, to see how the models work together. Since state that is never read is totally useless, we will also allow the counters to be queried. In fact, we will simply consider any update also a query and always respond with the current count.</p>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>First we need to set up the message types and ports:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>#[derive(Clone, Debug, PartialEq, Eq)]
struct CurrentCount {
    messages: u64,
    events: u64,
}
#[derive(Clone, Debug, PartialEq, Eq)]
struct CountMe;

struct CounterPort;
impl Port for CounterPort {
    type Indication = CurrentCount;
    type Request = CountMe;
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We will use the same types both for the port and actor communication, so <code>CountMe</code> and <code>CurrentCount</code> are both events and messages.
Since we want to provide a counter <em>service</em>, we’ll say that <code>CountMe</code> is going to be a <em>request</em> on the <code>CounterPort</code>, and <code>CurrentCount</code> is considered an <em>indication</em>. We could also design things the other way around, but this way it matches better with our “service” metaphor.</p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>Our internal state is going to be the two counters, plus the component context and a <em>provided</em> port instance for <code>CounterPort</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Counter {
    ctx: ComponentContext&lt;Self&gt;,
    counter_port: ProvidedPort&lt;CounterPort&gt;,
    msg_count: u64,
    event_count: u64,
}
impl Counter {
    pub fn new() -&gt; Self {
        Counter {
            ctx: ComponentContext::uninitialised(),
            counter_port: ProvidedPort::uninitialised(),
            msg_count: 0u64,
            event_count: 0u64,
        }
    }

    fn current_count(&amp;self) -&gt; CurrentCount {
        CurrentCount {
            messages: self.msg_count,
            events: self.event_count,
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also added a quick <code>current_count()</code> function, which access our internal state constructs a <code>CurrentCount</code> instance from it. This way, we can reuse the function for both event and message handling.</p>
<h3 id="counting-stuff"><a class="header" href="#counting-stuff">Counting Stuff</a></h3>
<p>In addition to counting the <code>CountMe</code> events and messages, we will also count control events incoming at the <code>ControlPort</code>. However, we will not respond to those. As mentioned previously, control events are handled indirectly via the <code>ComponentLifecycle</code> trait. On the other hand, for every <code>CountMe</code> event we will respond with the current state of both counters.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Counter {
    fn on_start(&amp;mut self) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a start event!&quot;);
        self.event_count += 1u64;
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
        self.event_count += 1u64;
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
        self.event_count += 1u64;
        Handled::Ok
    }
}

impl Provide&lt;CounterPort&gt; for Counter {
    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
        self.event_count += 1u64;
        self.counter_port.trigger(self.current_count());
        Handled::Ok
    }
}

impl Actor for Counter {
    type Message = Ask&lt;CountMe, CurrentCount&gt;;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        msg.complete(|_request| {
            info!(self.ctx.log(), &quot;Got a message!&quot;);
            self.msg_count += 1u64;
            self.current_count()
        })
        .expect(&quot;complete&quot;);
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;We are still ignoring network messages.&quot;);
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In the Kompics-style communication, we reply by simply triggering the <code>CurrentCount</code> event on our <code>counter_port</code> to whoever may listen. In the Actor-style, we need to know some reference to respond to. Since we are not responding to another component, but to the main-thread, we will use the <code>Ask</code>-pattern provided by Kompact, which converts our response message into a future that can be blocked on, until the result is available. We will describe this pattern in more detail in a <a href="introduction/../local/communication/ask.html">later section</a>.</p>
<h3 id="sending-stuff"><a class="header" href="#sending-stuff">Sending Stuff</a></h3>
<p>In order to count something, we must of course send some events and messages. We could do so in Actor-style by using <code>tell(...)</code> as before, but this time we want to wait for a response as well. So instead we will use <code>ask(...)</code> to automatically wrap our <code>CountMe</code> into an <code>Ask</code> instance as required by our actor’s implementation. In the Kompics-style, we can trigger on a port reference using <code>system.trigger_r(...)</code> instead. Whenever we get a response, we print it using the system’s logger:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let counter = system.create(Counter::new);
    system.start(&amp;counter);
    let actor_ref = counter.actor_ref();
    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
    for _i in 0..100 {
        let current_count = actor_ref.ask(CountMe).wait();
        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
    }
    for _i in 0..100 {
        system.trigger_r(CountMe, &amp;port_ref);
        // Where do the answers go?
    }
    std::thread::sleep(Duration::from_millis(1000));
    let current_count = actor_ref.ask(CountMe).wait();
    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
    system.shutdown().expect(&quot;shutdown&quot;);
    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
    std::thread::sleep(Duration::from_millis(10));
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>There are two things worth noting here:</p>
<ol>
<li>We are never getting any responses from the Kompics-style communication. There simply isn’t anything subscribed to our port, so the responses we are sending are simply dropped immediately. Kompact does not provide an <code>Ask</code>-equivalent for ports, since maintaining two mechanisms to achieve the same effect is inefficient, and this communication pattern is very unusual for the Kompics model.</li>
<li>We are also not getting any feedback when the events sent to the port are being handled. In order to see them being handled at all, we added a <code>thread::sleep(...)</code> invocation there. Events and messages in Kompact do <strong>not</strong> share the same queues and there are no ordering guarantees between them. Quite the opposite, in fact: Kompact ensures a certain amount of fairness between the two mechanisms and by the default will try to handle one message for every event it handles. Thus, without the sleep, we would see between one (the start event) and 101 events being counted when the final <code>Ask</code> returns. Even like this, it’s not guaranteed that any or all events are handled before the sleep expires. It’s just very likely, if your computer isn’t terribly slow.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin counters
</code></pre>
</blockquote>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>We have shown how Kompact handles internal state, and that it is automatically shared between the two different communication styles Kompact provides.</p>
<p>We have also seen, that there are no ordering guarantees between ports and message communication, something that is also true among different ports on the same component. It is thus important to remember that for applications, that require a certain sequence of events to be processed before proceeding, verifying completion must happen through the same communication style and even through the same port.</p>
<p>We will go through all the new parts introduced in this chapter again in detail in the following sections.</p>
<h1 id="local-kompact"><a class="header" href="#local-kompact">Local Kompact</a></h1>
<p>In this section we will introduce those features of Kompact in detail, which do not use the networking subsystem.</p>
<p>In particular, we will talk about different styles of <a href="local/communication/index.html">communication</a>, as well as Kompact’s built-in <a href="local/timers.html">timer facilities</a>, before describing some of the advanced options for Kompact systems, such as <a href="local/schedulers.html">schedulers</a>, <a href="local/logging.html">logging</a>, and <a href="local/configuration.html">configuration</a> in some detail. </p>
<h1 id="communication"><a class="header" href="#communication">Communication</a></h1>
<p>In this chapter we are going to introduce Kompact’s communication mechanisms in detail. We will do so by building up a longer example: A worker pool that, given an array of data, aggregates the data with a given function, while splitting the work over a predetermined number of worker components. The entry point to the pool is going to be a <code>Manager</code> component, which takes work requests and distributes them evenly over its worker pool, waits for the results to come in, aggregates the results, and finally responds to the original request. To make things a bit simpler, we will only deal with <code>u64</code> arrays and aggregation results for now, and we will assume that our aggregation functions are both <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> and <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a>. It should be easy to see how a more generic version can be implemented, that accepts other data types than <code>u64</code> and can avoid the commutativity requirement.</p>
<h1 id="messages-and-events"><a class="header" href="#messages-and-events">Messages and Events</a></h1>
<p>To begin with we must decide what we want to send over events and what over messages, and how exactly our message/event types should look like.</p>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<p>For the incoming work assignments, we want some kind of request-response-style communication pattern, so we can reply once the aggregation is complete. </p>
<p>So we will use Actor communication for this part of the example, so that we can later use the “ask”-pattern again from the main-thread. For now, we know that the result of the work is a <code>u64</code>, which we will wrap in a <code>WorkResult</code> struct for clarity of purpose. </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Clone, Debug)]
struct WorkResult(u64);
<span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also know that we need to pass some data array and an aggregation function when we make a request for work to be done. Since we will want to share the data later with our workers, we’ll put it into an atomic reference, i.e. <code>Arc&lt;[u64]&gt;</code>. For the aggregation function, we’ll simply pass a function pointer of type <code>fn(u64, &amp;u64) -&gt; u64</code>, which is the signature accepted by the <code>fold</code> function on an iterator. However, in order to start a <code>fold</code>, we also need a neutral element, which depends on the aggregation function. So we add that to the work request as a field as well. </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span>struct Work {
    data: Arc&lt;[u64]&gt;,
    merger: fn(u64, &amp;u64) -&gt; u64,
    neutral: u64,
}
<span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We will also use message based communicaton for the work assignments for the individual workers in the pool. Since we want to send a different message to each worker, message addressing is a better fit here, than component broadcasting. The <code>WorkPart</code> message is really basically the same as the <code>Work</code> message, except that we add the range, that this particular worker is supposed to aggregate, to it.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct WorkPart {
    data: Arc&lt;[u64]&gt;,
    range: Range&lt;usize&gt;,
    merger: fn(u64, &amp;u64) -&gt; u64,
    neutral: u64,
}
<span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> Both Actor messages and events must implement the <code>std::fmt::Debug</code> trait in Kompact. Since both <code>Work</code> and <code>WorkPart</code> contain function pointers, which do not have a sensible <code>Debug</code> representation, we implement it manually instead of deriving and simply put a <code>&quot;&lt;function&gt;&quot;</code> placeholder in its stead. Since our data arrays can be really big, we also only print their length.</p>
</blockquote>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>We will use Kompics-style communication for the results going from the workers to the manager. However, these are of the same type as the final result; a <code>u64</code> wrapped in a <code>WorkResult</code>. So all we have to do is add the <code>std::clone::Clone</code> trait, which is required for events.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Clone, Debug)]
struct WorkResult(u64);
<span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also need a port on which the <code>WorkResult</code> can travel; let’s call it a <code>WorkerPort</code>. Based on the naming, say a <code>Worker</code> <em>provides</em> the <code>WorkerPort</code> service, so messages from <code>Worker</code> to <code>Manager</code> are <em>indications</em>. Since we are using messages for requesting work to be done, we don’t need any <em>request</em> event on the <code>WorkerPort</code> and will just use the empty <code>Never</code> type again.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span>struct WorkerPort;
impl Port for WorkerPort {
    type Indication = WorkResult;
    type Request = Never;
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h1 id="state-1"><a class="header" href="#state-1">State</a></h1>
<p>Of course, we are going to need some component state to make this aggregation pool work out correctly.</p>
<h2 id="worker"><a class="header" href="#worker">Worker</a></h2>
<p>Our workers are pretty much stateless, apart from the component context and the <em>provided</em> <code>WorkerPort</code> instance. Both of these fields, we always simply initialise with the <code>new()</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Worker {
    ctx: ComponentContext&lt;Self&gt;,
    worker_port: ProvidedPort&lt;WorkerPort&gt;,
}
impl Worker {
    fn new() -&gt; Self {
        Worker {
            ctx: ComponentContext::uninitialised(),
            worker_port: ProvidedPort::uninitialised(),
        }
    }
}
<span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="manager"><a class="header" href="#manager">Manager</a></h2>
<p>The manager is a bit more complicated, of course. First of all it needs to know how many workers to start in the first place, and then keep track of all their instances (<code>Arc&lt;Component&lt;Worker&gt;&gt;</code>), so it can shut them down again later. We will also have the manager hang on to some actor references for each worker, so we don’t have to create a new one from the instances later. In fact, we will hold on to strong references (<code>ActorRefStrong&lt;WorkPart&gt;</code>), since we know the workers are not going to be deallocated anyway until we remove them from our vector of instances. </p>
<blockquote>
<p><strong>Note:</strong> Strong actor references are a bit more efficient than weak ones (<code>ActorRef&lt;_&gt;</code>), as they avoid upgrading some internal <code>std::sync::Weak</code> instances to <code>std::sync::Arc</code> instances on every message. However, they prevent deallocation of the target components, and should thus be used with care in dynamic Kompact systems.</p>
</blockquote>
<p>Additionally, we need to keep track of which request, if any, we are currently working on, so we can answer it later. We’ll make our lives easy for now, and only deal with one request at a time, but this mechanism can easily be extended for multiple outstanding requests with some additional bookkeeping.</p>
<p>We also need to put the partial results from each worker somewhere and figure out when we have seen all results, so we can combine them and reply to the request. We could simply keep a single <code>u64</code> accumulator value around, into which we always merge as soon as we get a result from a worker. In that case, we would also need a field to keep track of how many responses we have already received, so we know when we are done. Since we won’t have too many workers, however, we will simply put all results into a vector, and consider ourselves to be done when the vector contains <code>number_of_workers + 1</code> entries (we’ll get back to the <code>+1</code> part later).</p>
<p>And finally, of course, we also need a component context and we need to <em>require</em> the <code>WorkerPort</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Manager {
    ctx: ComponentContext&lt;Self&gt;,
    worker_port: RequiredPort&lt;WorkerPort&gt;,
    num_workers: usize,
    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
    result_accumulator: Vec&lt;u64&gt;,
}
impl Manager {
    fn new(num_workers: usize) -&gt; Self {
        Manager {
            ctx: ComponentContext::uninitialised(),
            worker_port: RequiredPort::uninitialised(),
            num_workers,
            workers: Vec::with_capacity(num_workers),
            worker_refs: Vec::with_capacity(num_workers),
            outstanding_request: None,
            result_accumulator: Vec::with_capacity(num_workers + 1),
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h1 id="handlers"><a class="header" href="#handlers">Handlers</a></h1>
<p>Now that we have set up all the messages, events, and the state, we need to actually implement the behaviours of the <code>Manager</code> and the <code>Worker</code>. That means we need to implement the <code>Actor</code> trait for both components, to handle the messages we are sending, and we also need to implement the appropriate event handling traits: <code>ComponentLifecycle</code> and <code>Require&lt;WorkerPort&gt;</code> for the <code>Manager</code>, and <code>Provide&lt;ControlPort&gt;</code> and <code>Provide&lt;WorkerPort&gt;</code> for the <code>Worker</code>.</p>
<h2 id="worker-1"><a class="header" href="#worker-1">Worker</a></h2>
<h3 id="actor"><a class="header" href="#actor">Actor</a></h3>
<p>Since the worker is stateless, its implementation is really simple. It’s basically just a francy wrapper around a slice <code>fold</code>. That is, whenever we get a <code>WorkPart</code> message on our <code>receive_local(...)</code> function from the <code>Actor</code> trait, we simply take a slice of the range we were allocated to work on, and then call <code>fold(msg.neutral, msg.merger)</code> on it to produce the desired <code>u64</code> result. And then we simply wrap the result into a <code>WorkResult</code>, which we trigger on our instance of <code>WorkerPort</code> so it gets back to the manager.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span>impl Actor for Worker {
    type Message = WorkPart;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        let my_slice = &amp;msg.data[msg.range];
        let res = my_slice.iter().fold(msg.neutral, msg.merger);
        self.worker_port.trigger(WorkResult(res));
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="ports"><a class="header" href="#ports">Ports</a></h3>
<p>We also need to provide implementations for <code>ComponentLifecycle</code> and <code>WorkerPort</code>, because they are expected by Kompact. However, we don’t actually want to do anything interesting with them. So we are going to use the <code>ignore_lifecycle!(Worker)</code> macro to generate an empty <code>ComponentLifecycle</code> implementation, and similarly use the <code>ignore_requests!(WorkerPort, Worker)</code> macro to generate an empty <code>Provide&lt;WorkerPort&gt;</code> implementation.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>ignore_lifecycle!(Worker);
ignore_requests!(WorkerPort, Worker);
<span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="manager-1"><a class="header" href="#manager-1">Manager</a></h2>
<p>The manager needs to do three things: 1) Manage the worker pool, 2) split up work requests and send chunks to workers, and 3) collect the results from the workers, combine them, and reply with the final result.</p>
<p>We will deal with 1) in a <code>ComponentLifecycle</code> handler, and with 3) in the handler for <code>WorkerPort</code>, of course. For 2), however, we want to use the “ask”-pattern again, so we will look at that in the next section.</p>
<h3 id="componentlifecycle"><a class="header" href="#componentlifecycle">ComponentLifecycle</a></h3>
<p>Whenever the manager is started (or restarted after being paused) we must populate our pool of workers and connect them appropriately. We can create new components from within an actor by using the <code>system()</code> reference from the <code>ComponentContext</code>. Of course, we must also remember to actually start the new components, or nothing will happen when we send messages to them later. Additionally, we must fill the appropriate state with component instances and actor references, as we discussed in the previous section.</p>
<blockquote>
<p><strong>Note:</strong> As opposed to many other Actor or Component frameworks, Kompact does <strong>not</strong> produce a hierarchical structure when calling <code>create(...)</code> from within a component. This is because Kompact doesn’t have such a strong focus on error handling and supervision as other systems, and maintaining a hierarchical structure is more complicated than maintaining a flat one.</p>
</blockquote>
<p>When the manager gets shut down or paused we will clean up the worker pool completely. Even if we are only temporarily paused, it is better to reduce our footprint by cleaning up, than forgetting to do so and hanging on to all the pool memory while not running anyway.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Manager {
    fn on_start(&amp;mut self) -&gt; Handled {
        // set up our workers
        for _i in 0..self.num_workers {
            let worker = self.ctx.system().create(Worker::new);
            worker.connect_to_required(self.worker_port.share());
            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
            self.ctx.system().start(&amp;worker);
            self.workers.push(worker);
            self.worker_refs.push(worker_ref);
        }
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        // clean up after ourselves
        self.worker_refs.clear();
        let system = self.ctx.system();
        self.workers.drain(..).for_each(|worker| {
            system.stop(&amp;worker);
        });
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> We are getting the required <code>ActorRefStrong&lt;WorkPart&gt;</code> by first calling <code>actor_ref()</code> on a worker instance and then upgrading the result via <code>hold()</code> from an <code>ActorRef&lt;WorkPart&gt;</code> to <code>ActorRefStrong&lt;WorkPart&gt;</code>. This returns a <code>Result</code>, as upgrading is impossible if the component is already deallocated. However, since we are holding on to the actual instance of the component here as well, we <em>know</em> it’s not deallocated, yet, and <code>hold()</code> cannot fail, so we simply call <code>expect(...)</code> to unwrap it.</p>
</blockquote>
<h3 id="worker-port"><a class="header" href="#worker-port">Worker Port</a></h3>
<p>Whenever we get a <code>WorkResult</code> from a worker, we will temporarily store it in <code>self.result_accumulator</code>, as long we have an outstanding request. After every new addition to the accumulator, we check if we have gotten all responses with <code>self.result_accumulator.len() == (self.num_workers + 1)</code> (again, more on the <code>+ 1</code> later). If that is so, we will do the final aggregation on the accumulator via <code>fold(work.neutral, work.merger)</code> and then <code>reply(...)</code> to the outstanding request. Of course, we must also clean up after ourselves, i.e. reset the <code>self.outstanding_request</code> to <code>None</code> and clear out <code>self.result_accumulator</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span>impl Require&lt;WorkerPort&gt; for Manager {
    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
        if self.outstanding_request.is_some() {
            self.result_accumulator.push(event.0);
            if self.result_accumulator.len() == (self.num_workers + 1) {
                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
                let work: &amp;Work = ask.request();
                let res = self
                    .result_accumulator
                    .iter()
                    .fold(work.neutral, work.merger);
                self.result_accumulator.clear();
                let reply = WorkResult(res);
                ask.reply(reply).expect(&quot;reply&quot;);
            }
        } else {
            error!(
                self.log(),
                &quot;Got a response without an outstanding promise: {:?}&quot;, event
            );
        }
        Handled::Ok
    }
}
<span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h1 id="ask"><a class="header" href="#ask">Ask</a></h1>
<p>We have now mentioned multiple times that we want to use the “ask”-pattern again, as we did in the <a href="local/communication/../../introduction/state.html">introduction</a> briefly already. The “ask”-pattern is simply a mechanism to translate from message-based communication into a thread- or future-based model. It does so by coupling a request message with a <em>future</em> that is to be fulfilled with a response for the request. On the sending thread, the one with the future, the result can then be waited for at some point, when it is needed, via blocking, for example. The receiving Actor, on the other hand, gets a combination of the request message with a <em>promise</em>, an <code>Ask</code> instance, that it can fulfill with the response at any later time. Thus, the <code>Message</code> type for such an actor is not <code>Request</code> but rather <code>Ask&lt;Request, Response&gt;</code>.</p>
<blockquote>
<p><strong>Note:</strong> The futures returned by Kompact’s “ask”-API conform with Rust’s built-in async/await mechanism. On top of that Kompact offers some convenience methods that can be called on a <code>KFuture</code> to make the common case of blocking on the result easier.</p>
</blockquote>
<h2 id="manager-2"><a class="header" href="#manager-2">Manager</a></h2>
<p>The <code>Message</code> type for the manager is thus <code>Ask&lt;Work, WorkResponse&gt;</code>, which we already saw when describing its <a href="local/communication/state.html">state</a>. In order to access the actual <code>Work</code> instance in our <code>receive_local(...)</code> implementation, we use the <code>Ask::request()</code> function. </p>
<p>We then must distribute the work more or less evenly over the available workers. If no workers are available, the manager simply does all the work itself. Otherwise we’ll figure out what constitutes and “equal share” (i.e. the <code>stride</code>) and then use it to step through the indices into the data, producing sub-ranges, which we send to each worker immediately. Since it may sometimes happen due to rounding that we have a tiny bit of work left at the end, we just do that at the manager and put it directly into the <code>self.result_accumulator</code>. This extra work, it the reason for the previously mentioned <code>+ 1</code> whenever we are considering the length of the <code>self.result_accumulator</code>. It is simply the manager’s share of the work. In order to keep this length consistent, we will simply push the <code>work.neutral</code> element whenever the manager actually doesn’t do any work. Finally, we need to remember to store the request in <code>self.outstanding_request</code> so we can reply to it later when all responses have arrived.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span>impl Actor for Manager {
    type Message = Ask&lt;Work, WorkResult&gt;;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        assert!(
            self.outstanding_request.is_none(),
            &quot;One request at a time, please!&quot;
        );
        let work: &amp;Work = msg.request();
        if self.num_workers == 0 {
            // manager gotta work itself -&gt; very unhappy manager
            let res = work.data.iter().fold(work.neutral, work.merger);
            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
        } else {
            let len = work.data.len();
            let stride = len / self.num_workers;
            let mut start = 0usize;
            let mut index = 0;
            while start &lt; len &amp;&amp; index &lt; self.num_workers {
                let end = len.min(start + stride);
                let range = start..end;
                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
                let msg = WorkPart::from(work, range);
                let worker = &amp;self.worker_refs[index];
                worker.tell(msg);
                start += stride;
                index += 1;
            }
            if start &lt; len {
                // manager just does the rest itself
                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
                self.result_accumulator.push(res);
            } else {
                // just put a neutral element in there, so our count is right in the end
                self.result_accumulator.push(work.neutral);
            }
            self.outstanding_request = Some(msg);
        }
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
    }
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="sending-work"><a class="header" href="#sending-work">Sending Work</a></h2>
<p>When sending work to the manager from the main-thread, we can construct the required <code>Ask</code> instance with <code>ActorRef::ask(...)</code>. Since we only want to handle a single request at a time, we will immediately <code>wait()</code> for the result of the future.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span>    let res = manager_ref.ask(work).wait();
<span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> For situations where the <code>Ask</code> instance is nested, for example, into an enum, Kompact offers the <code>ActorRef::ask_with</code> function. Instead of a <code>Request</code> value, <code>ask_with</code> expects a <em>function</em> that takes a <code>KPromise&lt;Result&gt;</code> and produces the Actor’s <code>Message</code> type. This also allows for custom <code>Ask</code> variants with more fields, for example.</p>
</blockquote>
<h1 id="system"><a class="header" href="#system">System</a></h1>
<p>In order to run any Kompact component, we need a <code>KompactSystem</code>. The system manages the runtime variables, the thread pool, logging, and many aspects of the Kompact. Such a system is created from a <code>KompactConfig</code> via the <code>build()</code> function. The config instance allows customisation of many parameters of the runtime, which we will discuss in upcoming sections. For now, the <code>default()</code> instance will do just fine.  It creates a thread pool with one thread for each CPU core, as reported by <a href="https://crates.io/crates/num_cpus">num_cpus</a>, schedules fairly between messags and events, and does some internal message/event batching to improve performance.</p>
<blockquote>
<p><strong>Note:</strong> As opposed to Kompics, in Kompact it is perfectly viable to have multiple systems running in the same process, for example with different configurations.</p>
</blockquote>
<p>When a Kompact system is not used anymore it should be shut down via the <code>shutdown()</code> function. Sometimes it is a component instead of the main-thread that must decide when to shut down. In that case, it can use <code>self.ctx.system().shutdown_async()</code> and the main-thread can wait for this to complete with <code>await_termination()</code>. </p>
<blockquote>
<p><strong>Note:</strong> Neither <code>shutdown_async()</code> nor <code>await_termination()</code> has a particularly efficient implementation, as this should be a relatively rare thing to do in the lifetime of a Kompact system, and thus doesn’t warrant optimisation at this point. That also means, though, that <code>await_termination()</code> should definitely <strong>not</strong> be used as a timing marker in a benchmark, as <em>some</em> people have done with the equivalent Akka API.</p>
</blockquote>
<h2 id="tying-things-together"><a class="header" href="#tying-things-together">Tying Things Together</a></h2>
<p>For our worker pool example, we will simply use the default configuration, and start a <code>Manager</code> component with a configurable number of workers. We then create some data array of a configurable size and send a work request with it and an aggregation function to the manager instance. We’ll use simple addition with overflow as our aggregation function, which means our neutral element is <code>0u64</code>. The data array we’ll generate is simply the integers from <code>1</code> to <code>data_size</code>, which means our aggregate will actually calculate a <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular number</a> (modulo overflows, for which we probably don’t have enough memory for the data array anyway). Since that particular number has a much simpler solution, i.e. \( \sum_{k=1}^n k = \frac{n\cdot(n+1)}{2} \), we will also use an assertion to verify we are actually producing the right result (again, this probably won’t work if we actually do overflow during aggregration, but oh well...details ;).</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span>fn run_task(num_workers: usize, data_size: usize) {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let manager = system.create(move || Manager::new(num_workers));
    system.start(&amp;manager);
    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);

    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
    let work = Work::with(data, overflowing_sum, 0u64);
    println!(&quot;Sending request...&quot;);
    let res = manager_ref.ask(work).wait();
    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
    assert_eq!(triangular_number(data_size as u64), res.0);
    system.shutdown().expect(&quot;shutdown&quot;);
}

fn triangular_number(n: u64) -&gt; u64 {
    (n * (n + 1u64)) / 2u64
}

fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
    lhs.overflowing_add(*rhs).0
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now all we are missing are values for the two parameters; <code>num_workers</code> and <code>data_size</code>. We’ll read those from command-line so we can play around with them.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    assert_eq!(
        3,
        args.len(),
        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
    );
    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
    run_task(num_workers, data_size);
}
<span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now we can run our example, by giving it some parameters, say <code>4 100000</code> to run 4 workers and calculate the 100000th triangular number. If you play with larger numbers you’ll see that a) it uses more and more memory and b) it will spend most of its time creating the original array, as our aggregration function is very simple and parallelisable, while data creation is done sequentially. Of course, in a real worker pool we’d probably read data from disk somewhere or from an already memory resident set, perhaps. But this is good enough for our little example.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin workers 4 100000
</code></pre>
</blockquote>
<h1 id="senders"><a class="header" href="#senders">Senders</a></h1>
<p>The one communication-related thing we haven’t touched, yet, is how to do request-response style communication among Actors. The <a href="local/communication/ask.html">“ask”-pattern</a> gave us request-reponse between an Actor and some arbitrary (non-pool) thread, <a href="local/communication/../../introduction/components.html">ports</a> basically give us some form request-response between <em>request</em> and <em>indication</em> events (with some broadcasting semantic caveats, of course). But for Actor to Actor communication, we have not seen anything of this sort, yet. In fact, you may have noticed that <code>receive_local(...)</code> does not actually give us any <em>sender</em> information, such as an <code>ActorRef</code>. Neither is this available via the component context as would be the case in Akka. </p>
<p>In Kompact, for local messages at least, sender information must be passed explicitly. This is for two reasons:</p>
<ol>
<li>It avoids creating an <code>ActorRef</code> for every message when it’s not needed, since actor references are not trivially cheap to create.</li>
<li>It allows the sender reference to be typed with the appropriate message type.</li>
</ol>
<p>This design gives us basically two variants to do request-reponse. If we know we are always going to respond to the same component instance, the most efficient thing to do is to get a reference to it once and then just keep it around as part of our internal state. This avoids constantly creating actor references, and is pretty efficient. If, however, we must respond to multiple different actors, which is often the case, we must make the sender reference part of the request message. We can do that either by adding a field to our custom message type, or simply wrapping our custom message type into the Kompact provided <code>WithSender</code> struct. <code>WithSender</code> is really the same idea as <code>Ask</code>, replacing the <code>KPromise&lt;Response&gt;</code> with an <code>ActorRef&lt;Response&gt;</code> (yes, there is also <code>WithSenderStrong</code> using an <code>ActorRefStrong</code> instead).</p>
<h2 id="workers-with-senders"><a class="header" href="#workers-with-senders">Workers with Senders</a></h2>
<p>To illustrate this mechanism we are going to rewrite the Workers example from the previous sections to use <code>WithSender</code> instead of the <code>WorkerPort</code> communication. We will use <code>WithSender</code> here, instead of a stored manager actor reference, to illustrate the point, but it should be clear that the latter will be more efficient as we <em>always</em> reply to the manager.</p>
<p>First we remove all mentions of <code>WorkerPort</code>, of course. Then we change the worker’s <code>Message</code> type to <code>WithSender&lt;WorkPart, ManagerMessage&gt;</code>. Why <code>ManagerMessage</code> and not <code>WorkResult</code>? Well, since all communication with the manager now happens via messages, we need to differentiate between messages from the main-thread, which are of type <code>Ask&lt;Work, WorkResult&gt;</code> and messages from the worker, which are of type <code>WorkResult</code>. Since we can only have a single <code>Message</code> type, <code>ManagerMessage</code> is simply an enum of both options.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">
</span>#[derive(Debug)]
enum ManagerMessage {
    Work(Ask&lt;Work, WorkResult&gt;),
    Result(WorkResult),
}
<span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WithSender&lt;WorkPart, ManagerMessage&gt;&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Work(msg) =&gt; {
</span><span class="boring">                assert!(
</span><span class="boring">                    self.outstanding_request.is_none(),
</span><span class="boring">                    &quot;One request at a time, please!&quot;
</span><span class="boring">                );
</span><span class="boring">                let work: &amp;Work = msg.request();
</span><span class="boring">                if self.num_workers == 0 {
</span><span class="boring">                    // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">                    let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">                    msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">                } else {
</span><span class="boring">                    let len = work.data.len();
</span><span class="boring">                    let stride = len / self.num_workers;
</span><span class="boring">                    let mut start = 0usize;
</span><span class="boring">                    let mut index = 0;
</span><span class="boring">                    while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                        let end = len.min(start + stride);
</span><span class="boring">                        let range = start..end;
</span><span class="boring">                        info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                        let msg = WorkPart::from(work, range);
</span><span class="boring">                        let worker = &amp;self.worker_refs[index];
</span><span class="boring">                        worker.tell(WithSender::from(msg, self));
</span><span class="boring">                        start += stride;
</span><span class="boring">                        index += 1;
</span><span class="boring">                    }
</span><span class="boring">                    if start &lt; len {
</span><span class="boring">                        // manager just does the rest itself
</span><span class="boring">                        let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.push(res);
</span><span class="boring">                    } else {
</span><span class="boring">                        // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                        self.result_accumulator.push(work.neutral);
</span><span class="boring">                    }
</span><span class="boring">                    self.outstanding_request = Some(msg);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Result(msg) =&gt; {
</span><span class="boring">                if self.outstanding_request.is_some() {
</span><span class="boring">                    self.result_accumulator.push(msg.0);
</span><span class="boring">                    if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                        let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                        let work: &amp;Work = ask.request();
</span><span class="boring">                        let res = self
</span><span class="boring">                            .result_accumulator
</span><span class="boring">                            .iter()
</span><span class="boring">                            .fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.clear();
</span><span class="boring">                        let reply = WorkResult(res);
</span><span class="boring">                        ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    error!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Got a response without an outstanding promise: {:?}&quot;, msg
</span><span class="boring">                    );
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WithSender&lt;WorkPart, ManagerMessage&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range.clone()];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        msg.reply(ManagerMessage::Result(WorkResult(res)));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref
</span><span class="boring">        .ask_with(|promise| ManagerMessage::Work(Ask::new(promise, work)))
</span><span class="boring">        .wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Thus, when the worker wants to <code>reply(...)</code> with a <code>WorkResult</code> it actually needs to wrap it in a <code>ManagerMessage</code> instance or the compiler is going to reject it.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Work(Ask&lt;Work, WorkResult&gt;),
</span><span class="boring">    Result(WorkResult),
</span><span class="boring">}
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WithSender&lt;WorkPart, ManagerMessage&gt;&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Work(msg) =&gt; {
</span><span class="boring">                assert!(
</span><span class="boring">                    self.outstanding_request.is_none(),
</span><span class="boring">                    &quot;One request at a time, please!&quot;
</span><span class="boring">                );
</span><span class="boring">                let work: &amp;Work = msg.request();
</span><span class="boring">                if self.num_workers == 0 {
</span><span class="boring">                    // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">                    let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">                    msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">                } else {
</span><span class="boring">                    let len = work.data.len();
</span><span class="boring">                    let stride = len / self.num_workers;
</span><span class="boring">                    let mut start = 0usize;
</span><span class="boring">                    let mut index = 0;
</span><span class="boring">                    while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                        let end = len.min(start + stride);
</span><span class="boring">                        let range = start..end;
</span><span class="boring">                        info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                        let msg = WorkPart::from(work, range);
</span><span class="boring">                        let worker = &amp;self.worker_refs[index];
</span><span class="boring">                        worker.tell(WithSender::from(msg, self));
</span><span class="boring">                        start += stride;
</span><span class="boring">                        index += 1;
</span><span class="boring">                    }
</span><span class="boring">                    if start &lt; len {
</span><span class="boring">                        // manager just does the rest itself
</span><span class="boring">                        let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.push(res);
</span><span class="boring">                    } else {
</span><span class="boring">                        // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                        self.result_accumulator.push(work.neutral);
</span><span class="boring">                    }
</span><span class="boring">                    self.outstanding_request = Some(msg);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Result(msg) =&gt; {
</span><span class="boring">                if self.outstanding_request.is_some() {
</span><span class="boring">                    self.result_accumulator.push(msg.0);
</span><span class="boring">                    if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                        let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                        let work: &amp;Work = ask.request();
</span><span class="boring">                        let res = self
</span><span class="boring">                            .result_accumulator
</span><span class="boring">                            .iter()
</span><span class="boring">                            .fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.clear();
</span><span class="boring">                        let reply = WorkResult(res);
</span><span class="boring">                        ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    error!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Got a response without an outstanding promise: {:?}&quot;, msg
</span><span class="boring">                    );
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">
</span>impl Actor for Worker {
    type Message = WithSender&lt;WorkPart, ManagerMessage&gt;;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        let my_slice = &amp;msg.data[msg.range.clone()];
        let res = my_slice.iter().fold(msg.neutral, msg.merger);
        msg.reply(ManagerMessage::Result(WorkResult(res)));
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref
</span><span class="boring">        .ask_with(|promise| ManagerMessage::Work(Ask::new(promise, work)))
</span><span class="boring">        .wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In the manager we must first update our state to reflect the new message (and thus reference) types.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Work(Ask&lt;Work, WorkResult&gt;),
</span><span class="boring">    Result(WorkResult),
</span><span class="boring">}
</span>#[derive(ComponentDefinition)]
struct Manager {
    ctx: ComponentContext&lt;Self&gt;,
    num_workers: usize,
    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
    worker_refs: Vec&lt;ActorRefStrong&lt;WithSender&lt;WorkPart, ManagerMessage&gt;&gt;&gt;,
    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
    result_accumulator: Vec&lt;u64&gt;,
}
<span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Work(msg) =&gt; {
</span><span class="boring">                assert!(
</span><span class="boring">                    self.outstanding_request.is_none(),
</span><span class="boring">                    &quot;One request at a time, please!&quot;
</span><span class="boring">                );
</span><span class="boring">                let work: &amp;Work = msg.request();
</span><span class="boring">                if self.num_workers == 0 {
</span><span class="boring">                    // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">                    let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">                    msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">                } else {
</span><span class="boring">                    let len = work.data.len();
</span><span class="boring">                    let stride = len / self.num_workers;
</span><span class="boring">                    let mut start = 0usize;
</span><span class="boring">                    let mut index = 0;
</span><span class="boring">                    while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                        let end = len.min(start + stride);
</span><span class="boring">                        let range = start..end;
</span><span class="boring">                        info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                        let msg = WorkPart::from(work, range);
</span><span class="boring">                        let worker = &amp;self.worker_refs[index];
</span><span class="boring">                        worker.tell(WithSender::from(msg, self));
</span><span class="boring">                        start += stride;
</span><span class="boring">                        index += 1;
</span><span class="boring">                    }
</span><span class="boring">                    if start &lt; len {
</span><span class="boring">                        // manager just does the rest itself
</span><span class="boring">                        let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.push(res);
</span><span class="boring">                    } else {
</span><span class="boring">                        // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                        self.result_accumulator.push(work.neutral);
</span><span class="boring">                    }
</span><span class="boring">                    self.outstanding_request = Some(msg);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Result(msg) =&gt; {
</span><span class="boring">                if self.outstanding_request.is_some() {
</span><span class="boring">                    self.result_accumulator.push(msg.0);
</span><span class="boring">                    if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                        let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                        let work: &amp;Work = ask.request();
</span><span class="boring">                        let res = self
</span><span class="boring">                            .result_accumulator
</span><span class="boring">                            .iter()
</span><span class="boring">                            .fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.clear();
</span><span class="boring">                        let reply = WorkResult(res);
</span><span class="boring">                        ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    error!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Got a response without an outstanding promise: {:?}&quot;, msg
</span><span class="boring">                    );
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WithSender&lt;WorkPart, ManagerMessage&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range.clone()];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        msg.reply(ManagerMessage::Result(WorkResult(res)));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref
</span><span class="boring">        .ask_with(|promise| ManagerMessage::Work(Ask::new(promise, work)))
</span><span class="boring">        .wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also remove the port connection logic from the <code>ComponentLifecycle</code> handler. Then we change the <code>Message</code> type of the manager to <code>ManagerMessage</code> and match on the <code>ManagerMessage</code> variant in the <code>receive_local(...)</code> function. For the <code>ManagerMessage::Work</code> variant, we basically do the same thing as in the old <code>receive_local(...)</code> function, except that we construct a <code>WithSender</code> instance from the <code>WorkPart</code> instead of sending it directly to the worker. We then simply copy the code from the old <code>WorkResult</code> handler into the branch for <code>ManagerMessage::Result</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Work(Ask&lt;Work, WorkResult&gt;),
</span><span class="boring">    Result(WorkResult),
</span><span class="boring">}
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WithSender&lt;WorkPart, ManagerMessage&gt;&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Actor for Manager {
    type Message = ManagerMessage;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        match msg {
            ManagerMessage::Work(msg) =&gt; {
                assert!(
                    self.outstanding_request.is_none(),
                    &quot;One request at a time, please!&quot;
                );
                let work: &amp;Work = msg.request();
                if self.num_workers == 0 {
                    // manager gotta work itself -&gt; very unhappy manager
                    let res = work.data.iter().fold(work.neutral, work.merger);
                    msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
                } else {
                    let len = work.data.len();
                    let stride = len / self.num_workers;
                    let mut start = 0usize;
                    let mut index = 0;
                    while start &lt; len &amp;&amp; index &lt; self.num_workers {
                        let end = len.min(start + stride);
                        let range = start..end;
                        info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
                        let msg = WorkPart::from(work, range);
                        let worker = &amp;self.worker_refs[index];
                        worker.tell(WithSender::from(msg, self));
                        start += stride;
                        index += 1;
                    }
                    if start &lt; len {
                        // manager just does the rest itself
                        let res = work.data[start..len].iter().fold(work.neutral, work.merger);
                        self.result_accumulator.push(res);
                    } else {
                        // just put a neutral element in there, so our count is right in the end
                        self.result_accumulator.push(work.neutral);
                    }
                    self.outstanding_request = Some(msg);
                }
            }
            ManagerMessage::Result(msg) =&gt; {
                if self.outstanding_request.is_some() {
                    self.result_accumulator.push(msg.0);
                    if self.result_accumulator.len() == (self.num_workers + 1) {
                        let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
                        let work: &amp;Work = ask.request();
                        let res = self
                            .result_accumulator
                            .iter()
                            .fold(work.neutral, work.merger);
                        self.result_accumulator.clear();
                        let reply = WorkResult(res);
                        ask.reply(reply).expect(&quot;reply&quot;);
                    }
                } else {
                    error!(
                        self.log(),
                        &quot;Got a response without an outstanding promise: {:?}&quot;, msg
                    );
                }
            }
        }
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
    }
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WithSender&lt;WorkPart, ManagerMessage&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range.clone()];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        msg.reply(ManagerMessage::Result(WorkResult(res)));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref
</span><span class="boring">        .ask_with(|promise| ManagerMessage::Work(Ask::new(promise, work)))
</span><span class="boring">        .wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The <code>receive_local(...)</code> function is getting pretty long, so we should probably decompose it into smaller private functions if we actually wanted to maintain this code.</p>
<p>Now finally, when we want to send the <code>Ask</code> from the main-thread, we also need to wrap it into <code>ManagerMessage::Work</code>. This prevents us from simply using <code>ActorRef::ask</code>, as it only produces an  <code>Ask</code> instance, not our wrapper <code>ManagerMessage</code>. This gets us back to previously mentioned <code>ActorRef::ask_with</code> function, which allows us to construct our <code>Ask</code> instance and put it into our wrapper ourselves. If we were to use this construction in many places throughout or code, it would likely be a good idea to use a constructor function on <code>ManagerMessage</code> to map the <code>promise</code> and the <code>work</code> values to the proper structure.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Work(Ask&lt;Work, WorkResult&gt;),
</span><span class="boring">    Result(WorkResult),
</span><span class="boring">}
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WithSender&lt;WorkPart, ManagerMessage&gt;&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Work(msg) =&gt; {
</span><span class="boring">                assert!(
</span><span class="boring">                    self.outstanding_request.is_none(),
</span><span class="boring">                    &quot;One request at a time, please!&quot;
</span><span class="boring">                );
</span><span class="boring">                let work: &amp;Work = msg.request();
</span><span class="boring">                if self.num_workers == 0 {
</span><span class="boring">                    // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">                    let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">                    msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">                } else {
</span><span class="boring">                    let len = work.data.len();
</span><span class="boring">                    let stride = len / self.num_workers;
</span><span class="boring">                    let mut start = 0usize;
</span><span class="boring">                    let mut index = 0;
</span><span class="boring">                    while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                        let end = len.min(start + stride);
</span><span class="boring">                        let range = start..end;
</span><span class="boring">                        info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                        let msg = WorkPart::from(work, range);
</span><span class="boring">                        let worker = &amp;self.worker_refs[index];
</span><span class="boring">                        worker.tell(WithSender::from(msg, self));
</span><span class="boring">                        start += stride;
</span><span class="boring">                        index += 1;
</span><span class="boring">                    }
</span><span class="boring">                    if start &lt; len {
</span><span class="boring">                        // manager just does the rest itself
</span><span class="boring">                        let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.push(res);
</span><span class="boring">                    } else {
</span><span class="boring">                        // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                        self.result_accumulator.push(work.neutral);
</span><span class="boring">                    }
</span><span class="boring">                    self.outstanding_request = Some(msg);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Result(msg) =&gt; {
</span><span class="boring">                if self.outstanding_request.is_some() {
</span><span class="boring">                    self.result_accumulator.push(msg.0);
</span><span class="boring">                    if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                        let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                        let work: &amp;Work = ask.request();
</span><span class="boring">                        let res = self
</span><span class="boring">                            .result_accumulator
</span><span class="boring">                            .iter()
</span><span class="boring">                            .fold(work.neutral, work.merger);
</span><span class="boring">                        self.result_accumulator.clear();
</span><span class="boring">                        let reply = WorkResult(res);
</span><span class="boring">                        ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    error!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Got a response without an outstanding promise: {:?}&quot;, msg
</span><span class="boring">                    );
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WithSender&lt;WorkPart, ManagerMessage&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range.clone()];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        msg.reply(ManagerMessage::Result(WorkResult(res)));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span>    let res = manager_ref
        .ask_with(|promise| ManagerMessage::Work(Ask::new(promise, work)))
        .wait();
<span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>At this point we should able to run the example again, and see the same behaviour as before.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin workers_sender 4 100000
</code></pre>
</blockquote>
<h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>Kompact comes with build-in support for scheduling some execution to happen in the future. Such scheduled execution can be either one-off or periodically repeating. Concretely, the scheduling API allows developers to subscribe a handler closure to the firing of a timeout after some <code>Duration</code>. This closure takes two arguments: </p>
<ol>
<li>A new mutable reference to the scheduling component, so that its state can be accessed safely from within the closure, and</li>
<li>a handle to the timeout being triggered, so that different timeouts can be differentiated. The handle is an opaque type named <code>ScheduledTimer</code>, but currently is simply a wrapper around a <code>Uuid</code> instance assigned (and returned) when the timeout is originally scheduled.</li>
</ol>
<h2 id="batching-example"><a class="header" href="#batching-example">Batching Example</a></h2>
<p>In order to show the scheduling API, we will develop a batching component, called a <code>Buncher</code>, that collects received events locally until either a pre-configured batch size is reached or a defined timeout expires, whichever happens first. Once the batch is closed by either condition, a new <code>Batch</code> event is triggered on the port containing all the collected events.</p>
<p>Since there are two variants of scheduled execution, we will also implement two variants of the batching component:</p>
<ol>
<li>The <em>regular</em> variant simply schedules a periodic timeout once, and then fires a batch whenever the timeout expires, no matter how long ago the last batch was triggered (which could be fairly recently if it was triggered by the batch size condition).</li>
<li>The <em>adaptive</em> variant schedules a new one-off timeout for every batch. If a batch is triggered by size instead of time, this variant will cancel the current timeout and schedule a new one with the full duration again. This approach is more practical, as it results in more evenly sized batches than the <em>regular</em> variant.</li>
</ol>
<h3 id="shared-code"><a class="header" href="#shared-code">Shared Code</a></h3>
<p>Both implementations share the basic events and ports involved. They also both use a printer component for <code>Batch</code> events, which simply logs the size of each batch so we can see it during execution.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use kompact::prelude::*;

#[derive(Clone, Debug)]
pub struct Ping(pub u64);

#[derive(Clone, Debug)]
pub struct Batch(pub Vec&lt;Ping&gt;);

pub struct Batching;
impl Port for Batching {
    type Indication = Batch;
    type Request = Ping;
}

#[derive(ComponentDefinition, Actor)]
pub struct BatchPrinter {
    ctx: ComponentContext&lt;Self&gt;,
    batch_port: RequiredPort&lt;Batching&gt;,
}
impl BatchPrinter {
    pub fn new() -&gt; Self {
        BatchPrinter {
            ctx: ComponentContext::uninitialised(),
            batch_port: RequiredPort::uninitialised(),
        }
    }
}

ignore_lifecycle!(BatchPrinter);

impl Require&lt;Batching&gt; for BatchPrinter {
    fn handle(&amp;mut self, batch: Batch) -&gt; Handled {
        info!(self.log(), &quot;Got a batch with {} Pings.&quot;, batch.0.len());
        Handled::Ok
    }
}
</code></pre>
<p>They’ll also really use the same running code, even though its repeated in each file so it picks the correct implementation. In either case, we set up the <code>Buncher</code> and the <code>BatchPrinter</code> in a default system, connect them via <code>biconnect_components(...)</code> and then send them two waves of <code>Ping</code> events. The first wave comes around every millisecond, depending on concrete thread scheduling by the OS, while the second comes around every second millisecond.
With a batch size of 100 and a timeout of 150ms we will see mostly full batches in the first wave, while we usually see time-triggered waves in the second wave.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let printer = system.create(BatchPrinter::new);
    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
    let batching = buncher.on_definition(|cd| cd.batch_port.share());

    system.start(&amp;printer);
    system.start(&amp;buncher);

    // these should usually trigger due to full batches
    let sleep_dur = Duration::from_millis(1);
    for i in 0..500 {
        let ping = Ping(i);
        system.trigger_r(ping, &amp;batching);
        std::thread::sleep(sleep_dur);
    }

    // these should usually trigger due to timeout
    let sleep_dur = Duration::from_millis(2);
    for i in 0..500 {
        let ping = Ping(i);
        system.trigger_r(ping, &amp;batching);
        std::thread::sleep(sleep_dur);
    }

    system.shutdown().expect(&quot;shutdown&quot;);
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="regular-buncher"><a class="header" href="#regular-buncher">Regular Buncher</a></h3>
<p>The state of the <code>Buncher</code> consists of the two configuration values, batch size and timeout, as well as the <code>Vec</code> storing the currently collecting batch and the handle for the currently scheduled timeout (<code>ScheduledTimer</code>).</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
struct Buncher {
    ctx: ComponentContext&lt;Self&gt;,
    batch_port: ProvidedPort&lt;Batching&gt;,
    batch_size: usize,
    timeout: Duration,
    current_batch: Vec&lt;Ping&gt;,
    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
}
<span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>As part of the lifecyle we must set up the timer, but also make sure to clean it up after we are done. To be able to do so, we must store the <code>ScheduledTimer</code> handle that the <code>schedule_periodic(...)</code> function returns in a local field, so we can access it when we are paused or killed and pass it as a parameter to <code>cancel_timer(...)</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Buncher {
    fn on_start(&amp;mut self) -&gt; Handled {
        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
        self.outstanding_timeout = Some(timeout);
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.outstanding_timeout.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Warning:</strong> Not cleaning up timeouts will cause them to be triggered over and over again. Not only will it slow down the timer facilities, but may also cause a lot of logging, depending on the logging level you are compiling with. Make sure to always clean up scheduled timeouts, especially periodic ones.</p>
</blockquote>
<p>The first parameter of the <code>schedule_periodic(...)</code> function is the time until the timeout is triggered the first time. The second parameters gives the periodicity. We’ll use the same value for both here.
The actual code we want to call whenever our periodic timeout is triggered is a private function called <code>handle_timeout(...)</code> which has the signature expected by the <code>schedule_periodic(...)</code> function. It checks that the timeout we got is actually an expected timeout, before invoking the actual <code>trigger_batch(...)</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn trigger_batch(&amp;mut self) -&gt; () {
        let mut new_batch = Vec::with_capacity(self.batch_size);
        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
        self.batch_port.trigger(Batch(new_batch))
    }

    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
        match self.outstanding_timeout {
            Some(ref timeout) if *timeout == timeout_id =&gt; {
                self.trigger_batch();
                Handled::Ok
            }
            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
            None =&gt; {
                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
                Handled::Ok
            } // can happen during restart or teardown
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The actual handler for the <code>Ping</code> events on the <code>Buncher</code> is pretty straight forward. We simply add the event to our active batch. Then we check if the batch is full, and if it is we again call <code>trigger_batch(...)</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Provide&lt;Batching&gt; for Buncher {
    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
        self.current_batch.push(event);
        if self.current_batch.len() &gt;= self.batch_size {
            self.trigger_batch();
        }
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If we go and run this implementation with the main function from above, we will see that for the first wave we often get a full batch followed by a very small batch, e.g.:</p>
<pre><code class="language-bash">Mar 10 15:42:03.734 INFO Got a batch with 100 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
Mar 10 15:42:03.762 INFO Got a batch with 22 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
Mar 10 15:42:03.890 INFO Got a batch with 100 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
Mar 10 15:42:03.912 INFO Got a batch with 16 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
</code></pre>
<p>This happens because we hit 100 Pings somewhere around 120ms into the timeout, and then there is only around 30ms left to collect events for the next batch. This, of course, isn’t particularly great behaviour for a batching abstraction. We would much rather have regular batches if the input is coming in regularly.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin buncher_regular
</code></pre>
</blockquote>
<h3 id="adaptive-buncher"><a class="header" href="#adaptive-buncher">Adaptive Buncher</a></h3>
<p>In order to get more regular sized batches, we need to reset our timeout whenever we trigger a batch based on size. Since this will cause our timeouts to be very irregular anyway, we will just skip periodic timeouts altogether and always schedule a new timer whenever we trigger a batch, no matter which condition triggered it.</p>
<p>To do so, we must first change the handler for lifecycle events to use <code>schedule_once(...)</code> instead of <code>schedule_periodic(...)</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Buncher {
    fn on_start(&amp;mut self) -&gt; Handled {
        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
        self.outstanding_timeout = Some(timeout);
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.outstanding_timeout.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We must also remember to reschedule a new timeout when we handle a current one. It’s important to correctly replace the handle for the timeout so we never accidentally trigger on an outdated timeout.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span>    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
        match self.outstanding_timeout {
            Some(ref timeout) if *timeout == timeout_id =&gt; {
                self.trigger_batch();
                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
                self.outstanding_timeout = Some(new_timeout);
                Handled::Ok
            }
            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
            None =&gt; {
                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
                Handled::Ok
            } // can happen during restart or teardown
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Finally, when we trigger a batch based on size, we must proactively cancel the current timeout and schedule a new one. Note that this cancellation API is asychronous, so it can very well happen that an already cancelled timeout will still be invoked because it was already queued up. That is why we must always check for a matching timeout handle before executing a received timeout.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Provide&lt;Batching&gt; for Buncher {
    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
        self.current_batch.push(event);
        if self.current_batch.len() &gt;= self.batch_size {
            self.trigger_batch();
            if let Some(timeout) = self.outstanding_timeout.take() {
                self.cancel_timer(timeout);
            }
            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
            self.outstanding_timeout = Some(new_timeout);
        }
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If we run again now, we can see that the first wave of pings is pretty much always triggered based on size, while the second wave is always triggered based on timeout, giving us much more regular batches.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin buncher_adaptive
</code></pre>
</blockquote>
<h1 id="schedulers"><a class="header" href="#schedulers">Schedulers</a></h1>
<p>Kompact allows the core component scheduler to be exchanged, in order to support different kinds of workloads.
The default <code>crossbeam_workstealing_pool</code> scheduler from the <a href="https://docs.rs/executors/latest/executors/crossbeam_workstealing_pool/index.html">executors</a> crate, for example, is designed for fork-join type workloads. That is, workloads where a small number of (pool) external events spawns a large number of (pool) internal events. 
But not all workloads are of this type. Sometimes the majority of events are (pool) external, and there is little communication between components running on the thread pool. Our somewhat contrived “counter”-example from the <a href="local/../introduction/state.html">introduction</a> was of this nature, for example. We were sending events and messages from the main-thread to the <code>Counter</code>, which was running on Kompact’s thread-pool. But we never sent any messages or events to any other component on that pool. In fact, we also only had a single component, and running it a large thread pool seems rather silly. (Kompact’s default thread pool has one thread for each CPU core, as reported by <a href="https://crates.io/crates/num_cpus">num_cpus</a>.)</p>
<h2 id="changing-pool-size"><a class="header" href="#changing-pool-size">Changing Pool Size</a></h2>
<p>We will first change just the pool size for the “counter”-example, since that is easily done. </p>
<p>The number of threads in Kompact’s thread pool is configured with the config value at <a href="https://docs.rs/kompact/latest/kompact/config_keys/system/constant.THREADS.html">system::THREADS</a> using the <code>set_config_value</code> function on a <code>KompactConfig</code> instance. We will simply pass in <code>1usize</code> there, before constructing our Kompact system.</p>
<p>That we change this line</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span>    let system = KompactConfig::default().build().expect(&quot;system&quot;);
<span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>to this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span>    use kompact::config_keys::system;
    let mut conf = KompactConfig::default();
    conf.set_config_value(&amp;system::THREADS, 1usize);
    let system = conf.build().expect(&quot;system&quot;);
<span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The same effect could be achieved via a <a href="local/configuration.html">configuration</a> file by setting <code>kompact.runtime.threads = 1</code>.</p>
<p>If we run this, we will see exactly (modulo event timing) the same output as when running on the larger pool with Kompact’s default settings.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin counters_pool
</code></pre>
</blockquote>
<h2 id="changing-scheduler-implementation"><a class="header" href="#changing-scheduler-implementation">Changing Scheduler Implementation</a></h2>
<p>Ok, so now we’ll switch to a pool that is designed for external events: <code>crossbeam_channel_pool</code>, also from the <a href="https://docs.rs/executors/latest/executors/crossbeam_channel_pool/index.html">executors</a> crate. </p>
<p>We can set the scheduler implementation to be used by our Kompact system using the <code>executor(...)</code> function on a <code>KompactConfig</code> instance. That function expects a closure from the number of threads (<code>usize</code>) to something that implements the <code>executors::FuturesExecutor</code> <a href="https://docs.rs/executors/latest/executors/trait.FuturesExecutor.html">trait</a>.</p>
<blockquote>
<p><strong>Note:</strong> There is actually a more general API for changing scheduler, in the <code>scheduler(...)</code> function, which expects a function returning a <code>Box&lt;dyn kompact::runtime::Scheduler&gt;</code>. The <code>executor(...)</code> function is simply a shortcut for using schedulers that are compatible with the <a href="https://crates.io/crates/executors">executors</a> crate.</p>
</blockquote>
<p>In order to use the <code>crossbeam_channel_pool</code> scheduler, we need to import the <code>kompact::executors</code> module, which is simply a re-export from the <a href="https://crates.io/crates/executors">executors</a> crate:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use kompact::executors;
</code></pre>
<p>With that, all we need to add is the following line of code, which selects the <code>ThreadPool</code> implementation from the <code>crossbeam_channel_pool</code> module, instead of the one from the <code>crossbeam_workstealing_pool</code> module, that is default.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{executors, prelude::*};
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    use kompact::config_keys::system;
</span><span class="boring">    let mut conf = KompactConfig::default();
</span><span class="boring">    conf.set_config_value(&amp;system::THREADS, 1usize);
</span>    conf.executor(executors::crossbeam_channel_pool::ThreadPool::new);
<span class="boring">    let system = conf.build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If we run this, again, we will see exactly (modulo event timing) the same output as when running on the larger pool with Kompact’s default settings.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin counters_channel_pool
</code></pre>
</blockquote>
<h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Kompact uses the <a href="https://crates.io/crates/slog">slog</a> crate to provide system wide logging facilities.
The basic macros for this, <code>slog::{crit, debug, error, info, o, trace, warn}</code> are re-exported in the prelude for convenience. Logging works out of the box with a default asynchronous console logger implementation that roughly corresponds to the following setup code:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let decorator = slog_term::TermDecorator::new().stdout().build();
let drain = slog_term::FullFormat::new(decorator).build().fuse();
let drain = slog_async::Async::new(drain).chan_size(1024).build().fuse();
let logger = slog::Logger::root_typed(Arc::new(drain));
</code></pre>
<p>The actual logging levels are controlled via build features. The default features correspond to <code>max_level_trace</code> and <code>release_max_level_info</code>, that is in debug builds all levels are shown, while in the release profile only <code>info</code> and more severe message are shown. Alternatively, Kompact provides a slightly less verbose feature variant called <code>silent_logging</code>, which is equivalent to <code>max_level_info</code> and <code>release_max_level_error</code>.</p>
<p>This is exemplified in the following very simple code example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    trace!(
        system.logger(),
        &quot;You will only see this in debug builds with default features&quot;
    );
    debug!(
        system.logger(),
        &quot;You will only see this in debug builds with default features&quot;
    );
    info!(system.logger(), &quot;You will only see this in debug builds with silent_logging or in release builds with default features&quot;);
    warn!(system.logger(), &quot;You will only see this in debug builds with silent_logging or in release builds with default features&quot;);
    error!(system.logger(), &quot;You will always see this&quot;);

    // remember that logging is asynchronous and won't happen if the system is shut down already
    std::thread::sleep(Duration::from_millis(100));
    system.shutdown().expect(&quot;shutdown&quot;);
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_logging() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Try to run it with a few different build settings and see what you get.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin logging
</code></pre>
</blockquote>
<h2 id="custom-logger"><a class="header" href="#custom-logger">Custom Logger</a></h2>
<p>Sometimes the default logging configuration is not sufficient for a particular application. For example, you might need a larger queue size in the <code>Async</code> drain, or you may want to write to a file instead of the terminal.</p>
<p>In the following example we replace the default terminal logger with a file logger, logging to <code>/tmp/myloggingfile</code> instead. We also increase the queue size in the <code>Async</code> drain to 2048, so that it fits the 2048 logging events we are sending it short succession later. In order to replace the default logger, we use the <code>KompactConfig::logger(...)</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{fs::OpenOptions, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">const FILE_NAME: &amp;str = &quot;/tmp/myloggingfile&quot;;
</span><span class="boring">
</span>pub fn main() {
    let mut conf = KompactConfig::default();
    let logger = {
        let file = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(FILE_NAME)
            .expect(&quot;logging file&quot;);

        // create logger
        let decorator = slog_term::PlainSyncDecorator::new(file);
        let drain = slog_term::FullFormat::new(decorator).build().fuse();
        let drain = slog_async::Async::new(drain).chan_size(2048).build().fuse();
        slog::Logger::root_typed(
            Arc::new(drain),
            o!(
            &quot;location&quot; =&gt; slog::PushFnValue(|r: &amp;slog::Record&lt;'_&gt;, ser: slog::PushFnValueSerializer&lt;'_&gt;| {
                ser.emit(format_args!(&quot;{}:{}&quot;, r.file(), r.line()))
            })),
        )
    };
    conf.logger(logger);
    let system = conf.build().expect(&quot;system&quot;);
    trace!(
        system.logger(),
        &quot;You will only see this in debug builds with default features&quot;
    );
    debug!(
        system.logger(),
        &quot;You will only see this in debug builds with default features&quot;
    );
    info!(system.logger(), &quot;You will only see this in debug builds with silent_logging or in release builds with default features&quot;);
    warn!(system.logger(), &quot;You will only see this in debug builds with silent_logging or in release builds with default features&quot;);
    error!(system.logger(), &quot;You will always see this&quot;);

    for i in 0..2048 {
        info!(system.logger(), &quot;Logging number {}.&quot;, i);
    }

    // remember that logging is asynchronous and won't happen if the system is shut down already
    std::thread::sleep(Duration::from_millis(1000));
    system.shutdown().expect(&quot;shutdown&quot;);
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_logging() {
</span><span class="boring">        main();
</span><span class="boring">        std::fs::remove_file(FILE_NAME).expect(&quot;remove log file&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary and then show the logging file with:</p>
<pre><code class="language-bash">cargo run --release --bin logging_custom
cat /tmp/myloggingfile
</code></pre>
</blockquote>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Since it is often inconvenient to pass around a large number of parameters when setting up a component system, Kompact also offers a configuration system allowing parameters to be loaded from a file or provided as a large string at the top level, for example. This system is powered by the <a href="https://crates.io/crates/hocon">Hocon</a> crate and uses its APIs with very little additional support. </p>
<p>Configuration options must be set on the <code>KompactConfig</code> instance before the system is started and the resulting configuration remains immutable for the lifetime of the system. A configuration can be loaded from a file by passing a path to the file to the <code>load_config_file(...)</code> function. Alternatively, configuration values can be loaded directly from a string using <code>load_config_str(...)</code>.</p>
<p>Within each component the <a href="https://docs.rs/hocon/latest/hocon/enum.Hocon.html">Hocon</a> configuration instance can be accessed via the context and individual keys via bracket notation, e.g. <code>self.ctx.config()[&quot;my-key&quot;]</code>. The configuration can also be accessed outside a component via <code>KompactSystem::config()</code>.</p>
<p>In addition to component configuration, many parts of Kompact’s runtime can also be configured via this mechanism. The complete set of available configuration keys and their effects is described in the modules below <a href="https://docs.rs/kompact/latest/kompact/config_keys/index.html">kompact::config_keys</a>.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We are going to reuse the <code>Buncher</code> from the <a href="local/timers.html">timers</a> section and pass its two parameters, <code>batch_size</code> and <code>timeout</code>, via configuration instead of the constructor.</p>
<p>We’ll start off by creating a configuration file <code>application.conf</code> in the working directory, so its easy to find later. Something like this:</p>
<pre><code class="language-hocon">buncher {
	batch-size = 100
	timeout = 100 ms
}
omega {
	initial-period = 10 ms
	delta = 1 ms
}
</code></pre>
<p>We can then add this file to the <code>KompicsConfig</code> instance using the <code>load_config_file(...)</code> function: </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new() -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size: 0,
</span><span class="boring">            timeout: Duration::from_millis(1),
</span><span class="boring">            current_batch: Vec::new(),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.batch_size = self.ctx.config()[&quot;buncher&quot;][&quot;batch-size&quot;]
</span><span class="boring">            .as_i64()
</span><span class="boring">            .expect(&quot;batch size&quot;) as usize;
</span><span class="boring">        self.timeout = self.ctx.config()[&quot;buncher&quot;][&quot;timeout&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;timeout&quot;);
</span><span class="boring">        self.current_batch.reserve(self.batch_size);
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut conf = KompactConfig::default();
</span>    conf.load_config_file(&quot;./application.conf&quot;)
<span class="boring">        .load_config_str(&quot;buncher.batch-size = 50&quot;);
</span><span class="boring">    let system = conf.build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(Buncher::new);
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>To show off how multiple configuration sources can be combined, we will override the <code>batch-size</code> value from the main function with a literal string, <em>after</em> the file has been loaded:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new() -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size: 0,
</span><span class="boring">            timeout: Duration::from_millis(1),
</span><span class="boring">            current_batch: Vec::new(),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.batch_size = self.ctx.config()[&quot;buncher&quot;][&quot;batch-size&quot;]
</span><span class="boring">            .as_i64()
</span><span class="boring">            .expect(&quot;batch size&quot;) as usize;
</span><span class="boring">        self.timeout = self.ctx.config()[&quot;buncher&quot;][&quot;timeout&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;timeout&quot;);
</span><span class="boring">        self.current_batch.reserve(self.batch_size);
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span>    let mut conf = KompactConfig::default();
    conf.load_config_file(&quot;./application.conf&quot;)
        .load_config_str(&quot;buncher.batch-size = 50&quot;);
    let system = conf.build().expect(&quot;system&quot;);
<span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(Buncher::new);
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now we change the <code>Buncher</code> constructor to not take any arguments anymore. Since we still need to put some values into the struct fields, let’s put some default values, say batch size of 0 and a timeout of 1ms. We could also go with an <code>Option</code>, if it’s important to know whether the component was initialised properly nor not. We also don’t know the required capacity for the vector anymore, so we just create an empty one, and extend it later once we have read the batch size from the config file.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span>    fn new() -&gt; Buncher {
        Buncher {
            ctx: ComponentContext::uninitialised(),
            batch_port: ProvidedPort::uninitialised(),
            batch_size: 0,
            timeout: Duration::from_millis(1),
            current_batch: Vec::new(),
            outstanding_timeout: None,
        }
    }

<span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.batch_size = self.ctx.config()[&quot;buncher&quot;][&quot;batch-size&quot;]
</span><span class="boring">            .as_i64()
</span><span class="boring">            .expect(&quot;batch size&quot;) as usize;
</span><span class="boring">        self.timeout = self.ctx.config()[&quot;buncher&quot;][&quot;timeout&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;timeout&quot;);
</span><span class="boring">        self.current_batch.reserve(self.batch_size);
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut conf = KompactConfig::default();
</span><span class="boring">    conf.load_config_file(&quot;./application.conf&quot;)
</span><span class="boring">        .load_config_str(&quot;buncher.batch-size = 50&quot;);
</span><span class="boring">    let system = conf.build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(Buncher::new);
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>And, of course, we must also update the matching <code>create(...)</code> call in the main function:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new() -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size: 0,
</span><span class="boring">            timeout: Duration::from_millis(1),
</span><span class="boring">            current_batch: Vec::new(),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.batch_size = self.ctx.config()[&quot;buncher&quot;][&quot;batch-size&quot;]
</span><span class="boring">            .as_i64()
</span><span class="boring">            .expect(&quot;batch size&quot;) as usize;
</span><span class="boring">        self.timeout = self.ctx.config()[&quot;buncher&quot;][&quot;timeout&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;timeout&quot;);
</span><span class="boring">        self.current_batch.reserve(self.batch_size);
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut conf = KompactConfig::default();
</span><span class="boring">    conf.load_config_file(&quot;./application.conf&quot;)
</span><span class="boring">        .load_config_str(&quot;buncher.batch-size = 50&quot;);
</span><span class="boring">    let system = conf.build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span>    let buncher = system.create(Buncher::new);
<span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Finally, the actual config access happens in the <code>on_start</code>code. At this point the component is properly initialised and we have acceess to configuration values. The <a href="https://docs.rs/hocon/latest/hocon/enum.Hocon.html">Hocon</a> type has a bunch of very convenient conversion functions, so we can get a <code>Duration</code> directly from the <code>100 ms</code> string in the file, for example. Once we have read the values for <code>batch_size</code> and <code>timeout</code>, we can also go ahead and reserve the required additional space in the <code>current_batch</code> vector.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new() -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size: 0,
</span><span class="boring">            timeout: Duration::from_millis(1),
</span><span class="boring">            current_batch: Vec::new(),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span>    fn on_start(&amp;mut self) -&gt; Handled {
        self.batch_size = self.ctx.config()[&quot;buncher&quot;][&quot;batch-size&quot;]
            .as_i64()
            .expect(&quot;batch size&quot;) as usize;
        self.timeout = self.ctx.config()[&quot;buncher&quot;][&quot;timeout&quot;]
            .as_duration()
            .expect(&quot;timeout&quot;);
        self.current_batch.reserve(self.batch_size);
        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
        self.outstanding_timeout = Some(timeout);
        Handled::Ok
    }

<span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut conf = KompactConfig::default();
</span><span class="boring">    conf.load_config_file(&quot;./application.conf&quot;)
</span><span class="boring">        .load_config_str(&quot;buncher.batch-size = 50&quot;);
</span><span class="boring">    let system = conf.build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(Buncher::new);
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>At this point we can run the example, and we can see from the regular “50 event”-sized batches in the beginning that our overriding of the batch size worked just fine.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin buncher_config
</code></pre>
</blockquote>
<h1 id="fault-recovery"><a class="header" href="#fault-recovery">Fault Recovery</a></h1>
<p>Sometimes panics can happen in components that provide crucial services to the rest of system. And while it is, of course, better to try and have <code>Result::Err</code> branches in place for every anticipated problem, with the use of 3rd party libraries and even some standard library functions not every possible panic can be prevented. Thus components can “fault” unexpectedly and the service they provide suddenly is not available.</p>
<p>In order to deal with cases where simply letting a component die is just not good enough, Kompact provdes a simple mechanism for recovering from faults: For every individual component, users can register a <code>RecoveryFunction</code>, that is basically a function which takes a <code>FaultContext</code> and produces a mechanism to recover from that fault, called a <code>RecoveryHandler</code>. This recovery handler is executed by the system’s <code>ComponentSupervisor</code> when it is informed of the fault.</p>
<blockquote>
<p><strong>Note:</strong> Fault recovery only works when the executed binary is compiled with <em>panic unwinding</em>. In binaries set to <code>panic=abort</code> none of this applies and fault handling must be dealt with outside the process running the Kompact system.</p>
</blockquote>
<blockquote>
<p><strong>Warning:</strong> Panicking within the <code>RecoveryHandler</code> will destroy the <code>ComponentSupervisor</code>, which is unrecoverable, and thus lead to “poisoning” of the whole Kompact system.</p>
</blockquote>
<p>A <code>RecoveryFunction</code> can be registered via <code>Component::set_recovery_function(...)</code> from outside a component or via <code>ComponentContext::set_recovery_function(...)</code> from within. Either way causes a <code>Mutex</code> to be locked, so be aware of the performance cost and the risk for deadlock when using with the latter function (since you are already holding the <code>Mutex</code> on the <code>ComponentDefinition</code> at this point). That being said, <code>set_recovery_function(...)</code> can be called repeatedly to update the state stored in the function. This is particularly useful as a very simple snapshotting mechanism, allowing a replacement component later to be started from this earlier state snapshort, instead of starting from scratch.</p>
<p>Apart from inspecting the <code>FaultContext</code> the recovery function must produce some kind of recovery handler. The simplest (and default) handler is <code>FaultContext::ignore()</code> which performs no additional action on the supervisor to recover the faulted component. If custom handling is required, it can be provided via <code>FaultContext::recover_with(...)</code>, where the user can provide a closure that may use the <code>FaultContext</code>, the supervisor’s <code>SystemHandle</code>, and the supervisor’s <code>KompactLogger</code> to react to the fault. What happens in this function is completely up to the user and the needs of the application. A common case might be to log some particular message, or create a new component via <code>system.create(...)</code> and start it with <code>system.start(...)</code>, for example.</p>
<blockquote>
<p><strong>Warning:</strong> Do <em>not</em> block within the <code>RecoveryHandler</code>, as that will prevent the <code>ComponentSupervisor</code> from doing its job. In particular, absolutely do not block on lifecycle event (e.g., <code>start_notify</code>) as that will deadlock the supervisor! If you need to execute a complicated sequence of asynchronous commands to recover from a fault, it is recommended to use a temporary component for this sequence, which can simply be started from the recovery handler.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> After recovery all component references (<code>Arc&lt;Component&lt;CD&gt;&gt;</code>) and actor references to the old component will be invalid. If your application needs their functionality, you need to devise a mechanism to share the new references (e.g., concurrent queues, <code>Arc&lt;Mutex&lt;...&gt;&gt;</code>, etc.). If the component provides a <a href="local/distributed/namedservices.html">named service</a> the alias must be re-registered to point to the new instance.</p>
</blockquote>
<h2 id="unstable-counter-example"><a class="header" href="#unstable-counter-example">Unstable Counter Example</a></h2>
<p>In order to showcase the recovery mechanism, we write a timer-based counter, which occasionally overflows and thus causes the component to crash. In order not to lose all the instances we have already counted, we will occasionally store the current count in the recovery function, and during recovery start from that point, i.e. a slightly outdated count, but at least not 0.</p>
<p>In addition to the current count, we will store references to two scheduled timers: For every <code>count_timeout</code> we want to increase our <code>count</code> by 1 and for every <code>state_timeout</code> we will update the recovery function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
struct UnstableCounter {
    ctx: ComponentContext&lt;Self&gt;,
    count: u8,
    count_timeout: Option&lt;ScheduledTimer&gt;,
    state_timeout: Option&lt;ScheduledTimer&gt;,
}
<span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>By default, we just initialise the count to 0 and leave the timeouts unset until we are started.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Default for UnstableCounter {
    fn default() -&gt; Self {
        UnstableCounter {
            ctx: ComponentContext::uninitialised(),
            count: 0,
            count_timeout: None,
            state_timeout: None,
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>During start, we schedule the two timers and also set our recovery function. Within the recovery function, we simply store the state we want to remember, i.e. the two timeouts and the count. When it is called we produce a recovery handler from this state, that cancels the old timeouts and then starts a new <code>UnstableCounter</code> by passing in the last count we stored. </p>
<p>As usual, we also cancel our timeouts when we are stopped or killed.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for UnstableCounter {
    fn on_start(&amp;mut self) -&gt; Handled {
        let count_timeout = self.schedule_periodic(
            COUNT_TIMEOUT,
            COUNT_TIMEOUT,
            UnstableCounter::handle_count_timeout,
        );
        self.count_timeout = Some(count_timeout.clone());
        let state_timeout = self.schedule_periodic(
            STATE_TIMEOUT,
            STATE_TIMEOUT,
            UnstableCounter::handle_state_timeout,
        );
        self.state_timeout = Some(state_timeout.clone());
        let count = self.count;
        self.ctx.set_recovery_function(move |fault| {
            fault.recover_with(move |_ctx, system, logger| {
                warn!(
                    logger,
                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
                );
                // Clean up now invalid timers
                system.cancel_timer(count_timeout);
                system.cancel_timer(state_timeout);
                let counter_component = system.create(move || Self::with_state(count));
                system.start(&amp;counter_component);
            })
        });
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.count_timeout.take() {
            self.cancel_timer(timeout);
        }
        if let Some(timeout) = self.state_timeout.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span>    fn with_state(count: u8) -&gt; Self {
        UnstableCounter {
            ctx: ComponentContext::uninitialised(),
            count,
            count_timeout: None,
            state_timeout: None,
        }
    }

<span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> Cancelling the timeouts during faults is not really necessary, as they will be cleaned automatically when the faulty component is dropped. Since we don’t control who is holding on to component references, though, it may avoid some unnecessary overhead on a heavily loaded timer if done more eagerly, like this. It is included here mostly as an example of possible cleanup code in a recovery handler.</p>
</blockquote>
<p>When our timeouts are triggered we must handle them. The count timeout is easy, we simply increment the <code>self.count</code> variable using the <code>checked_add</code> to cause a panic on overflow even in release builds. During the state timeout, we essentially reintroduce the recovery function from the <code>on_start</code> lifecycle handler, so that we update the state it closed over.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span>    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
        Handled::Ok
    }

    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
        info!(
            self.log(),
            &quot;Saving recovery state with count of {}&quot;, self.count
        );
        let mut count_timeout = self.count_timeout.clone();
        let mut state_timeout = self.state_timeout.clone();
        let count = self.count;
        self.ctx.set_recovery_function(move |fault| {
            fault.recover_with(move |_ctx, system, logger| {
                warn!(
                    logger,
                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
                );
                // Clean up now invalid timers
                if let Some(timeout) = count_timeout.take() {
                    system.cancel_timer(timeout);
                }
                if let Some(timeout) = state_timeout.take() {
                    system.cancel_timer(timeout);
                }
                let counter_component = system.create(move || Self::with_state(count));
                system.start(&amp;counter_component);
            })
        });
        Handled::Ok
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In order to run this, we simply start the default instance of the <code>UnstableCounter</code> onto a Kompact system and then wait for a bit to let it count. The output will show the counting and the crashes. We can see that after the crash do not start counting from 0, but instead from something much higher, around 199 depending on your exact timing. Also notice how we crash much faster after the first time, since it doesn’t take as long to reach 255 again.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let component = system.create(UnstableCounter::default);
    system.start(&amp;component);
    drop(component); // avoid it from holding on to memory after crashing
    std::thread::sleep(Duration::from_millis(5000));
    println!(&quot;Shutting down system&quot;);
    system.shutdown().expect(&quot;shutdown&quot;);
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin unstable_counter
</code></pre>
</blockquote>
<h1 id="dynamic-components"><a class="header" href="#dynamic-components">Dynamic Components</a></h1>
<p>Kompact is a very strictly and statically typed framework. Sometimes, however, it is beneficial to be a little more dynamic.
There are many reasons you might want to introduce some dynamism into your component system: modularity, ease of modeling,
or sometimes even performance: static dispatch in Rust often involves monomorphising substantial amounts of generic code, 
which leads to code bloat. The more instructions the CPU has to load the more likely it is that something won’t fit in the
cache, which can incur performance penalties.</p>
<p>Because of this, we introduced a way to deal with components with a little bit of dynamic typing. Namely, you’re able
to create components from type-erased definitions with <code>{System,SystemHandle}::create_erased</code> (nightly only), and query 
type-erased components for ports they may provide and/or require with <code>on_dyn_definition</code> and <code>get_{provided,required}_port</code>.</p>
<blockquote>
<p><strong>Note:</strong> While creating type-erased components from <strong>type-erased definitions</strong> <em>is</em> nightly-only, you can create component
just normally and then cast it to a type-erased component on stable.</p>
</blockquote>
<p>Let’s create a dynamic interactive system showcasing these features. We’ll build a little REPL which the user can use
to spawn some components, set their settings, and send them some data to process.</p>
<p>First some basic components:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">
</span><span class="boring">use kompact::{component::AbstractComponent, prelude::*};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    fmt,
</span><span class="boring">    io::{stdin, BufRead},
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Adder {
    ctx: ComponentContext&lt;Self&gt;,
    offset: f32,
    set_offset: ProvidedPort&lt;SetOffset&gt;,
}
info_lifecycle!(Adder);

impl Actor for Adder {
    type Message = f32;

    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
        let res = a + self.offset;
        info!(self.log(), &quot;Adder result = {}&quot;, res);
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!()
    }
}

struct SetOffset;

impl Port for SetOffset {
    type Indication = Never;
    type Request = f32;
}

impl Provide&lt;SetOffset&gt; for Adder {
    fn handle(&amp;mut self, value: f32) -&gt; Handled {
        self.offset = value;
        Handled::Ok
    }
}

impl Adder {
    pub fn new() -&gt; Self {
        Adder {
            ctx: ComponentContext::uninitialised(),
            offset: 0f32,
            set_offset: ProvidedPort::uninitialised(),
        }
    }
}

#[derive(ComponentDefinition)]
struct Multiplier {
    ctx: ComponentContext&lt;Self&gt;,
    scale: f32,
    set_scale: ProvidedPort&lt;SetScale&gt;,
}
info_lifecycle!(Multiplier);

impl Actor for Multiplier {
    type Message = f32;

    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
        let res = a * self.scale;
        info!(self.log(), &quot;Multiplier result = {}&quot;, res);
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!()
    }
}

struct SetScale;

impl Port for SetScale {
    type Indication = Never;
    type Request = f32;
}

impl Provide&lt;SetScale&gt; for Multiplier {
    fn handle(&amp;mut self, value: f32) -&gt; Handled {
        self.scale = value;
        Handled::Ok
    }
}

impl Multiplier {
    fn new() -&gt; Multiplier {
        Multiplier {
            ctx: ComponentContext::uninitialised(),
            scale: 1.0,
            set_scale: ProvidedPort::uninitialised(),
        }
    }
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Linear {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Linear);
</span><span class="boring">
</span><span class="boring">impl Actor for Linear {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Linear result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Linear {
</span><span class="boring">    fn new() -&gt; Linear {
</span><span class="boring">        Linear {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            offset: 0.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DynamicManager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    arithmetic_units: Vec&lt;Arc&lt;dyn AbstractComponent&lt;Message = f32&gt;&gt;&gt;,
</span><span class="boring">    set_offsets: RequiredPort&lt;SetOffset&gt;,
</span><span class="boring">    set_scales: RequiredPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_indications!(SetOffset, DynamicManager);
</span><span class="boring">ignore_indications!(SetScale, DynamicManager);
</span><span class="boring">ignore_lifecycle!(DynamicManager);
</span><span class="boring">
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Spawn(Box&lt;dyn CreateErased&lt;f32&gt; + Send&gt;),
</span><span class="boring">    Compute(f32),
</span><span class="boring">    SetScales(f32),
</span><span class="boring">    SetOffsets(f32),
</span><span class="boring">    KillAll,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Debug for ManagerMessage {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        match self {
</span><span class="boring">            ManagerMessage::Spawn(_) =&gt; {
</span><span class="boring">                write!(f, &quot;Spawn(_)&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                write!(f, &quot;Compute({})&quot;, *val)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; {
</span><span class="boring">                write!(f, &quot;SetScales({})&quot;, *scale)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; {
</span><span class="boring">                write!(f, &quot;SetOffsets({})&quot;, *offset)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                write!(f, &quot;KillAll&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                write!(f, &quot;Quit&quot;)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DynamicManager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: ManagerMessage) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Spawn(definition) =&gt; {
</span><span class="boring">                let system = self.ctx.system();
</span><span class="boring">                let component = system.create_erased(definition);
</span><span class="boring">                component.on_dyn_definition(|def| {
</span><span class="boring">                    if let Some(set_scale) = def.get_provided_port::&lt;SetScale&gt;() {
</span><span class="boring">                        biconnect_ports(set_scale, &amp;mut self.set_scales);
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(set_offset) = def.get_provided_port::&lt;SetOffset&gt;() {
</span><span class="boring">                        biconnect_ports(set_offset, &amp;mut self.set_offsets);
</span><span class="boring">                    }
</span><span class="boring">                });
</span><span class="boring">                system.start(&amp;component);
</span><span class="boring">
</span><span class="boring">                self.arithmetic_units.push(component);
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                for unit in &amp;self.arithmetic_units {
</span><span class="boring">                    unit.actor_ref().tell(val);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; self.set_scales.trigger(scale),
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; self.set_offsets.trigger(offset),
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">                self.ctx.system().shutdown_async();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DynamicManager {
</span><span class="boring">    fn kill_all(&amp;mut self) {
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        for unit in self.arithmetic_units.drain(..) {
</span><span class="boring">            system.kill(unit);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager: Arc&lt;Component&lt;DynamicManager&gt;&gt; = system.create(|| DynamicManager {
</span><span class="boring">        ctx: ComponentContext::uninitialised(),
</span><span class="boring">        arithmetic_units: vec![],
</span><span class="boring">        set_offsets: RequiredPort::uninitialised(),
</span><span class="boring">        set_scales: RequiredPort::uninitialised(),
</span><span class="boring">    });
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref();
</span><span class="boring">
</span><span class="boring">    std::thread::spawn(move || {
</span><span class="boring">        for line in stdin().lock().lines() {
</span><span class="boring">            let res = (|| -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">                let line = line?;
</span><span class="boring">
</span><span class="boring">                let message = match line.trim() {
</span><span class="boring">                    &quot;spawn adder&quot; =&gt; ManagerMessage::Spawn(Box::new(Adder::new())),
</span><span class="boring">                    &quot;spawn multiplier&quot; =&gt; ManagerMessage::Spawn(Box::new(Multiplier::new())),
</span><span class="boring">                    &quot;spawn linear&quot; =&gt; ManagerMessage::Spawn(Box::new(Linear::new())),
</span><span class="boring">                    &quot;kill all&quot; =&gt; ManagerMessage::KillAll,
</span><span class="boring">                    &quot;quit&quot; =&gt; ManagerMessage::Quit,
</span><span class="boring">                    other =&gt; {
</span><span class="boring">                        if let Some(offset) = other.strip_prefix(&quot;set offset &quot;) {
</span><span class="boring">                            ManagerMessage::SetOffsets(offset.parse()?)
</span><span class="boring">                        } else if let Some(scale) = other.strip_prefix(&quot;set scale &quot;) {
</span><span class="boring">                            ManagerMessage::SetScales(scale.parse()?)
</span><span class="boring">                        } else if let Some(val) = other.strip_prefix(&quot;compute &quot;) {
</span><span class="boring">                            ManagerMessage::Compute(val.parse()?)
</span><span class="boring">                        } else {
</span><span class="boring">                            Err(&quot;unknown command!&quot;)?
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                manager_ref.tell(message);
</span><span class="boring">
</span><span class="boring">                Ok(())
</span><span class="boring">            })();
</span><span class="boring">
</span><span class="boring">            if let Err(e) = res {
</span><span class="boring">                println!(&quot;{}&quot;, e);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>Our components perform simple arithmetic operations on the incoming message and log the results (as well as their 
lifecycle). The internal state of the components can be set via <code>Set{Offset,Scale}</code> ports. So far we just have components
with <em>either</em> a scale <em>or</em> an offset. Let’s add something slightly more interesting, which uses both.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">
</span><span class="boring">use kompact::{component::AbstractComponent, prelude::*};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    fmt,
</span><span class="boring">    io::{stdin, BufRead},
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Adder {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Adder);
</span><span class="boring">
</span><span class="boring">impl Actor for Adder {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Adder result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetOffset;
</span><span class="boring">
</span><span class="boring">impl Port for SetOffset {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Adder {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Adder {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Adder {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            offset: 0f32,
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Multiplier {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Multiplier);
</span><span class="boring">
</span><span class="boring">impl Actor for Multiplier {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale;
</span><span class="boring">        info!(self.log(), &quot;Multiplier result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetScale;
</span><span class="boring">
</span><span class="boring">impl Port for SetScale {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Multiplier {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Multiplier {
</span><span class="boring">    fn new() -&gt; Multiplier {
</span><span class="boring">        Multiplier {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Linear {
    ctx: ComponentContext&lt;Self&gt;,
    scale: f32,
    offset: f32,
    set_scale: ProvidedPort&lt;SetScale&gt;,
    set_offset: ProvidedPort&lt;SetOffset&gt;,
}
info_lifecycle!(Linear);

impl Actor for Linear {
    type Message = f32;

    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
        let res = a * self.scale + self.offset;
        info!(self.log(), &quot;Linear result = {}&quot;, res);
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!()
    }
}

impl Provide&lt;SetOffset&gt; for Linear {
    fn handle(&amp;mut self, value: f32) -&gt; Handled {
        self.offset = value;
        Handled::Ok
    }
}

impl Provide&lt;SetScale&gt; for Linear {
    fn handle(&amp;mut self, value: f32) -&gt; Handled {
        self.scale = value;
        Handled::Ok
    }
}

impl Linear {
    fn new() -&gt; Linear {
        Linear {
            ctx: ComponentContext::uninitialised(),
            scale: 1.0,
            offset: 0.0,
            set_scale: ProvidedPort::uninitialised(),
            set_offset: ProvidedPort::uninitialised(),
        }
    }
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DynamicManager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    arithmetic_units: Vec&lt;Arc&lt;dyn AbstractComponent&lt;Message = f32&gt;&gt;&gt;,
</span><span class="boring">    set_offsets: RequiredPort&lt;SetOffset&gt;,
</span><span class="boring">    set_scales: RequiredPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_indications!(SetOffset, DynamicManager);
</span><span class="boring">ignore_indications!(SetScale, DynamicManager);
</span><span class="boring">ignore_lifecycle!(DynamicManager);
</span><span class="boring">
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Spawn(Box&lt;dyn CreateErased&lt;f32&gt; + Send&gt;),
</span><span class="boring">    Compute(f32),
</span><span class="boring">    SetScales(f32),
</span><span class="boring">    SetOffsets(f32),
</span><span class="boring">    KillAll,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Debug for ManagerMessage {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        match self {
</span><span class="boring">            ManagerMessage::Spawn(_) =&gt; {
</span><span class="boring">                write!(f, &quot;Spawn(_)&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                write!(f, &quot;Compute({})&quot;, *val)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; {
</span><span class="boring">                write!(f, &quot;SetScales({})&quot;, *scale)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; {
</span><span class="boring">                write!(f, &quot;SetOffsets({})&quot;, *offset)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                write!(f, &quot;KillAll&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                write!(f, &quot;Quit&quot;)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DynamicManager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: ManagerMessage) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Spawn(definition) =&gt; {
</span><span class="boring">                let system = self.ctx.system();
</span><span class="boring">                let component = system.create_erased(definition);
</span><span class="boring">                component.on_dyn_definition(|def| {
</span><span class="boring">                    if let Some(set_scale) = def.get_provided_port::&lt;SetScale&gt;() {
</span><span class="boring">                        biconnect_ports(set_scale, &amp;mut self.set_scales);
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(set_offset) = def.get_provided_port::&lt;SetOffset&gt;() {
</span><span class="boring">                        biconnect_ports(set_offset, &amp;mut self.set_offsets);
</span><span class="boring">                    }
</span><span class="boring">                });
</span><span class="boring">                system.start(&amp;component);
</span><span class="boring">
</span><span class="boring">                self.arithmetic_units.push(component);
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                for unit in &amp;self.arithmetic_units {
</span><span class="boring">                    unit.actor_ref().tell(val);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; self.set_scales.trigger(scale),
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; self.set_offsets.trigger(offset),
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">                self.ctx.system().shutdown_async();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DynamicManager {
</span><span class="boring">    fn kill_all(&amp;mut self) {
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        for unit in self.arithmetic_units.drain(..) {
</span><span class="boring">            system.kill(unit);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager: Arc&lt;Component&lt;DynamicManager&gt;&gt; = system.create(|| DynamicManager {
</span><span class="boring">        ctx: ComponentContext::uninitialised(),
</span><span class="boring">        arithmetic_units: vec![],
</span><span class="boring">        set_offsets: RequiredPort::uninitialised(),
</span><span class="boring">        set_scales: RequiredPort::uninitialised(),
</span><span class="boring">    });
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref();
</span><span class="boring">
</span><span class="boring">    std::thread::spawn(move || {
</span><span class="boring">        for line in stdin().lock().lines() {
</span><span class="boring">            let res = (|| -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">                let line = line?;
</span><span class="boring">
</span><span class="boring">                let message = match line.trim() {
</span><span class="boring">                    &quot;spawn adder&quot; =&gt; ManagerMessage::Spawn(Box::new(Adder::new())),
</span><span class="boring">                    &quot;spawn multiplier&quot; =&gt; ManagerMessage::Spawn(Box::new(Multiplier::new())),
</span><span class="boring">                    &quot;spawn linear&quot; =&gt; ManagerMessage::Spawn(Box::new(Linear::new())),
</span><span class="boring">                    &quot;kill all&quot; =&gt; ManagerMessage::KillAll,
</span><span class="boring">                    &quot;quit&quot; =&gt; ManagerMessage::Quit,
</span><span class="boring">                    other =&gt; {
</span><span class="boring">                        if let Some(offset) = other.strip_prefix(&quot;set offset &quot;) {
</span><span class="boring">                            ManagerMessage::SetOffsets(offset.parse()?)
</span><span class="boring">                        } else if let Some(scale) = other.strip_prefix(&quot;set scale &quot;) {
</span><span class="boring">                            ManagerMessage::SetScales(scale.parse()?)
</span><span class="boring">                        } else if let Some(val) = other.strip_prefix(&quot;compute &quot;) {
</span><span class="boring">                            ManagerMessage::Compute(val.parse()?)
</span><span class="boring">                        } else {
</span><span class="boring">                            Err(&quot;unknown command!&quot;)?
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                manager_ref.tell(message);
</span><span class="boring">
</span><span class="boring">                Ok(())
</span><span class="boring">            })();
</span><span class="boring">
</span><span class="boring">            if let Err(e) = res {
</span><span class="boring">                println!(&quot;{}&quot;, e);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>Now let’s write a manager component, which will take care of creating the components described above, killing them, 
modifying their settings, and sending them data to process. In this case we have just three different types of worker
components, but imagine we had tens (still sharing the same message type and some subsets of “settings”). In that case
it would be <strong>very</strong> tedious to manage all these component types explicitly.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">
</span><span class="boring">use kompact::{component::AbstractComponent, prelude::*};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    fmt,
</span><span class="boring">    io::{stdin, BufRead},
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Adder {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Adder);
</span><span class="boring">
</span><span class="boring">impl Actor for Adder {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Adder result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetOffset;
</span><span class="boring">
</span><span class="boring">impl Port for SetOffset {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Adder {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Adder {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Adder {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            offset: 0f32,
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Multiplier {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Multiplier);
</span><span class="boring">
</span><span class="boring">impl Actor for Multiplier {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale;
</span><span class="boring">        info!(self.log(), &quot;Multiplier result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetScale;
</span><span class="boring">
</span><span class="boring">impl Port for SetScale {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Multiplier {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Multiplier {
</span><span class="boring">    fn new() -&gt; Multiplier {
</span><span class="boring">        Multiplier {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Linear {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Linear);
</span><span class="boring">
</span><span class="boring">impl Actor for Linear {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Linear result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Linear {
</span><span class="boring">    fn new() -&gt; Linear {
</span><span class="boring">        Linear {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            offset: 0.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct DynamicManager {
    ctx: ComponentContext&lt;Self&gt;,
    arithmetic_units: Vec&lt;Arc&lt;dyn AbstractComponent&lt;Message = f32&gt;&gt;&gt;,
    set_offsets: RequiredPort&lt;SetOffset&gt;,
    set_scales: RequiredPort&lt;SetScale&gt;,
}

ignore_indications!(SetOffset, DynamicManager);
ignore_indications!(SetScale, DynamicManager);
ignore_lifecycle!(DynamicManager);
<span class="boring">
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Spawn(Box&lt;dyn CreateErased&lt;f32&gt; + Send&gt;),
</span><span class="boring">    Compute(f32),
</span><span class="boring">    SetScales(f32),
</span><span class="boring">    SetOffsets(f32),
</span><span class="boring">    KillAll,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Debug for ManagerMessage {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        match self {
</span><span class="boring">            ManagerMessage::Spawn(_) =&gt; {
</span><span class="boring">                write!(f, &quot;Spawn(_)&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                write!(f, &quot;Compute({})&quot;, *val)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; {
</span><span class="boring">                write!(f, &quot;SetScales({})&quot;, *scale)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; {
</span><span class="boring">                write!(f, &quot;SetOffsets({})&quot;, *offset)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                write!(f, &quot;KillAll&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                write!(f, &quot;Quit&quot;)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DynamicManager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: ManagerMessage) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Spawn(definition) =&gt; {
</span><span class="boring">                let system = self.ctx.system();
</span><span class="boring">                let component = system.create_erased(definition);
</span><span class="boring">                component.on_dyn_definition(|def| {
</span><span class="boring">                    if let Some(set_scale) = def.get_provided_port::&lt;SetScale&gt;() {
</span><span class="boring">                        biconnect_ports(set_scale, &amp;mut self.set_scales);
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(set_offset) = def.get_provided_port::&lt;SetOffset&gt;() {
</span><span class="boring">                        biconnect_ports(set_offset, &amp;mut self.set_offsets);
</span><span class="boring">                    }
</span><span class="boring">                });
</span><span class="boring">                system.start(&amp;component);
</span><span class="boring">
</span><span class="boring">                self.arithmetic_units.push(component);
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                for unit in &amp;self.arithmetic_units {
</span><span class="boring">                    unit.actor_ref().tell(val);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; self.set_scales.trigger(scale),
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; self.set_offsets.trigger(offset),
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">                self.ctx.system().shutdown_async();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DynamicManager {
</span><span class="boring">    fn kill_all(&amp;mut self) {
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        for unit in self.arithmetic_units.drain(..) {
</span><span class="boring">            system.kill(unit);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager: Arc&lt;Component&lt;DynamicManager&gt;&gt; = system.create(|| DynamicManager {
</span><span class="boring">        ctx: ComponentContext::uninitialised(),
</span><span class="boring">        arithmetic_units: vec![],
</span><span class="boring">        set_offsets: RequiredPort::uninitialised(),
</span><span class="boring">        set_scales: RequiredPort::uninitialised(),
</span><span class="boring">    });
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref();
</span><span class="boring">
</span><span class="boring">    std::thread::spawn(move || {
</span><span class="boring">        for line in stdin().lock().lines() {
</span><span class="boring">            let res = (|| -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">                let line = line?;
</span><span class="boring">
</span><span class="boring">                let message = match line.trim() {
</span><span class="boring">                    &quot;spawn adder&quot; =&gt; ManagerMessage::Spawn(Box::new(Adder::new())),
</span><span class="boring">                    &quot;spawn multiplier&quot; =&gt; ManagerMessage::Spawn(Box::new(Multiplier::new())),
</span><span class="boring">                    &quot;spawn linear&quot; =&gt; ManagerMessage::Spawn(Box::new(Linear::new())),
</span><span class="boring">                    &quot;kill all&quot; =&gt; ManagerMessage::KillAll,
</span><span class="boring">                    &quot;quit&quot; =&gt; ManagerMessage::Quit,
</span><span class="boring">                    other =&gt; {
</span><span class="boring">                        if let Some(offset) = other.strip_prefix(&quot;set offset &quot;) {
</span><span class="boring">                            ManagerMessage::SetOffsets(offset.parse()?)
</span><span class="boring">                        } else if let Some(scale) = other.strip_prefix(&quot;set scale &quot;) {
</span><span class="boring">                            ManagerMessage::SetScales(scale.parse()?)
</span><span class="boring">                        } else if let Some(val) = other.strip_prefix(&quot;compute &quot;) {
</span><span class="boring">                            ManagerMessage::Compute(val.parse()?)
</span><span class="boring">                        } else {
</span><span class="boring">                            Err(&quot;unknown command!&quot;)?
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                manager_ref.tell(message);
</span><span class="boring">
</span><span class="boring">                Ok(())
</span><span class="boring">            })();
</span><span class="boring">
</span><span class="boring">            if let Err(e) = res {
</span><span class="boring">                println!(&quot;{}&quot;, e);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>Using <code>Arc&lt;dyn AbstractComponent&lt;Message=M&gt;&gt;</code> we can mix different components that take the same type of message in one
collection. Now to fill that <code>Vec</code> with something useful. We’ll define some messages for the manager and start creating 
some components.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">
</span><span class="boring">use kompact::{component::AbstractComponent, prelude::*};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    fmt,
</span><span class="boring">    io::{stdin, BufRead},
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Adder {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Adder);
</span><span class="boring">
</span><span class="boring">impl Actor for Adder {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Adder result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetOffset;
</span><span class="boring">
</span><span class="boring">impl Port for SetOffset {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Adder {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Adder {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Adder {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            offset: 0f32,
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Multiplier {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Multiplier);
</span><span class="boring">
</span><span class="boring">impl Actor for Multiplier {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale;
</span><span class="boring">        info!(self.log(), &quot;Multiplier result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetScale;
</span><span class="boring">
</span><span class="boring">impl Port for SetScale {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Multiplier {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Multiplier {
</span><span class="boring">    fn new() -&gt; Multiplier {
</span><span class="boring">        Multiplier {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Linear {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Linear);
</span><span class="boring">
</span><span class="boring">impl Actor for Linear {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Linear result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Linear {
</span><span class="boring">    fn new() -&gt; Linear {
</span><span class="boring">        Linear {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            offset: 0.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DynamicManager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    arithmetic_units: Vec&lt;Arc&lt;dyn AbstractComponent&lt;Message = f32&gt;&gt;&gt;,
</span><span class="boring">    set_offsets: RequiredPort&lt;SetOffset&gt;,
</span><span class="boring">    set_scales: RequiredPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_indications!(SetOffset, DynamicManager);
</span><span class="boring">ignore_indications!(SetScale, DynamicManager);
</span><span class="boring">ignore_lifecycle!(DynamicManager);
</span><span class="boring">
</span>enum ManagerMessage {
    Spawn(Box&lt;dyn CreateErased&lt;f32&gt; + Send&gt;),
    Compute(f32),
    SetScales(f32),
    SetOffsets(f32),
    KillAll,
    Quit,
}

impl fmt::Debug for ManagerMessage {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            ManagerMessage::Spawn(_) =&gt; {
                write!(f, &quot;Spawn(_)&quot;)
            }
            ManagerMessage::Compute(val) =&gt; {
                write!(f, &quot;Compute({})&quot;, *val)
            }
            ManagerMessage::SetScales(scale) =&gt; {
                write!(f, &quot;SetScales({})&quot;, *scale)
            }
            ManagerMessage::SetOffsets(offset) =&gt; {
                write!(f, &quot;SetOffsets({})&quot;, *offset)
            }
            ManagerMessage::KillAll =&gt; {
                write!(f, &quot;KillAll&quot;)
            }
            ManagerMessage::Quit =&gt; {
                write!(f, &quot;Quit&quot;)
            }
        }
    }
}

impl Actor for DynamicManager {
    type Message = ManagerMessage;

    fn receive_local(&amp;mut self, msg: ManagerMessage) -&gt; Handled {
        match msg {
            ManagerMessage::Spawn(definition) =&gt; {
                let system = self.ctx.system();
                let component = system.create_erased(definition);
<span class="boring">                component.on_dyn_definition(|def| {
</span><span class="boring">                    if let Some(set_scale) = def.get_provided_port::&lt;SetScale&gt;() {
</span><span class="boring">                        biconnect_ports(set_scale, &amp;mut self.set_scales);
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(set_offset) = def.get_provided_port::&lt;SetOffset&gt;() {
</span><span class="boring">                        biconnect_ports(set_offset, &amp;mut self.set_offsets);
</span><span class="boring">                    }
</span><span class="boring">                });
</span><span class="boring">                system.start(&amp;component);
</span><span class="boring">
</span><span class="boring">                self.arithmetic_units.push(component);
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                for unit in &amp;self.arithmetic_units {
</span><span class="boring">                    unit.actor_ref().tell(val);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; self.set_scales.trigger(scale),
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; self.set_offsets.trigger(offset),
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">                self.ctx.system().shutdown_async();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DynamicManager {
</span><span class="boring">    fn kill_all(&amp;mut self) {
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        for unit in self.arithmetic_units.drain(..) {
</span><span class="boring">            system.kill(unit);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager: Arc&lt;Component&lt;DynamicManager&gt;&gt; = system.create(|| DynamicManager {
</span><span class="boring">        ctx: ComponentContext::uninitialised(),
</span><span class="boring">        arithmetic_units: vec![],
</span><span class="boring">        set_offsets: RequiredPort::uninitialised(),
</span><span class="boring">        set_scales: RequiredPort::uninitialised(),
</span><span class="boring">    });
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref();
</span><span class="boring">
</span><span class="boring">    std::thread::spawn(move || {
</span><span class="boring">        for line in stdin().lock().lines() {
</span><span class="boring">            let res = (|| -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">                let line = line?;
</span><span class="boring">
</span><span class="boring">                let message = match line.trim() {
</span><span class="boring">                    &quot;spawn adder&quot; =&gt; ManagerMessage::Spawn(Box::new(Adder::new())),
</span><span class="boring">                    &quot;spawn multiplier&quot; =&gt; ManagerMessage::Spawn(Box::new(Multiplier::new())),
</span><span class="boring">                    &quot;spawn linear&quot; =&gt; ManagerMessage::Spawn(Box::new(Linear::new())),
</span><span class="boring">                    &quot;kill all&quot; =&gt; ManagerMessage::KillAll,
</span><span class="boring">                    &quot;quit&quot; =&gt; ManagerMessage::Quit,
</span><span class="boring">                    other =&gt; {
</span><span class="boring">                        if let Some(offset) = other.strip_prefix(&quot;set offset &quot;) {
</span><span class="boring">                            ManagerMessage::SetOffsets(offset.parse()?)
</span><span class="boring">                        } else if let Some(scale) = other.strip_prefix(&quot;set scale &quot;) {
</span><span class="boring">                            ManagerMessage::SetScales(scale.parse()?)
</span><span class="boring">                        } else if let Some(val) = other.strip_prefix(&quot;compute &quot;) {
</span><span class="boring">                            ManagerMessage::Compute(val.parse()?)
</span><span class="boring">                        } else {
</span><span class="boring">                            Err(&quot;unknown command!&quot;)?
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                manager_ref.tell(message);
</span><span class="boring">
</span><span class="boring">                Ok(())
</span><span class="boring">            })();
</span><span class="boring">
</span><span class="boring">            if let Err(e) = res {
</span><span class="boring">                println!(&quot;{}&quot;, e);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>As we don’t want the manager type to know about the concrete component types <em>at all</em>, the <code>Spawn</code> message above contains a
boxed, type-erased component definition, which we then turn into a component using <code>create_erased</code>.</p>
<p>Normally, after creating the components we would connect the ports to each other using <code>connect_to_required</code>, or maybe
<code>on_definition</code> and direct port access. However, all of those require concrete types, like <code>Arc&lt;Component&lt;Adder&gt;&gt;</code>
or <code>Arc&lt;Component&lt;Linear&gt;&gt;</code>, which is not what we get here (<code>Arc&lt;dyn AbstractComponent&lt;Message=f32&gt;</code>). Instead we can use
<code>on_dyn_definition</code> together with the <code>Option</code>-returning <code>get_{provided,required}_port</code> to dynamically check if a given
port exists on the abstract component and, if so, fetch it. </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">
</span><span class="boring">use kompact::{component::AbstractComponent, prelude::*};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    fmt,
</span><span class="boring">    io::{stdin, BufRead},
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Adder {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Adder);
</span><span class="boring">
</span><span class="boring">impl Actor for Adder {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Adder result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetOffset;
</span><span class="boring">
</span><span class="boring">impl Port for SetOffset {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Adder {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Adder {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Adder {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            offset: 0f32,
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Multiplier {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Multiplier);
</span><span class="boring">
</span><span class="boring">impl Actor for Multiplier {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale;
</span><span class="boring">        info!(self.log(), &quot;Multiplier result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetScale;
</span><span class="boring">
</span><span class="boring">impl Port for SetScale {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Multiplier {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Multiplier {
</span><span class="boring">    fn new() -&gt; Multiplier {
</span><span class="boring">        Multiplier {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Linear {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Linear);
</span><span class="boring">
</span><span class="boring">impl Actor for Linear {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Linear result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Linear {
</span><span class="boring">    fn new() -&gt; Linear {
</span><span class="boring">        Linear {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            offset: 0.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DynamicManager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    arithmetic_units: Vec&lt;Arc&lt;dyn AbstractComponent&lt;Message = f32&gt;&gt;&gt;,
</span><span class="boring">    set_offsets: RequiredPort&lt;SetOffset&gt;,
</span><span class="boring">    set_scales: RequiredPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_indications!(SetOffset, DynamicManager);
</span><span class="boring">ignore_indications!(SetScale, DynamicManager);
</span><span class="boring">ignore_lifecycle!(DynamicManager);
</span><span class="boring">
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Spawn(Box&lt;dyn CreateErased&lt;f32&gt; + Send&gt;),
</span><span class="boring">    Compute(f32),
</span><span class="boring">    SetScales(f32),
</span><span class="boring">    SetOffsets(f32),
</span><span class="boring">    KillAll,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Debug for ManagerMessage {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        match self {
</span><span class="boring">            ManagerMessage::Spawn(_) =&gt; {
</span><span class="boring">                write!(f, &quot;Spawn(_)&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                write!(f, &quot;Compute({})&quot;, *val)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; {
</span><span class="boring">                write!(f, &quot;SetScales({})&quot;, *scale)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; {
</span><span class="boring">                write!(f, &quot;SetOffsets({})&quot;, *offset)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                write!(f, &quot;KillAll&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                write!(f, &quot;Quit&quot;)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DynamicManager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: ManagerMessage) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Spawn(definition) =&gt; {
</span><span class="boring">                let system = self.ctx.system();
</span><span class="boring">                let component = system.create_erased(definition);
</span>                component.on_dyn_definition(|def| {
                    if let Some(set_scale) = def.get_provided_port::&lt;SetScale&gt;() {
                        biconnect_ports(set_scale, &amp;mut self.set_scales);
                    }
                    if let Some(set_offset) = def.get_provided_port::&lt;SetOffset&gt;() {
                        biconnect_ports(set_offset, &amp;mut self.set_offsets);
                    }
                });
                system.start(&amp;component);

                self.arithmetic_units.push(component);
            }
            ManagerMessage::Compute(val) =&gt; {
                for unit in &amp;self.arithmetic_units {
                    unit.actor_ref().tell(val);
                }
            }
            ManagerMessage::SetScales(scale) =&gt; self.set_scales.trigger(scale),
            ManagerMessage::SetOffsets(offset) =&gt; self.set_offsets.trigger(offset),
            ManagerMessage::KillAll =&gt; {
                self.kill_all();
            }
            ManagerMessage::Quit =&gt; {
                self.kill_all();
                self.ctx.system().shutdown_async();
            }
        }

        Handled::Ok
    }

    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
        unimplemented!()
    }
}

impl DynamicManager {
    fn kill_all(&amp;mut self) {
        let system = self.ctx.system();
        for unit in self.arithmetic_units.drain(..) {
            system.kill(unit);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager: Arc&lt;Component&lt;DynamicManager&gt;&gt; = system.create(|| DynamicManager {
</span><span class="boring">        ctx: ComponentContext::uninitialised(),
</span><span class="boring">        arithmetic_units: vec![],
</span><span class="boring">        set_offsets: RequiredPort::uninitialised(),
</span><span class="boring">        set_scales: RequiredPort::uninitialised(),
</span><span class="boring">    });
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref();
</span><span class="boring">
</span><span class="boring">    std::thread::spawn(move || {
</span><span class="boring">        for line in stdin().lock().lines() {
</span><span class="boring">            let res = (|| -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">                let line = line?;
</span><span class="boring">
</span><span class="boring">                let message = match line.trim() {
</span><span class="boring">                    &quot;spawn adder&quot; =&gt; ManagerMessage::Spawn(Box::new(Adder::new())),
</span><span class="boring">                    &quot;spawn multiplier&quot; =&gt; ManagerMessage::Spawn(Box::new(Multiplier::new())),
</span><span class="boring">                    &quot;spawn linear&quot; =&gt; ManagerMessage::Spawn(Box::new(Linear::new())),
</span><span class="boring">                    &quot;kill all&quot; =&gt; ManagerMessage::KillAll,
</span><span class="boring">                    &quot;quit&quot; =&gt; ManagerMessage::Quit,
</span><span class="boring">                    other =&gt; {
</span><span class="boring">                        if let Some(offset) = other.strip_prefix(&quot;set offset &quot;) {
</span><span class="boring">                            ManagerMessage::SetOffsets(offset.parse()?)
</span><span class="boring">                        } else if let Some(scale) = other.strip_prefix(&quot;set scale &quot;) {
</span><span class="boring">                            ManagerMessage::SetScales(scale.parse()?)
</span><span class="boring">                        } else if let Some(val) = other.strip_prefix(&quot;compute &quot;) {
</span><span class="boring">                            ManagerMessage::Compute(val.parse()?)
</span><span class="boring">                        } else {
</span><span class="boring">                            Err(&quot;unknown command!&quot;)?
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                manager_ref.tell(message);
</span><span class="boring">
</span><span class="boring">                Ok(())
</span><span class="boring">            })();
</span><span class="boring">
</span><span class="boring">            if let Err(e) = res {
</span><span class="boring">                println!(&quot;{}&quot;, e);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    system.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>Now that we have the dynamic component part done, we can write a very simple repl. We’ll start the Kompact system in the
main thread, create the manager there, and await system termination. In a separate thread we’ll continuously read <code>stdin</code>
and interpret the lines as commands to send to the manager.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">
</span><span class="boring">use kompact::{component::AbstractComponent, prelude::*};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    fmt,
</span><span class="boring">    io::{stdin, BufRead},
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Adder {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Adder);
</span><span class="boring">
</span><span class="boring">impl Actor for Adder {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Adder result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetOffset;
</span><span class="boring">
</span><span class="boring">impl Port for SetOffset {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Adder {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Adder {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Adder {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            offset: 0f32,
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Multiplier {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Multiplier);
</span><span class="boring">
</span><span class="boring">impl Actor for Multiplier {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale;
</span><span class="boring">        info!(self.log(), &quot;Multiplier result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SetScale;
</span><span class="boring">
</span><span class="boring">impl Port for SetScale {
</span><span class="boring">    type Indication = Never;
</span><span class="boring">    type Request = f32;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Multiplier {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Multiplier {
</span><span class="boring">    fn new() -&gt; Multiplier {
</span><span class="boring">        Multiplier {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Linear {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    scale: f32,
</span><span class="boring">    offset: f32,
</span><span class="boring">    set_scale: ProvidedPort&lt;SetScale&gt;,
</span><span class="boring">    set_offset: ProvidedPort&lt;SetOffset&gt;,
</span><span class="boring">}
</span><span class="boring">info_lifecycle!(Linear);
</span><span class="boring">
</span><span class="boring">impl Actor for Linear {
</span><span class="boring">    type Message = f32;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, a: Self::Message) -&gt; Handled {
</span><span class="boring">        let res = a * self.scale + self.offset;
</span><span class="boring">        info!(self.log(), &quot;Linear result = {}&quot;, res);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetOffset&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.offset = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;SetScale&gt; for Linear {
</span><span class="boring">    fn handle(&amp;mut self, value: f32) -&gt; Handled {
</span><span class="boring">        self.scale = value;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Linear {
</span><span class="boring">    fn new() -&gt; Linear {
</span><span class="boring">        Linear {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            scale: 1.0,
</span><span class="boring">            offset: 0.0,
</span><span class="boring">            set_scale: ProvidedPort::uninitialised(),
</span><span class="boring">            set_offset: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DynamicManager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    arithmetic_units: Vec&lt;Arc&lt;dyn AbstractComponent&lt;Message = f32&gt;&gt;&gt;,
</span><span class="boring">    set_offsets: RequiredPort&lt;SetOffset&gt;,
</span><span class="boring">    set_scales: RequiredPort&lt;SetScale&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_indications!(SetOffset, DynamicManager);
</span><span class="boring">ignore_indications!(SetScale, DynamicManager);
</span><span class="boring">ignore_lifecycle!(DynamicManager);
</span><span class="boring">
</span><span class="boring">enum ManagerMessage {
</span><span class="boring">    Spawn(Box&lt;dyn CreateErased&lt;f32&gt; + Send&gt;),
</span><span class="boring">    Compute(f32),
</span><span class="boring">    SetScales(f32),
</span><span class="boring">    SetOffsets(f32),
</span><span class="boring">    KillAll,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Debug for ManagerMessage {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        match self {
</span><span class="boring">            ManagerMessage::Spawn(_) =&gt; {
</span><span class="boring">                write!(f, &quot;Spawn(_)&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                write!(f, &quot;Compute({})&quot;, *val)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; {
</span><span class="boring">                write!(f, &quot;SetScales({})&quot;, *scale)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; {
</span><span class="boring">                write!(f, &quot;SetOffsets({})&quot;, *offset)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                write!(f, &quot;KillAll&quot;)
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                write!(f, &quot;Quit&quot;)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DynamicManager {
</span><span class="boring">    type Message = ManagerMessage;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: ManagerMessage) -&gt; Handled {
</span><span class="boring">        match msg {
</span><span class="boring">            ManagerMessage::Spawn(definition) =&gt; {
</span><span class="boring">                let system = self.ctx.system();
</span><span class="boring">                let component = system.create_erased(definition);
</span><span class="boring">                component.on_dyn_definition(|def| {
</span><span class="boring">                    if let Some(set_scale) = def.get_provided_port::&lt;SetScale&gt;() {
</span><span class="boring">                        biconnect_ports(set_scale, &amp;mut self.set_scales);
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(set_offset) = def.get_provided_port::&lt;SetOffset&gt;() {
</span><span class="boring">                        biconnect_ports(set_offset, &amp;mut self.set_offsets);
</span><span class="boring">                    }
</span><span class="boring">                });
</span><span class="boring">                system.start(&amp;component);
</span><span class="boring">
</span><span class="boring">                self.arithmetic_units.push(component);
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Compute(val) =&gt; {
</span><span class="boring">                for unit in &amp;self.arithmetic_units {
</span><span class="boring">                    unit.actor_ref().tell(val);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::SetScales(scale) =&gt; self.set_scales.trigger(scale),
</span><span class="boring">            ManagerMessage::SetOffsets(offset) =&gt; self.set_offsets.trigger(offset),
</span><span class="boring">            ManagerMessage::KillAll =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">            }
</span><span class="boring">            ManagerMessage::Quit =&gt; {
</span><span class="boring">                self.kill_all();
</span><span class="boring">                self.ctx.system().shutdown_async();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DynamicManager {
</span><span class="boring">    fn kill_all(&amp;mut self) {
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        for unit in self.arithmetic_units.drain(..) {
</span><span class="boring">            system.kill(unit);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
   let system = KompactConfig::default().build().expect(&quot;system&quot;);
   let manager: Arc&lt;Component&lt;DynamicManager&gt;&gt; = system.create(|| DynamicManager {
       ctx: ComponentContext::uninitialised(),
       arithmetic_units: vec![],
       set_offsets: RequiredPort::uninitialised(),
       set_scales: RequiredPort::uninitialised(),
   });
   system.start(&amp;manager);
   let manager_ref = manager.actor_ref();

   std::thread::spawn(move || {
       for line in stdin().lock().lines() {
           let res = (|| -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
               let line = line?;

               let message = match line.trim() {
                   &quot;spawn adder&quot; =&gt; ManagerMessage::Spawn(Box::new(Adder::new())),
                   &quot;spawn multiplier&quot; =&gt; ManagerMessage::Spawn(Box::new(Multiplier::new())),
                   &quot;spawn linear&quot; =&gt; ManagerMessage::Spawn(Box::new(Linear::new())),
                   &quot;kill all&quot; =&gt; ManagerMessage::KillAll,
                   &quot;quit&quot; =&gt; ManagerMessage::Quit,
                   other =&gt; {
                       if let Some(offset) = other.strip_prefix(&quot;set offset &quot;) {
                           ManagerMessage::SetOffsets(offset.parse()?)
                       } else if let Some(scale) = other.strip_prefix(&quot;set scale &quot;) {
                           ManagerMessage::SetScales(scale.parse()?)
                       } else if let Some(val) = other.strip_prefix(&quot;compute &quot;) {
                           ManagerMessage::Compute(val.parse()?)
                       } else {
                           Err(&quot;unknown command!&quot;)?
                       }
                   }
               };

               manager_ref.tell(message);

               Ok(())
           })();

           if let Err(e) = res {
               println!(&quot;{}&quot;, e);
           }
       }
   });

   system.await_termination();
}
</code></pre>
<p>When run, it looks something like this:</p>
<pre><code>❯ cargo run --features=type_erasure,silent_logging --bin dynamic_components
   Compiling kompact-examples v0.10.0 (/home/mrobakowski/projects/kompact/docs/examples)
    Finished dev [unoptimized + debuginfo] target(s) in 2.56s
     Running `/home/mrobakowski/projects/kompact/target/debug/dynamic_components`
compute 1
spawn adder
Nov 09 00:55:59.917 INFO Starting..., ctype: Adder, cid: 79bd396b-de75-4284-bc57-e0cf8193f72f, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:39
set offset 5
compute 1
Nov 09 00:56:43.465 INFO Adder result = 6, ctype: Adder, cid: 79bd396b-de75-4284-bc57-e0cf8193f72f, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:46
spawn multiplier
Nov 09 00:56:55.518 INFO Starting..., ctype: Multiplier, cid: 47dd4827-8d35-4351-a717-344ec7fe70fe, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:85
set scale 2
compute 2
Nov 09 00:57:09.684 INFO Adder result = 7, ctype: Adder, cid: 79bd396b-de75-4284-bc57-e0cf8193f72f, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:46
Nov 09 00:57:09.684 INFO Multiplier result = 4, ctype: Multiplier, cid: 47dd4827-8d35-4351-a717-344ec7fe70fe, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:92
kill all
Nov 09 00:57:17.769 INFO Killing..., ctype: Adder, cid: 79bd396b-de75-4284-bc57-e0cf8193f72f, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:39
Nov 09 00:57:17.769 INFO Killing..., ctype: Multiplier, cid: 47dd4827-8d35-4351-a717-344ec7fe70fe, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:85
spawn linear
Nov 09 00:57:24.840 INFO Starting..., ctype: Linear, cid: d0f01d1a-b448-4b5f-bddd-701d764992ea, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:135
spawn adder
Nov 09 00:57:32.136 INFO Starting..., ctype: Adder, cid: c3b9a0c5-875d-4e1d-8c70-3b414fe2a7bb, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:39
set offset 2
set scale 3
compute 4
Nov 09 00:57:41.558 INFO Linear result = 14, ctype: Linear, cid: d0f01d1a-b448-4b5f-bddd-701d764992ea, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:142
Nov 09 00:57:41.558 INFO Adder result = 6, ctype: Adder, cid: c3b9a0c5-875d-4e1d-8c70-3b414fe2a7bb, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:46
quit
Nov 09 00:57:51.351 INFO Killing..., ctype: Linear, cid: d0f01d1a-b448-4b5f-bddd-701d764992ea, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:135
Nov 09 00:57:51.352 INFO Killing..., ctype: Adder, cid: c3b9a0c5-875d-4e1d-8c70-3b414fe2a7bb, system: kompact-runtime-1, location: docs/examples/src/bin/dynamic_components.rs:39

</code></pre>
<h1 id="distributed-kompact"><a class="header" href="#distributed-kompact">Distributed Kompact</a></h1>
<p>Each Kompact system can be configured to use a networking library, called a <code>Dispatcher</code>, to communicate with other remote systems. In order to send messages to remote components, a special kind of actor reference is needed: an <code>ActorPath</code>. This is different from an <code>ActorRef</code> in that it contains the necessary information to route a message to the target component, not a reference to a queue. The queue for this kind of message is the system wide <code>Dispatcher</code>, which is responsible for figuring out how to get the message to the target indicated in the <code>ActorPath</code>. The implementation provided in the <code>NetworkDispatcher</code> that ships with Kompact will automatically establish and maintain the needed network links for any target you are sending to.</p>
<h2 id="actor-paths"><a class="header" href="#actor-paths">Actor Paths</a></h2>
<p>In addition to serving as opaque handles to remote components, actor paths can also be treated as human-readable resource identifiers. Internally, they are divided into two major parts:</p>
<ol>
<li>A <code>SystemPath</code>, which identifies the Kompact system we are trying to send to, and</li>
<li>the actual actor path tail, which identifies the actor within the system.</li>
</ol>
<p>Kompact provides two flavours of actor paths: </p>
<ol>
<li>A <em>Unique Path</em> identifies exactly one concrete instance of a component.</li>
<li>A <em>Named Path</em> can identify one or more instances of a component providing some service. The component(s) that a named path points to can be changed dynamically over time.</li>
</ol>
<p>Examples of actor path string representations are:</p>
<ul>
<li><code>tcp://127.0.0.1:63482#c6a799f0-77ff-4548-9726-744b90556ce7</code> (unique)</li>
<li><code>tcp://127.0.0.1:63482/my-service/instance1</code> (named)</li>
</ul>
<h3 id="system-paths"><a class="header" href="#system-paths">System Paths</a></h3>
<p>A system path is essentially the same as you would address a server over a network. It specifies the transport protocol to use, the IP address, and the port. Different dispatchers are free to implement whichever set of transport protocols they wish to support. The provided <code>NetworkDispatcher</code> currently only offers TCP, in addition to the “fake” <code>local</code> protocol, which simply specifies an actor path within the same system via the dispatcher.</p>
<p>The <code>SystemPath</code> type specifies a system path alone, and can be acquired via <code>KompactSystem::system_path()</code>, for example. It doesn’t have any function by itself, but can be used to build up a full actor path or for comparisons, for example.</p>
<h3 id="unique-paths"><a class="header" href="#unique-paths">Unique Paths</a></h3>
<p>The <code>ActorPath::Unique</code> variant identifies a concrete instance of a component by its unique identifier, that is the same one you would get with <code>self.ctx.id()</code>, for example. So a unique path is really just a system path combined with a component id, which in the string representation is separated by a <code>#</code> character, e.g.: <code>tcp://127.0.0.1:63482#c6a799f0-77ff-4548-9726-744b90556ce7</code></p>
<p>That means that once the target component is destroyed (due to a fault, for example) its unique actor path becomes invalid and can not be reassigned to even if a component of the same type is started to take its place. That makes unique paths relatively inflexible. However, the dispatcher is significantly faster at resolving unique paths compared to named paths, so they are still recommended for performance critical communication.</p>
<h3 id="named-paths"><a class="header" href="#named-paths">Named Paths</a></h3>
<p>The <code>ActorPath::Named</code> variant is more flexible than a unique path, in that it can be reassigned later. It also allows the specification of an actual path, that is a sequence of strings, which could be hierarchical like in a filesystem. This opens up the possibilities for things like broadcast or routing semantics over path subtrees, for example.</p>
<p>In human-readable format a named path is represented by a system path followed by a sequence of strings beginning with and separated by forward slash (<code>/</code>) characters, just like a unix filesystem path would, e.g.: <code>tcp://127.0.0.1:63482/my-service/instance1</code></p>
<p>Multiple named paths can be registered to the same component.</p>
<h1 id="basic-communication"><a class="header" href="#basic-communication">Basic Communication</a></h1>
<p>In order to use remote communication with Kompact we need to replace the default <code>Dispatcher</code> implementation, with the provided <code>NetworkDispatcher</code>. Custom dispatchers in general are set with the <code>KompactConfig::system_components(...)</code> function, which also allows replacement of the system’s deadletter box, that is the component that handles messages where no recipient could be resolved. An instance of the <code>NetworkDispatcher</code> should be created via its configuration struct using <code>NetworkConfig::build()</code>. This type also allows to specify the listening socket for the system via <code>KompactConfig::with_socket(...)</code>. The default implementation will bind to <code>127.0.0.1</code> on a random free port. Attempting to bind on an occupied port, or without appropriate rights on a reserved port such as 80 will cause the creation of the <code>KompactSystem</code> instance to fail.</p>
<p>Once a Kompact system with a network dispatcher is created, we need to acquire actor paths for each component we want to be addressable. Kompact requires components to be explicitly registered with a dispatcher and returns an appropriate actor path as the result of a successful registration. The easiest way to acquire a registered component and a unique actor path for it, is to call <code>KompactSystem::create_and_register(...)</code> instead of <code>KompactSystem::create(...)</code> when creating it. This will return both the component and a future with the actor path, which completes once registration was successful. It is typically recommended not to start a component before registration is complete, as messages it sends with its unique path as source might not be answerable until registration is completed.</p>
<p>Sending messages is achieved by calling <code>ActorPath::tell(...)</code> with something that is serialisable (i.e. implements the <code>Serialisable</code> trait) and something that can produce a source address as well as a reference to the <code>Dispatcher</code>, typically just <code>self</code> from within a component.</p>
<p>In order to receive messages, a component must implement (some variant of) the <code>Actor</code> trait, and in particular its <code>receive_network(...)</code> function. Deserialisation happens lazily in Kompact, that means components are passed serialised data and a serialisation identifier in the form of a <code>NetworkMessage</code> message. They must then decide based on the identifier if they want to try and deserialise the content into a message. This can be done using the <code>NetworkMessage::try_deserialise::&lt;TargetType, Deserialiser&gt;()</code> function, or more conveniently for multiple messages via the <code>match_deser!</code> macro. We will get back to serialisation in more detail <a href="distributed/serialisation.html">later</a>.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>In this section we will go through a concrete example of a distributed service in Kompact. In particular, we are going to develop a distributed leader election abstraction, which internally uses heartbeats to establish a “candidate set” of live nodes, and then deterministically picks one node from the set to be the “leader”.</p>
<h3 id="local-abstraction"><a class="header" href="#local-abstraction">Local Abstraction</a></h3>
<p>Locally we want to expose a port abstraction called <code>EventualLeaderDetection</code>, which has no requests and only a single indication: The <code>Trust</code> event indicates the selection of a new leader.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">pub struct Heartbeat;
</span><span class="boring">impl SerialisationId for Heartbeat {
</span><span class="boring">    const SER_ID: SerId = 1234;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Clone, Debug)]
pub struct Trust(pub ActorPath);

pub struct EventualLeaderDetection;
impl Port for EventualLeaderDetection {
    type Indication = Trust;
    type Request = Never;
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">pub struct TrustPrinter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: RequiredPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">}
</span><span class="boring">impl TrustPrinter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        TrustPrinter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: RequiredPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(TrustPrinter);
</span><span class="boring">
</span><span class="boring">impl Require&lt;EventualLeaderDetection&gt; for TrustPrinter {
</span><span class="boring">    fn handle(&amp;mut self, event: Trust) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Got leader: {}.&quot;, event.0);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In order to see some results later when we run it, we will also add a quick printer component for these <code>Trust</code> events:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">pub struct Heartbeat;
</span><span class="boring">impl SerialisationId for Heartbeat {
</span><span class="boring">    const SER_ID: SerId = 1234;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">pub struct Trust(pub ActorPath);
</span><span class="boring">
</span><span class="boring">pub struct EventualLeaderDetection;
</span><span class="boring">impl Port for EventualLeaderDetection {
</span><span class="boring">    type Indication = Trust;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
pub struct TrustPrinter {
    ctx: ComponentContext&lt;Self&gt;,
    omega_port: RequiredPort&lt;EventualLeaderDetection&gt;,
}
impl TrustPrinter {
    pub fn new() -&gt; Self {
        TrustPrinter {
            ctx: ComponentContext::uninitialised(),
            omega_port: RequiredPort::uninitialised(),
        }
    }
}

ignore_lifecycle!(TrustPrinter);

impl Require&lt;EventualLeaderDetection&gt; for TrustPrinter {
    fn handle(&amp;mut self, event: Trust) -&gt; Handled {
        info!(self.log(), &quot;Got leader: {}.&quot;, event.0);
        Handled::Ok
    }
}
</code></pre>
<h3 id="messages-2"><a class="header" href="#messages-2">Messages</a></h3>
<p>We have two ways to interact with our leader election implementation: Different instances will send <code>Heartbeat</code> message over the network among themselves. For simplicity we will use <a href="https://crates.io/crates/serde">Serde</a> as a serialisation mechanism for now. For Serde serialisation to work correctly with Kompact we have assign a serialisation id to <code>Heartbeat</code>, that is a unique number that can be used to identify it during deserialisation. It’s very similar to a <code>TypeId</code>, except that it’s guaranteed to be same in any binary generated with the code included since the constant is hardcoded. For the example, we’ll simply use <code>1234</code> since that isn’t taken, yet. In a larger project, however, it’s important to keep track of these ids to prevent duplicates.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
pub struct Heartbeat;
impl SerialisationId for Heartbeat {
    const SER_ID: SerId = 1234;
}
<span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">pub struct Trust(pub ActorPath);
</span><span class="boring">
</span><span class="boring">pub struct EventualLeaderDetection;
</span><span class="boring">impl Port for EventualLeaderDetection {
</span><span class="boring">    type Indication = Trust;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">pub struct TrustPrinter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: RequiredPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">}
</span><span class="boring">impl TrustPrinter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        TrustPrinter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: RequiredPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(TrustPrinter);
</span><span class="boring">
</span><span class="boring">impl Require&lt;EventualLeaderDetection&gt; for TrustPrinter {
</span><span class="boring">    fn handle(&amp;mut self, event: Trust) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Got leader: {}.&quot;, event.0);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Additionally, we want be able to change the set of involved processes at runtime. This is primarily due to the fact that we will use unique paths for now and we simply don’t know the full set of unique paths at creation time of the actors that they refer to.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span>#[derive(Debug)]
struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    processes: Arc&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; () {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = UpdateProcesses;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Received new process set with {} processes&quot;,
</span><span class="boring">            msg.0.len()
</span><span class="boring">        );
</span><span class="boring">        let UpdateProcesses(processes) = msg;
</span><span class="boring">        self.processes = processes;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
</span><span class="boring">            Ok(_heartbeat) =&gt; {
</span><span class="boring">                self.candidates.insert(sender);
</span><span class="boring">            }
</span><span class="boring">            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        2,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of systems.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_systems(num_systems);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_systems(num_systems: usize) {
</span><span class="boring">    let mut systems: Vec&lt;KompactSystem&gt; = {
</span><span class="boring">        let system = || {
</span><span class="boring">            let mut cfg = KompactConfig::default();
</span><span class="boring">            cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">            cfg.build().expect(&quot;KompactSystem&quot;)
</span><span class="boring">        };
</span><span class="boring">        let mut data = Vec::with_capacity(num_systems);
</span><span class="boring">        for _i in 0..num_systems {
</span><span class="boring">            let sys = system();
</span><span class="boring">            data.push(sys);
</span><span class="boring">        }
</span><span class="boring">        data
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|sys| {
</span><span class="boring">            let printer = sys.create(TrustPrinter::new);
</span><span class="boring">            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
</span><span class="boring">            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
</span><span class="boring">                .expect(&quot;connection&quot;);
</span><span class="boring">            let path =
</span><span class="boring">                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
</span><span class="boring">            sys.start(&amp;printer);
</span><span class="boring">            sys.start(&amp;detector);
</span><span class="boring">            (path, detector.actor_ref())
</span><span class="boring">        })
</span><span class="boring">        .unzip();
</span><span class="boring">
</span><span class="boring">    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();
</span><span class="boring">
</span><span class="boring">    actors.iter().for_each(|actor| {
</span><span class="boring">        let update = UpdateProcesses(shared_processes.clone());
</span><span class="boring">        actor.tell(update);
</span><span class="boring">    });
</span><span class="boring">    // let them settle
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    // shut down systems one by one
</span><span class="boring">    for sys in systems.drain(..) {
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="state-2"><a class="header" href="#state-2">State</a></h3>
<p>There is a bit of state we need to keep track of in our <code>EventualLeaderElector</code> component:</p>
<ul>
<li>First me must provide the <code>EventualLeaderDetection</code> port, of course. </li>
<li>We also need to track the current process set, which we will handle as a boxed slice shared behind an <code>Arc</code>, since all components should have the same set anyway. Of course, if we were running this in real distribution, and not just with multiple systems in a single process, we would probably only run a single instance per process and a simple boxed slice (or just a normal vector) would probably be more sensible. </li>
<li>Further we must track the current candidate set, for which we will use a standard <code>HashSet</code> to avoid adding duplicates. </li>
<li>We also need to know how often to check the candidate set and update our leader. Since this time needs to be able to dynamically adjust to network conditions, we keep two values for this in our state: The current <code>period</code> and a <code>delta</code> value, which we use when we need to adjust the period. The <code>delta</code> is technically immutable and could be a constant, but we want to make both values <a href="distributed/../local/configuration.html">configurable</a>, so we need to store the loaded values somewhere.</li>
<li>Finally, we to keep track of the current <a href="distributed/../local/timers.html">timer handle</a> and the current leader, if any.</li>
</ul>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct EventualLeaderElector {
    ctx: ComponentContext&lt;Self&gt;,
    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
    processes: Arc&lt;[ActorPath]&gt;,
    candidates: HashSet&lt;ActorPath&gt;,
    period: Duration,
    delta: Duration,
    timer_handle: Option&lt;ScheduledTimer&gt;,
    leader: Option&lt;ActorPath&gt;,
}
<span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; () {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = UpdateProcesses;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Received new process set with {} processes&quot;,
</span><span class="boring">            msg.0.len()
</span><span class="boring">        );
</span><span class="boring">        let UpdateProcesses(processes) = msg;
</span><span class="boring">        self.processes = processes;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
</span><span class="boring">            Ok(_heartbeat) =&gt; {
</span><span class="boring">                self.candidates.insert(sender);
</span><span class="boring">            }
</span><span class="boring">            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        2,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of systems.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_systems(num_systems);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_systems(num_systems: usize) {
</span><span class="boring">    let mut systems: Vec&lt;KompactSystem&gt; = {
</span><span class="boring">        let system = || {
</span><span class="boring">            let mut cfg = KompactConfig::default();
</span><span class="boring">            cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">            cfg.build().expect(&quot;KompactSystem&quot;)
</span><span class="boring">        };
</span><span class="boring">        let mut data = Vec::with_capacity(num_systems);
</span><span class="boring">        for _i in 0..num_systems {
</span><span class="boring">            let sys = system();
</span><span class="boring">            data.push(sys);
</span><span class="boring">        }
</span><span class="boring">        data
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|sys| {
</span><span class="boring">            let printer = sys.create(TrustPrinter::new);
</span><span class="boring">            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
</span><span class="boring">            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
</span><span class="boring">                .expect(&quot;connection&quot;);
</span><span class="boring">            let path =
</span><span class="boring">                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
</span><span class="boring">            sys.start(&amp;printer);
</span><span class="boring">            sys.start(&amp;detector);
</span><span class="boring">            (path, detector.actor_ref())
</span><span class="boring">        })
</span><span class="boring">        .unzip();
</span><span class="boring">
</span><span class="boring">    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();
</span><span class="boring">
</span><span class="boring">    actors.iter().for_each(|actor| {
</span><span class="boring">        let update = UpdateProcesses(shared_processes.clone());
</span><span class="boring">        actor.tell(update);
</span><span class="boring">    });
</span><span class="boring">    // let them settle
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    // shut down systems one by one
</span><span class="boring">    for sys in systems.drain(..) {
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In order to load our configuration values from a file, we need to put something like the following into an <code>application.conf</code> file in the current working directory:</p>
<pre><code class="language-hocon">omega {
	initial-period = 10 ms
	delta = 1 ms
}
</code></pre>
<p>And then we can load it and start the initial timeout in the <code>on_start</code> handler as before:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    processes: Arc&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; () {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for EventualLeaderElector {
    fn on_start(&amp;mut self) -&gt; Handled {
        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
            .as_duration()
            .expect(&quot;initial period&quot;);
        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
            .as_duration()
            .expect(&quot;delta&quot;);
        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
        self.timer_handle = Some(timeout);
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.timer_handle.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = UpdateProcesses;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Received new process set with {} processes&quot;,
</span><span class="boring">            msg.0.len()
</span><span class="boring">        );
</span><span class="boring">        let UpdateProcesses(processes) = msg;
</span><span class="boring">        self.processes = processes;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
</span><span class="boring">            Ok(_heartbeat) =&gt; {
</span><span class="boring">                self.candidates.insert(sender);
</span><span class="boring">            }
</span><span class="boring">            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        2,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of systems.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_systems(num_systems);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_systems(num_systems: usize) {
</span><span class="boring">    let mut systems: Vec&lt;KompactSystem&gt; = {
</span><span class="boring">        let system = || {
</span><span class="boring">            let mut cfg = KompactConfig::default();
</span><span class="boring">            cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">            cfg.build().expect(&quot;KompactSystem&quot;)
</span><span class="boring">        };
</span><span class="boring">        let mut data = Vec::with_capacity(num_systems);
</span><span class="boring">        for _i in 0..num_systems {
</span><span class="boring">            let sys = system();
</span><span class="boring">            data.push(sys);
</span><span class="boring">        }
</span><span class="boring">        data
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|sys| {
</span><span class="boring">            let printer = sys.create(TrustPrinter::new);
</span><span class="boring">            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
</span><span class="boring">            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
</span><span class="boring">                .expect(&quot;connection&quot;);
</span><span class="boring">            let path =
</span><span class="boring">                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
</span><span class="boring">            sys.start(&amp;printer);
</span><span class="boring">            sys.start(&amp;detector);
</span><span class="boring">            (path, detector.actor_ref())
</span><span class="boring">        })
</span><span class="boring">        .unzip();
</span><span class="boring">
</span><span class="boring">    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();
</span><span class="boring">
</span><span class="boring">    actors.iter().for_each(|actor| {
</span><span class="boring">        let update = UpdateProcesses(shared_processes.clone());
</span><span class="boring">        actor.tell(update);
</span><span class="boring">    });
</span><span class="boring">    // let them settle
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    // shut down systems one by one
</span><span class="boring">    for sys in systems.drain(..) {
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="leader-election-algorithm"><a class="header" href="#leader-election-algorithm">Leader Election Algorithm</a></h3>
<p>This part isn’t very specific to networking, but basically the election algorithm works as follows: Every time the timeout fires we clear out the current candidate set into a temporary vector. We then sort the vector and take the last element, if any, as the potential new leader. If that new leader is not the same as the current one then either our current leader has failed, or the timeout is wrong. For simplicity we will assume both is true and replace the leader and update the scheduled timeout by adding the <code>delta</code> to the current <code>period</code>. We then announce our new leader choice via a trigger on the <code>EventualLeaderDetection</code> port. Whether or not we replaced the leader, we always send heartbeats to everyone in the process set.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    processes: Arc&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
        candidates.sort_unstable();
        candidates.reverse(); // pick smallest instead of largest
        candidates.pop()
    }

    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
        match self.timer_handle.take() {
            Some(timeout) if timeout == timeout_id =&gt; {
                let new_leader = self.select_leader();
                if new_leader != self.leader {
                    self.period += self.delta;
                    self.leader = new_leader;
                    if let Some(ref leader) = self.leader {
                        self.omega_port.trigger(Trust(leader.clone()));
                    }
                    self.cancel_timer(timeout);
                    let new_timer =
                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
                    self.timer_handle = Some(new_timer);
                } else {
                    // just put it back
                    self.timer_handle = Some(timeout);
                }
                self.send_heartbeats();
                Handled::Ok
            }
            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
            None =&gt; {
                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
                Handled::Ok
            } // can happen during restart or teardown
        }
    }

<span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; () {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = UpdateProcesses;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Received new process set with {} processes&quot;,
</span><span class="boring">            msg.0.len()
</span><span class="boring">        );
</span><span class="boring">        let UpdateProcesses(processes) = msg;
</span><span class="boring">        self.processes = processes;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
</span><span class="boring">            Ok(_heartbeat) =&gt; {
</span><span class="boring">                self.candidates.insert(sender);
</span><span class="boring">            }
</span><span class="boring">            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        2,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of systems.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_systems(num_systems);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_systems(num_systems: usize) {
</span><span class="boring">    let mut systems: Vec&lt;KompactSystem&gt; = {
</span><span class="boring">        let system = || {
</span><span class="boring">            let mut cfg = KompactConfig::default();
</span><span class="boring">            cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">            cfg.build().expect(&quot;KompactSystem&quot;)
</span><span class="boring">        };
</span><span class="boring">        let mut data = Vec::with_capacity(num_systems);
</span><span class="boring">        for _i in 0..num_systems {
</span><span class="boring">            let sys = system();
</span><span class="boring">            data.push(sys);
</span><span class="boring">        }
</span><span class="boring">        data
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|sys| {
</span><span class="boring">            let printer = sys.create(TrustPrinter::new);
</span><span class="boring">            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
</span><span class="boring">            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
</span><span class="boring">                .expect(&quot;connection&quot;);
</span><span class="boring">            let path =
</span><span class="boring">                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
</span><span class="boring">            sys.start(&amp;printer);
</span><span class="boring">            sys.start(&amp;detector);
</span><span class="boring">            (path, detector.actor_ref())
</span><span class="boring">        })
</span><span class="boring">        .unzip();
</span><span class="boring">
</span><span class="boring">    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();
</span><span class="boring">
</span><span class="boring">    actors.iter().for_each(|actor| {
</span><span class="boring">        let update = UpdateProcesses(shared_processes.clone());
</span><span class="boring">        actor.tell(update);
</span><span class="boring">    });
</span><span class="boring">    // let them settle
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    // shut down systems one by one
</span><span class="boring">    for sys in systems.drain(..) {
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="sending-network-messages"><a class="header" href="#sending-network-messages">Sending Network Messages</a></h3>
<p>The only place in this example where we are sending remote messages is when we are sending heartbeats:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    processes: Arc&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span>    fn send_heartbeats(&amp;self) -&gt; () {
        self.processes.iter().for_each(|process| {
            process.tell((Heartbeat, Serde), self);
        });
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = UpdateProcesses;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Received new process set with {} processes&quot;,
</span><span class="boring">            msg.0.len()
</span><span class="boring">        );
</span><span class="boring">        let UpdateProcesses(processes) = msg;
</span><span class="boring">        self.processes = processes;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
</span><span class="boring">            Ok(_heartbeat) =&gt; {
</span><span class="boring">                self.candidates.insert(sender);
</span><span class="boring">            }
</span><span class="boring">            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        2,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of systems.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_systems(num_systems);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_systems(num_systems: usize) {
</span><span class="boring">    let mut systems: Vec&lt;KompactSystem&gt; = {
</span><span class="boring">        let system = || {
</span><span class="boring">            let mut cfg = KompactConfig::default();
</span><span class="boring">            cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">            cfg.build().expect(&quot;KompactSystem&quot;)
</span><span class="boring">        };
</span><span class="boring">        let mut data = Vec::with_capacity(num_systems);
</span><span class="boring">        for _i in 0..num_systems {
</span><span class="boring">            let sys = system();
</span><span class="boring">            data.push(sys);
</span><span class="boring">        }
</span><span class="boring">        data
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|sys| {
</span><span class="boring">            let printer = sys.create(TrustPrinter::new);
</span><span class="boring">            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
</span><span class="boring">            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
</span><span class="boring">                .expect(&quot;connection&quot;);
</span><span class="boring">            let path =
</span><span class="boring">                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
</span><span class="boring">            sys.start(&amp;printer);
</span><span class="boring">            sys.start(&amp;detector);
</span><span class="boring">            (path, detector.actor_ref())
</span><span class="boring">        })
</span><span class="boring">        .unzip();
</span><span class="boring">
</span><span class="boring">    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();
</span><span class="boring">
</span><span class="boring">    actors.iter().for_each(|actor| {
</span><span class="boring">        let update = UpdateProcesses(shared_processes.clone());
</span><span class="boring">        actor.tell(update);
</span><span class="boring">    });
</span><span class="boring">    // let them settle
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    // shut down systems one by one
</span><span class="boring">    for sys in systems.drain(..) {
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We invoke the <code>ActorPath::tell(...)</code> method with a tuple of the actual <code>Heartbeat</code> together with the serialiser with want to use, which is <code>kompact::serde_serialisers::Serde</code>. We also pass a reference to <code>self</code> which will automatically insert our unique actor path into the message as the source and send everything to our system’s dispatcher, which will take care of serialisation, as well as network channel creation and selection for us.</p>
<h3 id="handling-network-messages"><a class="header" href="#handling-network-messages">Handling Network Messages</a></h3>
<p>In order to handle (network) messages we must implement the Actor trait as described <a href="distributed/../local/communication/messagesandevents.html">previously</a>. The local message type we are handling is <code>UpdateProcesses</code> and whenever we get it, we simply replace our current <code>processes</code> with the new value.</p>
<p>For network messages, on the other hand, we don’t know what are being given, generally, so we get <code>NetworkMessage</code>. This is basically a wrapper around a sender <code>ActorPath</code>, a serialisation id, and a byte buffer with the serialised data. In our example, we know we only want to handle messages that deserialise to <code>Heartbeat</code>. We also know we need to use <code>Serde</code> as a deserialiser, since that’s what we used for serialisation in the first place. Thus, we use <code>NetMessage::try_deserialise::&lt;Heartbeat, Serde&gt;()</code> to attempt to deserialise a <code>Heartbeat</code> from the buffer using the <code>Serde</code> deserialiser. This call will automatically check if the serialisation id matches <code>Heartbeat::SER_ID</code> and if yes, attempt to deserialise it using <code>Serde</code>. If it doesn’t work, we’ll get a <code>Result::Err</code> instead. If it does work, however, we don’t actually care about the Hearbeat itself, but we insert the sender from the <code>NetMessage</code> into <code>self.candidates</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    processes: Arc&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; () {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span>impl Actor for EventualLeaderElector {
    type Message = UpdateProcesses;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        info!(
            self.log(),
            &quot;Received new process set with {} processes&quot;,
            msg.0.len()
        );
        let UpdateProcesses(processes) = msg;
        self.processes = processes;
        Handled::Ok
    }

    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
        let sender = msg.sender;
        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
            Ok(_heartbeat) =&gt; {
                self.candidates.insert(sender);
            }
            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
        }
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        2,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of systems.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_systems(num_systems);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_systems(num_systems: usize) {
</span><span class="boring">    let mut systems: Vec&lt;KompactSystem&gt; = {
</span><span class="boring">        let system = || {
</span><span class="boring">            let mut cfg = KompactConfig::default();
</span><span class="boring">            cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">            cfg.build().expect(&quot;KompactSystem&quot;)
</span><span class="boring">        };
</span><span class="boring">        let mut data = Vec::with_capacity(num_systems);
</span><span class="boring">        for _i in 0..num_systems {
</span><span class="boring">            let sys = system();
</span><span class="boring">            data.push(sys);
</span><span class="boring">        }
</span><span class="boring">        data
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|sys| {
</span><span class="boring">            let printer = sys.create(TrustPrinter::new);
</span><span class="boring">            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
</span><span class="boring">            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
</span><span class="boring">                .expect(&quot;connection&quot;);
</span><span class="boring">            let path =
</span><span class="boring">                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
</span><span class="boring">            sys.start(&amp;printer);
</span><span class="boring">            sys.start(&amp;detector);
</span><span class="boring">            (path, detector.actor_ref())
</span><span class="boring">        })
</span><span class="boring">        .unzip();
</span><span class="boring">
</span><span class="boring">    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();
</span><span class="boring">
</span><span class="boring">    actors.iter().for_each(|actor| {
</span><span class="boring">        let update = UpdateProcesses(shared_processes.clone());
</span><span class="boring">        actor.tell(update);
</span><span class="boring">    });
</span><span class="boring">    // let them settle
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    // shut down systems one by one
</span><span class="boring">    for sys in systems.drain(..) {
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="system-setup"><a class="header" href="#system-setup">System Setup</a></h3>
<p>In this example we need to set up multiple systems in the same process for the first time, since we want them to communicate via the network instead of directly, as a preparation for actually running distributed. We are going to take the number of systems (and thus leader election components) as a command line argument. We start each system with the same configuration file and give them each a <code>NetworkDispatcher</code> with default settings. This way we don’t have to manually pick a bunch of ports and hope they happen to be free. On the other hand that means, of course, that we can’t predict what system addresses are going to look like. So in order to give everyone a set of processes to talk to, we need to wait until all systems are set up and all the leader elector components started and registered, collect all the registrations into a vector and then send an update to every component with the complete set.</p>
<p>At this point the system is running just fine and we give it some time to settle on timeouts and elect a leader. We will see the result in the logging messages eventually. Now to see the leader election responding to actual changes, we are going to kill one system at a time and always give it a second to settle. This way we can watch the elector on the remaining systems updating the trust values one by one.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{collections::HashSet, sync::Arc, time::Duration};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct UpdateProcesses(Arc&lt;[ActorPath]&gt;);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    processes: Arc&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            processes: Vec::new().into_boxed_slice().into(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; () {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = UpdateProcesses;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Received new process set with {} processes&quot;,
</span><span class="boring">            msg.0.len()
</span><span class="boring">        );
</span><span class="boring">        let UpdateProcesses(processes) = msg;
</span><span class="boring">        self.processes = processes;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">        match msg.data.try_deserialise::&lt;Heartbeat, Serde&gt;() {
</span><span class="boring">            Ok(_heartbeat) =&gt; {
</span><span class="boring">                self.candidates.insert(sender);
</span><span class="boring">            }
</span><span class="boring">            Err(e) =&gt; warn!(self.log(), &quot;Invalid data: {:?}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    assert_eq!(
        2,
        args.len(),
        &quot;Invalid arguments! Must give number of systems.&quot;
    );
    let num_systems: usize = args[1].parse().expect(&quot;number&quot;);
    run_systems(num_systems);
}

pub fn run_systems(num_systems: usize) {
    let mut systems: Vec&lt;KompactSystem&gt; = {
        let system = || {
            let mut cfg = KompactConfig::default();
            cfg.load_config_file(&quot;./application.conf&quot;);
            cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
            cfg.build().expect(&quot;KompactSystem&quot;)
        };
        let mut data = Vec::with_capacity(num_systems);
        for _i in 0..num_systems {
            let sys = system();
            data.push(sys);
        }
        data
    };

    let (processes, actors): (Vec&lt;ActorPath&gt;, Vec&lt;ActorRef&lt;UpdateProcesses&gt;&gt;) = systems
        .iter()
        .map(|sys| {
            let printer = sys.create(TrustPrinter::new);
            let (detector, registration) = sys.create_and_register(EventualLeaderElector::new);
            biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer)
                .expect(&quot;connection&quot;);
            let path =
                registration.wait_expect(Duration::from_millis(1000), &quot;actor never registered&quot;);
            sys.start(&amp;printer);
            sys.start(&amp;detector);
            (path, detector.actor_ref())
        })
        .unzip();

    let shared_processes: Arc&lt;[ActorPath]&gt; = processes.into_boxed_slice().into();

    actors.iter().for_each(|actor| {
        let update = UpdateProcesses(shared_processes.clone());
        actor.tell(update);
    });
    // let them settle
    std::thread::sleep(Duration::from_millis(1000));
    // shut down systems one by one
    for sys in systems.drain(..) {
        std::thread::sleep(Duration::from_millis(1000));
        sys.shutdown().expect(&quot;shutdown&quot;);
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_omega() {
</span><span class="boring">        run_systems(3);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin leader_election 3
</code></pre>
<p>Note that running in debug mode will produce a lot of output now as it will trace all the network messages.</p>
</blockquote>
<h1 id="named-services"><a class="header" href="#named-services">Named Services</a></h1>
<p>In the last section we discussed how to build a leader election mechanism with a bunch of networked Kompact systems. But we couldn’t actually run it in deployment, because we couldn’t really figure out how to collect a list of actor paths for all the processes and then distribute that list to every process. This happens because we can only know the actor path of an actor <em>after</em> we have created it. We could have manually distributed the actor paths, by writing the assigned path to a file, then collecting it externally, and finally parsing paths from said collected file and passing them to each elector component. But that wouldn’t be a very nice system now, would it? </p>
<p>What we are missing here is a way to predict an <code>ActorPath</code> for a particular actor on a particular system. If we can know even a single path on a single host in the distributed actor system, we can have everyone send a message there, which will give that special component the unique paths for everyone that sends there, which it can in turn distribute back to everyone who has “checked in” in this manner. This process is often referred to as “bootstrapping”. In this section we are going to use named actor paths, which we can predict given some information about the system, to build a bootstrapping “service” for our leader election group.</p>
<h2 id="messages-3"><a class="header" href="#messages-3">Messages</a></h2>
<p>For the bootstrapping communication we require a new <code>CheckIn</code> message. It doesn’t actually need any content, since we really only care about the <code>ActorPath</code> of the sender. We will reply to this message with our <code>UpdateProcesses</code> message from the previous section. However, since that has to go over the network now, we need to make it serialisable. We also aren’t locally sharing the process set anymore, so we turn the <code>Arc&lt;[ActorPath]&gt;</code> into a simple <code>Vec&lt;ActorPath&gt;</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
struct CheckIn;
impl SerialisationId for CheckIn {
    const SER_ID: SerId = 2345;
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct UpdateProcesses(Vec&lt;ActorPath&gt;);
impl SerialisationId for UpdateProcesses {
    const SER_ID: SerId = 3456;
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="state-3"><a class="header" href="#state-3">State</a></h2>
<p>Our bootstrap server’s state is almost trivial. All it needs to keep track of is the current process set.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct BootstrapServer {
    ctx: ComponentContext&lt;Self&gt;,
    processes: HashSet&lt;ActorPath&gt;,
}
impl BootstrapServer {
    fn new() -&gt; Self {
        BootstrapServer {
            ctx: ComponentContext::uninitialised(),
            processes: HashSet::new(),
        }
    }

<span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also need to alter our leader elector a bit. First it needs to know the actor path of the bootstrap server, so it can actually check in. And second, we need to adapt the type of <code>processes</code> to be in line with our changes to <code>UpdateProcesses</code>. We’ll make it a <code>Box&lt;[ActorPath]&gt;</code> instead of <code>Arc&lt;[ActorPath]&gt;</code> and do the conversion from <code>Vec&lt;ActorPath&gt;</code> whenever we receive an update.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct EventualLeaderElector {
    ctx: ComponentContext&lt;Self&gt;,
    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
    bootstrap_server: ActorPath,
    processes: Box&lt;[ActorPath]&gt;,
    candidates: HashSet&lt;ActorPath&gt;,
    period: Duration,
    delta: Duration,
    timer_handle: Option&lt;ScheduledTimer&gt;,
    leader: Option&lt;ActorPath&gt;,
}
impl EventualLeaderElector {
    fn new(bootstrap_server: ActorPath) -&gt; Self {
        let minimal_period = Duration::from_millis(1);
        EventualLeaderElector {
            ctx: ComponentContext::uninitialised(),
            omega_port: ProvidedPort::uninitialised(),
            bootstrap_server,
            processes: Vec::new().into_boxed_slice(),
            candidates: HashSet::new(),
            period: minimal_period,
            delta: minimal_period,
            timer_handle: None,
            leader: None,
        }
    }

<span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="behaviours"><a class="header" href="#behaviours">Behaviours</a></h2>
<p>The behaviour of the bootstrap server is very simple. Whenever it gets a <code>CheckIn</code>, it adds the source of the message to its process set and then broadcasts the new process set to every process in the set. We will use the <code>NetworkActor</code> trait to implement the actor part here instead of <code>Actor</code>. <code>NetworkActor</code> is a convenience trait for actors that handle the same set of messages locally and remotely and ignore all other remote messages. It handles the deserialisation part for us, but we must tell it both the <code>Message</code> type and the <code>Deserialiser</code> type to use. Of course, in this case we don’t actually do anything for local messages, since we only need the sender and local messages simply don’t have a sender attached.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span>    fn broadcast_processess(&amp;self) -&gt; () {
        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
        let msg = UpdateProcesses(procs);
        self.processes.iter().for_each(|process| {
            process.tell((msg.clone(), Serde), self);
        });
    }
}
ignore_lifecycle!(BootstrapServer);
impl NetworkActor for BootstrapServer {
    type Deserialiser = Serde;
    type Message = CheckIn;

    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
        if let Some(process) = source {
            if self.processes.insert(process) {
                self.broadcast_processess();
            }
        }
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We must also make some small changes to the behaviour of the leader elector itself. First of all we must now send the <code>CheckIn</code> when we are being started. As before we are using <code>Serde</code> as a serialisation mechanism, so we really only have to add the following line to the <code>on_start</code> function:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span>        self.bootstrap_server.tell((CheckIn, Serde), self);
<span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also have to change how we handle <code>UpdateProcesses</code> slightly, since they are now coming in over the network. We thus have to move the code from <code>receive_local</code> to <code>receive_network</code>. But now we have two different possible network messages we could deserialise whenever we get a <code>NetMessage</code>: It could either be a <code>Heartbeat</code> or an <code>UpdateProcesses</code>. Since trying through them individually one by one is somewhat inefficient, what we really want is something like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">match msg.ser_id() {
	Heartbeat::SER_ID =&gt; // deserialise and handle Heartbeat
	UpdateProcesses::SER_ID =&gt; // deserialise and handle UpdateProcesses
}
</code></pre>
<p>Kompact provides the <code>match_deser!</code> macro to generate code like the above, since this is very common behaviour and writing it manually gets somewhat tedious eventually. The overall syntax for the macro is:</p>
<pre><code>match_deser! {
	(&lt;message expression&gt;) {
		&lt;message case 1&gt;,
		&lt;message case 2&gt;,
		...
	}
}
</code></pre>
<p>Here <code>&lt;message expression&gt;</code> is an expression that gives the message (data) to be deserialised. If the expression is simply an identifier like <code>msg</code> then the parenthesis may be elided.
The syntax for each different message case in the macro is basically:</p>
<pre><code>msg(variable_name): MessageType [using DeserialiserType] =&gt; &lt;body&gt;
</code></pre>
<p>For cases where <code>MessageType = DeserialiserType</code> the <code>[using DeserialiserType]</code> block can be elided. There are also default and error branches available for the macro, an example of which can be see in the <a href="https://docs.rs/kompact/latest/kompact/macro.match_deser.html">API docs</a>. It is also possible to immediately destructure the deserialised message by replacing <code>variable_name</code> with a pattern, as can be seen in the case of <code>UpdateProcesses</code> below.</p>
<p>Using this macro, our new actor implementation becomes the following:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span>impl Actor for EventualLeaderElector {
    type Message = Never;

    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
        unreachable!();
    }

    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
        let sender = msg.sender;

        match_deser! {
            (msg.data) {
                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
                    self.candidates.insert(sender);
                },
                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
                    info!(
                        self.log(),
                        &quot;Received new process set with {} processes&quot;,
                        processes.len()
                    );
                    self.processes = processes.into_boxed_slice();
                },
            }
        };
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="system-1"><a class="header" href="#system-1">System</a></h2>
<p>Now the real difference happens in the way we set up the Kompact systems. In the last section we set up a configurable number of systems that were all the same in the same process. Now we are only going to run a single system per process and we have two different setups as well: Most processes will be “clients” and only run the leader elector and the trust printer, but one process will additionally run the <code>BootstrapServer</code>.</p>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<p>The one thing that sets our bootstrap server creation apart from any other actor we have created so far, is that we want a <em>named actor path</em> for it. Basically, we want any other process to be able to constuct a valid <code>ActorPath</code> instance for the bootstrap server, such as <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap</code> , given only the port for it. In order to make Kompact resolve that path to the correct component we must do two things:</p>
<ol>
<li>Make sure that the Kompact system actually runs on localhost at the given port, and</li>
<li>register a named path alias for the <code>BootstrapServer</code> with the name <code>&quot;bootstrap&quot;</code>.</li>
</ol>
<p>To achieve the first part, we create the <code>NetworkDispatcher</code> from a <code>SocketAddr</code> instance that contains the correct IP and port instead of using the default value as we did before. To register a component with a named path, we must call <code>KompactSystem::register_by_alias(...)</code> with the target component and the path to register. The rest is more or less as before.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;

pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
    let mut cfg = KompactConfig::default();
    cfg.load_config_file(&quot;./application.conf&quot;);
    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());

    let system = cfg.build().expect(&quot;KompactSystem&quot;);

    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);

    let _bootstrap_unique = bootstrap_registration
        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
    let bootstrap_service = bootstrap_service_registration
        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
    system.start(&amp;bootstrap);

    let printer = system.create(TrustPrinter::new);
    let (detector, registration) =
        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
    system.start(&amp;printer);
    system.start(&amp;detector);

    system
}
<span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<p>The client setup works almost the same as in the previous section, except that we need to construct the required <code>ActorPath</code> instance for the bootstrap server given its <code>SocketAddr</code> now. We can do so using <code>NamedPath::with_socket(...)</code> which will construct a <code>NamedPath</code> instance that can easily be converted into an <code>ActorPath</code>. We pass this instance to the leader elector component during construction.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
    let mut cfg = KompactConfig::default();
    cfg.load_config_file(&quot;./application.conf&quot;);
    cfg.system_components(
        DeadletterBox::new,
        NetworkConfig::new(client_socket).build(),
    );

    let system = cfg.build().expect(&quot;KompactSystem&quot;);

    let bootstrap_service: ActorPath = NamedPath::with_socket(
        Transport::Tcp,
        bootstrap_socket,
        vec![BOOTSTRAP_PATH.into()],
    )
    .into();

    let printer = system.create(TrustPrinter::new);
    let (detector, registration) =
        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
    system.start(&amp;printer);
    system.start(&amp;detector);

    system
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="running-with-commandline-arguments"><a class="header" href="#running-with-commandline-arguments">Running with Commandline Arguments</a></h3>
<p>All that is left to do is to convert the port numbers given on the command line to the required <code>SocketAddr</code> instances and calling the correct method. When we are given 1 argument (port number) we will start a bootstrap server, and if we are given 2 arguments (server port and client port) we will start a client instead.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">impl SerialisationId for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; () {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((msg.clone(), Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = Serde;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer =
</span><span class="boring">                        self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, Serde), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(self.period, self.period, Self::handle_timeout);
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(UpdateProcesses(processes)): UpdateProcesses [using Serde] =&gt; {
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    match args.len() {
        2 =&gt; {
            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
            let system = run_server(bootstrap_socket);
            system.await_termination(); // gotta quit it from command line
        }
        3 =&gt; {
            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
            let system = run_client(bootstrap_socket, client_socket);
            system.await_termination(); // gotta quit it from command line
        }
        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x-1),
    }
}
<span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now we can run this by first starting a server in one shell and then a few clients in a few other shells. We can also see changes in trust events as we kill and add processes.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can build a binary with:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>You can run the bootstrap server on port 12345 with:</p>
<pre><code class="language-bash">../../target/release/bootstrapping 12345
</code></pre>
<p>Similarly, you can run a matching client on some free port with:</p>
<pre><code class="language-bash">../../target/release/bootstrapping 12345 0
</code></pre>
</blockquote>
<h1 id="path-routing"><a class="header" href="#path-routing">Path Routing</a></h1>
<p>In the previous section on <a href="distributed/namedservices.html">Named Services</a> we have seen that we can register components to named paths, such as <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap</code>. These paths look very much like a <a href="https://en.wikipedia.org/wiki/URL">URL</a>, and indeed, just like in REST APIs, Kompact named paths form a tree-like hierarchy. For example <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap/server1</code> would be a sub-path of <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap</code>. This hierarchy is reflected in the way Kompact stores these actor aliases internally, which from a structure like a directory tree.</p>
<p>This approach to named paths opens up the possibility of exploiting the hierarchy for implicit and explicit <em>routing</em> of messages over sub-trees (directories, in a sense), which we explore in this section.</p>
<h2 id="routing-policies"><a class="header" href="#routing-policies">Routing Policies</a></h2>
<p>In general, a routing policy is something that takes a message and set of references and selects one or more references that the message will be sent to. In the concrete case of routing within the named path tree, the type of the message must be <code>NetMessage</code> and the references are <code>DynActorRef</code>. The  set of references we give to a policy is going to be the set of all registered nodes under a particular prefix in the named actor tree, which we will call the <em>routing path</em>. </p>
<blockquote>
<p><strong>Example:</strong> If <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap</code> is a routing path with some policy P, then whenever we send something to it, we will pass the set containing the actor ref registered at <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap/server1</code> to P. If there were another registration at <code>tcp://127.0.0.1:&lt;port&gt;/bootstrap/servers/server1</code> we would add that to the set as well.</p>
</blockquote>
<h3 id="types-of-routing-paths"><a class="header" href="#types-of-routing-paths">Types of Routing Paths</a></h3>
<p>Kompact supports two different types of routing paths: <strong>explicit</strong> paths and <strong>implicit</strong> paths.</p>
<p>In order to explain this in the following paragraphs, consider a system where the following three actors are registered:</p>
<ol>
<li><code>tcp::127.0.0.1:1234/parent/child1</code></li>
<li><code>tcp::127.0.0.1:1234/parent/child2</code></li>
<li><code>tcp::127.0.0.1:1234/parent/child1/grandchild</code></li>
</ol>
<h4 id="implicit-routing"><a class="header" href="#implicit-routing">Implicit Routing</a></h4>
<p>Routing in Kompact can be used without any (routing specific) setup at all. If we simply construct an <code>ActorPath</code> of the form <code>tcp::127.0.0.1:1234/parent/*</code> and send a message there, Kompact will automatically broadcast this message to all three nodes registered above, since all of them have <code>tcp::127.0.0.1:1234/parent</code> as their prefix. This kind of implicit routing path is called a <strong>broadcast path</strong>. The other type of implicit routing supported by Kompact is called a <strong>select path</strong> and takes the form <code>tcp::127.0.0.1:1234/parent/?</code>. Sending a message to this select path will cause the message to be sent to exactly one of the actors. Which node exactly is subject to the routing policy at <code>tcp::127.0.0.1:1234/parent</code>, which is not guaranteed to be stable by the runtime. The current default policy for select is based on hash buckets over the messages sender field.</p>
<blockquote>
<p><strong>Warning:</strong> In certain deployments allowing implicit routing can become a security risk with respect to <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">DoS attacks</a>, since an attacker can basically force the system to broadcast a message to every registered node, which can cause a lot unnecessary load.</p>
<p>If this is a concern for your deployment scenario, you can compile Kompact without default features, which will remove implicit routing completely.</p>
</blockquote>
<h4 id="explicit-routing"><a class="header" href="#explicit-routing">Explicit Routing</a></h4>
<p>If implicit routing is not a good match for your use case, Kompact allows you explicitly set a policy at a particular point in the named tree via the <code>KompactSystem::set_routing_policy(...)</code> method. Not only does this allow you to customise the behaviour of routing for a particular sub-tree, it also enables you to hide the fact that a tree is routing at all, as with an explicit policy both <code>tcp::127.0.0.1:1234/parent</code> (where the routing policy is set) and one of <code>tcp::127.0.0.1:1234/parent/*</code> and <code>tcp::127.0.0.1:1234/parent/?</code> (depending on whether your police is of broadcast or select type) will exhibit the same behaviour.</p>
<p>Explicit routing works even if implicit routing is disabled.</p>
<h3 id="provided-policies"><a class="header" href="#provided-policies">Provided Policies</a></h3>
<p>Kompact comes with three routing policies built in:</p>
<ol>
<li><code>kompact::routing::groups::BroadcastRouting</code> is the default policy for broadcast paths. As the name implies, it will simply send a copy of each message to every member of the routing set. In order to improve the efficiency of broadcasting, you may want to override the default implementation of <code>Serialisable::cloned()</code> for the types you are broadcasting, at least when you know that local delivery can happen.</li>
<li><code>kompact::routing::groups::SenderDefaultHashBucketRouting</code> is the default policy for select paths. It will use the hash of the messages sender field to determine a member to send the message to. Changing the member set in any way will thus also change the assignments. <code>SenderDefaultHashBucketRouting</code> is actually just a type alias for a more customisable hash-based routing policy called <code>kompact::routing::groups::FieldHashBucketRouting</code>, which lets you decide the field(s) to use for hashing and the actual hashing algorithm.</li>
<li><code>kompact::routing::groups::RoundRobinRouting</code> uses a mutable index (an <code>AtomicUsize</code> to be exact) to select exactly one member in a round-robin manner.</li>
</ol>
<h3 id="custom-policies"><a class="header" href="#custom-policies">Custom Policies</a></h3>
<p>In addition to the already provided routing policies, users can easily implement their own by implementing <code>RoutingPolicy&lt;DynActorRef, NetMessage&gt;</code> for their custom type. It is important to note that policy lookups happen concurrently in the store and hence routing must be implemented with a <code>&amp;self</code> reference instead of <code>&amp;mut self</code>. Thus, routing protocols that must update manage state for each message must rely on atomics or—if really necessary—on mutexes or similar concurrent structures as appropriate for their access pattern.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>To show-case the path routing feature of Kompact, we will sketch a simple client-server application, where the server holds a “database” (just a large slice of strings in our case) and the client sends “queries” against this database. The queries are simply going to be shorter strings, which we will try to find as substrings in the database and return all matching strings. Since our database is actually immutable, we will share it among multiple server components and use <strong>select routing</strong> with the round-robin policy to spread out the load. Since the queries are expensive, we will also cache the results on the clients. To provide an example of broadcast routing we will cache the responses for <em>any</em> client at <em>every</em> client via broadcast. For simplicity, this example is going to be completely local within a single Kompact system, but the mechanisms involved are really designed for remote use primarily, with local paths only an optimisation normally.</p>
<h3 id="messages-4"><a class="header" href="#messages-4">Messages</a></h3>
<p>We only have two messages, the <code>Query</code> with a unique request id and the actual pattern we want to match against, and the <code>QueryResponse</code> which has all the fields of the <code>Query</code> plus a vector of strings that matched the pattern. For convenience, we will use <code>Serde</code> as serialisation mechanism again.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, Debug, Clone)]
struct Query {
    id: Uuid,
    pattern: String,
}
impl SerialisationId for Query {
    const SER_ID: SerId = 4242;
}
#[derive(Serialize, Deserialize, Debug, Clone)]
struct QueryResponse {
    id: Uuid,
    pattern: String,
    matches: Vec&lt;String&gt;,
}
impl SerialisationId for QueryResponse {
    const SER_ID: SerId = 4243;
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span><span class="boring">                self.server_path
</span><span class="boring">                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ENTRY_LENGTH: usize = 20;
</span><span class="boring">const PATTERN_LENGTH: usize = 2;
</span><span class="boring">
</span><span class="boring">const BALANCER_PATH: &amp;str = &quot;server&quot;;
</span><span class="boring">const CLIENT_PATH: &amp;str = &quot;client&quot;;
</span><span class="boring">
</span><span class="boring">const NUM_SERVERS: usize = 3;
</span><span class="boring">const NUM_CLIENTS: usize = 12;
</span><span class="boring">const DATABASE_SIZE: usize = 10000;
</span><span class="boring">
</span><span class="boring">const TIMEOUT: Duration = Duration::from_millis(100);
</span><span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    // use implicit policy
</span><span class="boring">    let broadcast_path: ActorPath = system
</span><span class="boring">        .system_path()
</span><span class="boring">        .into_named_with_string(&quot;client/*&quot;)
</span><span class="boring">        .expect(&quot;path&quot;)
</span><span class="boring">        .into();
</span><span class="boring">
</span><span class="boring">    // set explicit policy
</span><span class="boring">    let balancer_path = system
</span><span class="boring">        .set_routing_policy(
</span><span class="boring">            kompact::routing::groups::RoundRobinRouting::default(),
</span><span class="boring">            BALANCER_PATH,
</span><span class="boring">            false,
</span><span class="boring">        )
</span><span class="boring">        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
</span><span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span><span class="boring">    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let db = database.clone();
</span><span class="boring">            system.create(move || QueryServer::new(db))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, server)| {
</span><span class="boring">            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
</span><span class="boring">
</span><span class="boring">    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let server_path = balancer_path.clone();
</span><span class="boring">            let client_path = broadcast_path.clone();
</span><span class="boring">            system.create(move || Client::new(server_path, client_path))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, client)| {
</span><span class="boring">            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
</span><span class="boring">
</span><span class="boring">    // Start everything
</span><span class="boring">    servers
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|s| system.start_notify(s))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server start&quot;);
</span><span class="boring">    clients
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|c| system.start_notify(c))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client start&quot;);
</span><span class="boring">
</span><span class="boring">    // Let them work for a while
</span><span class="boring">    std::thread::sleep(Duration::from_secs(5));
</span><span class="boring">
</span><span class="boring">    // Shut down clients nicely.
</span><span class="boring">    clients
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|c| system.kill_notify(c))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client kill&quot;);
</span><span class="boring">
</span><span class="boring">    // Shut down servers nicely.
</span><span class="boring">    servers
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|s| system.kill_notify(s))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server kill&quot;);
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="state-and-behaviour"><a class="header" href="#state-and-behaviour">State and Behaviour</a></h3>
<p>As for this example the exact implementation of the servers and clients is not really crucial, we won’t describe it in detail here. The important things to note are that the <code>Client</code> uses the path <code>server_path</code> field to send requests, which we will initialise later with a select path of the form <code>tcp://127.0.0.1:&lt;port&gt;/server/?</code>. It also replaces its unique response path with a <code>broadcast_path</code>, which we will initialise later with a broadcast path of the form <code>tcp://127.0.0.1:&lt;port&gt;/client/*</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Query {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for Query {
</span><span class="boring">    const SER_ID: SerId = 4242;
</span><span class="boring">}
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct QueryResponse {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">    matches: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for QueryResponse {
</span><span class="boring">    const SER_ID: SerId = 4243;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span>                self.server_path
                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
<span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ENTRY_LENGTH: usize = 20;
</span><span class="boring">const PATTERN_LENGTH: usize = 2;
</span><span class="boring">
</span><span class="boring">const BALANCER_PATH: &amp;str = &quot;server&quot;;
</span><span class="boring">const CLIENT_PATH: &amp;str = &quot;client&quot;;
</span><span class="boring">
</span><span class="boring">const NUM_SERVERS: usize = 3;
</span><span class="boring">const NUM_CLIENTS: usize = 12;
</span><span class="boring">const DATABASE_SIZE: usize = 10000;
</span><span class="boring">
</span><span class="boring">const TIMEOUT: Duration = Duration::from_millis(100);
</span><span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    // use implicit policy
</span><span class="boring">    let broadcast_path: ActorPath = system
</span><span class="boring">        .system_path()
</span><span class="boring">        .into_named_with_string(&quot;client/*&quot;)
</span><span class="boring">        .expect(&quot;path&quot;)
</span><span class="boring">        .into();
</span><span class="boring">
</span><span class="boring">    // set explicit policy
</span><span class="boring">    let balancer_path = system
</span><span class="boring">        .set_routing_policy(
</span><span class="boring">            kompact::routing::groups::RoundRobinRouting::default(),
</span><span class="boring">            BALANCER_PATH,
</span><span class="boring">            false,
</span><span class="boring">        )
</span><span class="boring">        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
</span><span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span><span class="boring">    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let db = database.clone();
</span><span class="boring">            system.create(move || QueryServer::new(db))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, server)| {
</span><span class="boring">            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
</span><span class="boring">
</span><span class="boring">    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let server_path = balancer_path.clone();
</span><span class="boring">            let client_path = broadcast_path.clone();
</span><span class="boring">            system.create(move || Client::new(server_path, client_path))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, client)| {
</span><span class="boring">            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
</span><span class="boring">
</span><span class="boring">    // Start everything
</span><span class="boring">    servers
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|s| system.start_notify(s))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server start&quot;);
</span><span class="boring">    clients
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|c| system.start_notify(c))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client start&quot;);
</span><span class="boring">
</span><span class="boring">    // Let them work for a while
</span><span class="boring">    std::thread::sleep(Duration::from_secs(5));
</span><span class="boring">
</span><span class="boring">    // Shut down clients nicely.
</span><span class="boring">    clients
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|c| system.kill_notify(c))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client kill&quot;);
</span><span class="boring">
</span><span class="boring">    // Shut down servers nicely.
</span><span class="boring">    servers
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|s| system.kill_notify(s))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server kill&quot;);
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="system-setup-1"><a class="header" href="#system-setup-1">System Setup</a></h3>
<p>When setting up the Kompact system in the main, we will use the following constants, which essentially represent configuration of our scenario:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Query {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for Query {
</span><span class="boring">    const SER_ID: SerId = 4242;
</span><span class="boring">}
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct QueryResponse {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">    matches: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for QueryResponse {
</span><span class="boring">    const SER_ID: SerId = 4243;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span><span class="boring">                self.server_path
</span><span class="boring">                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>const ENTRY_LENGTH: usize = 20;
const PATTERN_LENGTH: usize = 2;

const BALANCER_PATH: &amp;str = &quot;server&quot;;
const CLIENT_PATH: &amp;str = &quot;client&quot;;

const NUM_SERVERS: usize = 3;
const NUM_CLIENTS: usize = 12;
const DATABASE_SIZE: usize = 10000;

const TIMEOUT: Duration = Duration::from_millis(100);
<span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    // use implicit policy
</span><span class="boring">    let broadcast_path: ActorPath = system
</span><span class="boring">        .system_path()
</span><span class="boring">        .into_named_with_string(&quot;client/*&quot;)
</span><span class="boring">        .expect(&quot;path&quot;)
</span><span class="boring">        .into();
</span><span class="boring">
</span><span class="boring">    // set explicit policy
</span><span class="boring">    let balancer_path = system
</span><span class="boring">        .set_routing_policy(
</span><span class="boring">            kompact::routing::groups::RoundRobinRouting::default(),
</span><span class="boring">            BALANCER_PATH,
</span><span class="boring">            false,
</span><span class="boring">        )
</span><span class="boring">        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
</span><span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span><span class="boring">    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let db = database.clone();
</span><span class="boring">            system.create(move || QueryServer::new(db))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, server)| {
</span><span class="boring">            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
</span><span class="boring">
</span><span class="boring">    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let server_path = balancer_path.clone();
</span><span class="boring">            let client_path = broadcast_path.clone();
</span><span class="boring">            system.create(move || Client::new(server_path, client_path))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, client)| {
</span><span class="boring">            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
</span><span class="boring">
</span><span class="boring">    // Start everything
</span><span class="boring">    servers
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|s| system.start_notify(s))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server start&quot;);
</span><span class="boring">    clients
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|c| system.start_notify(c))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client start&quot;);
</span><span class="boring">
</span><span class="boring">    // Let them work for a while
</span><span class="boring">    std::thread::sleep(Duration::from_secs(5));
</span><span class="boring">
</span><span class="boring">    // Shut down clients nicely.
</span><span class="boring">    clients
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|c| system.kill_notify(c))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client kill&quot;);
</span><span class="boring">
</span><span class="boring">    // Shut down servers nicely.
</span><span class="boring">    servers
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|s| system.kill_notify(s))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server kill&quot;);
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>First of all we set up the routing policies and their associated paths. In order to show off both variants, we will use implicit routing for the client broadcast path and explicit routing for the server select path. As mentioned before, implicit routing does not really require any specific setup. We simply construct the appropriate path, which in this case is going to be our system path followed by <code>client/*</code>. For the server load-balancing, we want to use the round-robin policy, which we will register under the <code>server</code> alias using <code>KompactSystem::set_routing_policy(...)</code>. Like a normal actor registration, this call returns a future with the actual path for this policy. Since the policy is set explicitly, this path will actually be of the form <code>tcp://127.0.0.1:&lt;port&gt;/server</code>, but sending a message to <code>tcp://127.0.0.1:&lt;port&gt;/server/?</code> would behave in the same manner.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Query {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for Query {
</span><span class="boring">    const SER_ID: SerId = 4242;
</span><span class="boring">}
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct QueryResponse {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">    matches: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for QueryResponse {
</span><span class="boring">    const SER_ID: SerId = 4243;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span><span class="boring">                self.server_path
</span><span class="boring">                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ENTRY_LENGTH: usize = 20;
</span><span class="boring">const PATTERN_LENGTH: usize = 2;
</span><span class="boring">
</span><span class="boring">const BALANCER_PATH: &amp;str = &quot;server&quot;;
</span><span class="boring">const CLIENT_PATH: &amp;str = &quot;client&quot;;
</span><span class="boring">
</span><span class="boring">const NUM_SERVERS: usize = 3;
</span><span class="boring">const NUM_CLIENTS: usize = 12;
</span><span class="boring">const DATABASE_SIZE: usize = 10000;
</span><span class="boring">
</span><span class="boring">const TIMEOUT: Duration = Duration::from_millis(100);
</span><span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span>    // use implicit policy
    let broadcast_path: ActorPath = system
        .system_path()
        .into_named_with_string(&quot;client/*&quot;)
        .expect(&quot;path&quot;)
        .into();

    // set explicit policy
    let balancer_path = system
        .set_routing_policy(
            kompact::routing::groups::RoundRobinRouting::default(),
            BALANCER_PATH,
            false,
        )
        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
<span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span><span class="boring">    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let db = database.clone();
</span><span class="boring">            system.create(move || QueryServer::new(db))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, server)| {
</span><span class="boring">            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
</span><span class="boring">
</span><span class="boring">    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let server_path = balancer_path.clone();
</span><span class="boring">            let client_path = broadcast_path.clone();
</span><span class="boring">            system.create(move || Client::new(server_path, client_path))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, client)| {
</span><span class="boring">            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
</span><span class="boring">
</span><span class="boring">    // Start everything
</span><span class="boring">    servers
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|s| system.start_notify(s))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server start&quot;);
</span><span class="boring">    clients
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|c| system.start_notify(c))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client start&quot;);
</span><span class="boring">
</span><span class="boring">    // Let them work for a while
</span><span class="boring">    std::thread::sleep(Duration::from_secs(5));
</span><span class="boring">
</span><span class="boring">    // Shut down clients nicely.
</span><span class="boring">    clients
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|c| system.kill_notify(c))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client kill&quot;);
</span><span class="boring">
</span><span class="boring">    // Shut down servers nicely.
</span><span class="boring">    servers
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|s| system.kill_notify(s))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server kill&quot;);
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We will then create and register both the servers and the clients, making sure to register either with a unique name (based on their index) under the correct path prefix.</p>
<h4 id="servers"><a class="header" href="#servers">Servers</a></h4>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Query {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for Query {
</span><span class="boring">    const SER_ID: SerId = 4242;
</span><span class="boring">}
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct QueryResponse {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">    matches: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for QueryResponse {
</span><span class="boring">    const SER_ID: SerId = 4243;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span><span class="boring">                self.server_path
</span><span class="boring">                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ENTRY_LENGTH: usize = 20;
</span><span class="boring">const PATTERN_LENGTH: usize = 2;
</span><span class="boring">
</span><span class="boring">const BALANCER_PATH: &amp;str = &quot;server&quot;;
</span><span class="boring">const CLIENT_PATH: &amp;str = &quot;client&quot;;
</span><span class="boring">
</span><span class="boring">const NUM_SERVERS: usize = 3;
</span><span class="boring">const NUM_CLIENTS: usize = 12;
</span><span class="boring">const DATABASE_SIZE: usize = 10000;
</span><span class="boring">
</span><span class="boring">const TIMEOUT: Duration = Duration::from_millis(100);
</span><span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    // use implicit policy
</span><span class="boring">    let broadcast_path: ActorPath = system
</span><span class="boring">        .system_path()
</span><span class="boring">        .into_named_with_string(&quot;client/*&quot;)
</span><span class="boring">        .expect(&quot;path&quot;)
</span><span class="boring">        .into();
</span><span class="boring">
</span><span class="boring">    // set explicit policy
</span><span class="boring">    let balancer_path = system
</span><span class="boring">        .set_routing_policy(
</span><span class="boring">            kompact::routing::groups::RoundRobinRouting::default(),
</span><span class="boring">            BALANCER_PATH,
</span><span class="boring">            false,
</span><span class="boring">        )
</span><span class="boring">        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
</span><span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span>    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
        .map(|_| {
            let db = database.clone();
            system.create(move || QueryServer::new(db))
        })
        .collect();

    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
        .iter()
        .enumerate()
        .map(|(index, server)| {
            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
        })
        .collect();
    // We don't actually need the paths,
    // just need to be sure they finished registering
    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
<span class="boring">
</span><span class="boring">    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let server_path = balancer_path.clone();
</span><span class="boring">            let client_path = broadcast_path.clone();
</span><span class="boring">            system.create(move || Client::new(server_path, client_path))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, client)| {
</span><span class="boring">            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
</span><span class="boring">
</span><span class="boring">    // Start everything
</span><span class="boring">    servers
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|s| system.start_notify(s))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server start&quot;);
</span><span class="boring">    clients
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|c| system.start_notify(c))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client start&quot;);
</span><span class="boring">
</span><span class="boring">    // Let them work for a while
</span><span class="boring">    std::thread::sleep(Duration::from_secs(5));
</span><span class="boring">
</span><span class="boring">    // Shut down clients nicely.
</span><span class="boring">    clients
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|c| system.kill_notify(c))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client kill&quot;);
</span><span class="boring">
</span><span class="boring">    // Shut down servers nicely.
</span><span class="boring">    servers
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|s| system.kill_notify(s))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server kill&quot;);
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h4 id="clients"><a class="header" href="#clients">Clients</a></h4>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Query {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for Query {
</span><span class="boring">    const SER_ID: SerId = 4242;
</span><span class="boring">}
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct QueryResponse {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">    matches: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for QueryResponse {
</span><span class="boring">    const SER_ID: SerId = 4243;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span><span class="boring">                self.server_path
</span><span class="boring">                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ENTRY_LENGTH: usize = 20;
</span><span class="boring">const PATTERN_LENGTH: usize = 2;
</span><span class="boring">
</span><span class="boring">const BALANCER_PATH: &amp;str = &quot;server&quot;;
</span><span class="boring">const CLIENT_PATH: &amp;str = &quot;client&quot;;
</span><span class="boring">
</span><span class="boring">const NUM_SERVERS: usize = 3;
</span><span class="boring">const NUM_CLIENTS: usize = 12;
</span><span class="boring">const DATABASE_SIZE: usize = 10000;
</span><span class="boring">
</span><span class="boring">const TIMEOUT: Duration = Duration::from_millis(100);
</span><span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    // use implicit policy
</span><span class="boring">    let broadcast_path: ActorPath = system
</span><span class="boring">        .system_path()
</span><span class="boring">        .into_named_with_string(&quot;client/*&quot;)
</span><span class="boring">        .expect(&quot;path&quot;)
</span><span class="boring">        .into();
</span><span class="boring">
</span><span class="boring">    // set explicit policy
</span><span class="boring">    let balancer_path = system
</span><span class="boring">        .set_routing_policy(
</span><span class="boring">            kompact::routing::groups::RoundRobinRouting::default(),
</span><span class="boring">            BALANCER_PATH,
</span><span class="boring">            false,
</span><span class="boring">        )
</span><span class="boring">        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
</span><span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span><span class="boring">    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let db = database.clone();
</span><span class="boring">            system.create(move || QueryServer::new(db))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, server)| {
</span><span class="boring">            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
</span><span class="boring">
</span>    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
        .map(|_| {
            let server_path = balancer_path.clone();
            let client_path = broadcast_path.clone();
            system.create(move || Client::new(server_path, client_path))
        })
        .collect();
    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
        .iter()
        .enumerate()
        .map(|(index, client)| {
            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
        })
        .collect();
    // We don't actually need the paths,
    // just need to be sure they finished registering
    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
<span class="boring">
</span><span class="boring">    // Start everything
</span><span class="boring">    servers
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|s| system.start_notify(s))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server start&quot;);
</span><span class="boring">    clients
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|c| system.start_notify(c))
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client start&quot;);
</span><span class="boring">
</span><span class="boring">    // Let them work for a while
</span><span class="boring">    std::thread::sleep(Duration::from_secs(5));
</span><span class="boring">
</span><span class="boring">    // Shut down clients nicely.
</span><span class="boring">    clients
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|c| system.kill_notify(c))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;client kill&quot;);
</span><span class="boring">
</span><span class="boring">    // Shut down servers nicely.
</span><span class="boring">    servers
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|s| system.kill_notify(s))
</span><span class="boring">        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">        .expect_completion(TIMEOUT, &quot;server kill&quot;);
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="running"><a class="header" href="#running">Running</a></h3>
<p>Finally, we simply start the servers and the clients, then run them for a few seconds, and shut them down again, before shutting down the system itself.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use lru::LruCache;
</span><span class="boring">use rand::{distributions::Alphanumeric, rngs::SmallRng, thread_rng, Rng, SeedableRng};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::{num::NonZeroUsize, sync::Arc, time::Duration};
</span><span class="boring">use uuid::Uuid;
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Query {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for Query {
</span><span class="boring">    const SER_ID: SerId = 4242;
</span><span class="boring">}
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct QueryResponse {
</span><span class="boring">    id: Uuid,
</span><span class="boring">    pattern: String,
</span><span class="boring">    matches: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">impl SerialisationId for QueryResponse {
</span><span class="boring">    const SER_ID: SerId = 4243;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct QueryServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    database: Arc&lt;[String]&gt;,
</span><span class="boring">    handled_requests: usize,
</span><span class="boring">}
</span><span class="boring">impl QueryServer {
</span><span class="boring">    fn new(database: Arc&lt;[String]&gt;) -&gt; Self {
</span><span class="boring">        QueryServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            database,
</span><span class="boring">            handled_requests: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_matches(&amp;self, pattern: &amp;str) -&gt; Vec&lt;String&gt; {
</span><span class="boring">        self.database
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|e| e.contains(pattern))
</span><span class="boring">            .cloned()
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for QueryServer {
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Server that handled {} requests&quot;, self.handled_requests
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for QueryServer {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(query): Query [using Serde] =&gt; {
</span><span class="boring">                    let matches = self.find_matches(&amp;query.pattern);
</span><span class="boring">                    let response = QueryResponse { id: query.id, pattern: query.pattern, matches };
</span><span class="boring">                    sender.tell((response, Serde), self);
</span><span class="boring">                    self.handled_requests += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Client {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    server_path: ActorPath,
</span><span class="boring">    broadcast_path: ActorPath,
</span><span class="boring">    request_count: usize,
</span><span class="boring">    cache_hits: usize,
</span><span class="boring">    cache: LruCache&lt;String, Vec&lt;String&gt;&gt;,
</span><span class="boring">    current_query: Option&lt;Query&gt;,
</span><span class="boring">    rng: SmallRng,
</span><span class="boring">}
</span><span class="boring">impl Client {
</span><span class="boring">    fn new(server_path: ActorPath, broadcast_path: ActorPath) -&gt; Self {
</span><span class="boring">        Client {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            server_path,
</span><span class="boring">            broadcast_path,
</span><span class="boring">            request_count: 0,
</span><span class="boring">            cache_hits: 0,
</span><span class="boring">            cache: LruCache::new(NonZeroUsize::new(20).unwrap()),
</span><span class="boring">            current_query: None,
</span><span class="boring">            rng: SmallRng::from_entropy(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_request(&amp;mut self) -&gt; () {
</span><span class="boring">        while self.current_query.is_none() {
</span><span class="boring">            let pattern = generate_string(&amp;mut self.rng, PATTERN_LENGTH);
</span><span class="boring">            self.request_count += 1;
</span><span class="boring">            let res = self.cache.get(&amp;pattern).map(|result| result.len());
</span><span class="boring">            if let Some(result) = res {
</span><span class="boring">                self.cache_hits += 1;
</span><span class="boring">                debug!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Answered query #{} ({}) with {} matches from cache.&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    result
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                let id = Uuid::new_v4();
</span><span class="boring">                trace!(
</span><span class="boring">                    self.log(),
</span><span class="boring">                    &quot;Sending query #{} ({}) with id={}&quot;,
</span><span class="boring">                    self.request_count,
</span><span class="boring">                    pattern,
</span><span class="boring">                    id
</span><span class="boring">                );
</span><span class="boring">                let query = Query { id, pattern };
</span><span class="boring">                self.current_query = Some(query.clone());
</span><span class="boring">                self.server_path
</span><span class="boring">                    .tell((query, Serde), &amp;self.broadcast_path.using_dispatcher(self));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Client {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.send_request();
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let hit_ratio = (self.cache_hits as f64) / (self.request_count as f64);
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Shutting down a Client that ran {} requests with {} cache hits ({}%)&quot;,
</span><span class="boring">            self.request_count,
</span><span class="boring">            self.cache_hits,
</span><span class="boring">            hit_ratio
</span><span class="boring">        );
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Client {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!(&quot;Can't instantiate Never type&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        match_deser! {
</span><span class="boring">            msg {
</span><span class="boring">                msg(response): QueryResponse [using Serde] =&gt; {
</span><span class="boring">                    trace!(self.log(), &quot;Got response for query id={}: {:?}&quot;, response.id, response.matches);
</span><span class="boring">                    if let Some(current_query) = self.current_query.take() {
</span><span class="boring">                        if current_query.id == response.id {
</span><span class="boring">                            debug!(self.log(), &quot;Got response with {} matches for query: {}&quot;, response.matches.len(), current_query.pattern);
</span><span class="boring">                            self.send_request();
</span><span class="boring">                        } else {
</span><span class="boring">                            // wrong id, put it back
</span><span class="boring">                            self.current_query = Some(current_query);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // in any case, put it in the cache
</span><span class="boring">                    self.cache.put(response.pattern, response.matches);
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ENTRY_LENGTH: usize = 20;
</span><span class="boring">const PATTERN_LENGTH: usize = 2;
</span><span class="boring">
</span><span class="boring">const BALANCER_PATH: &amp;str = &quot;server&quot;;
</span><span class="boring">const CLIENT_PATH: &amp;str = &quot;client&quot;;
</span><span class="boring">
</span><span class="boring">const NUM_SERVERS: usize = 3;
</span><span class="boring">const NUM_CLIENTS: usize = 12;
</span><span class="boring">const DATABASE_SIZE: usize = 10000;
</span><span class="boring">
</span><span class="boring">const TIMEOUT: Duration = Duration::from_millis(100);
</span><span class="boring">
</span><span class="boring">fn generate_string&lt;R: Rng&gt;(rng: &amp;mut R, length: usize) -&gt; String {
</span><span class="boring">    std::iter::repeat(())
</span><span class="boring">        .map(|_| rng.sample(Alphanumeric) as char)
</span><span class="boring">        .take(length)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_database(size: usize) -&gt; Arc&lt;[String]&gt; {
</span><span class="boring">    let mut data: Vec&lt;String&gt; = Vec::with_capacity(size);
</span><span class="boring">    let mut rng = thread_rng();
</span><span class="boring">    for _i in 0..size {
</span><span class="boring">        let entry = generate_string(&amp;mut rng, ENTRY_LENGTH);
</span><span class="boring">        data.push(entry);
</span><span class="boring">    }
</span><span class="boring">    data.into()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_str(kompact::runtime::MINIMAL_CONFIG);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::default().build());
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    // use implicit policy
</span><span class="boring">    let broadcast_path: ActorPath = system
</span><span class="boring">        .system_path()
</span><span class="boring">        .into_named_with_string(&quot;client/*&quot;)
</span><span class="boring">        .expect(&quot;path&quot;)
</span><span class="boring">        .into();
</span><span class="boring">
</span><span class="boring">    // set explicit policy
</span><span class="boring">    let balancer_path = system
</span><span class="boring">        .set_routing_policy(
</span><span class="boring">            kompact::routing::groups::RoundRobinRouting::default(),
</span><span class="boring">            BALANCER_PATH,
</span><span class="boring">            false,
</span><span class="boring">        )
</span><span class="boring">        .wait_expect(TIMEOUT, &quot;balancing policy&quot;);
</span><span class="boring">
</span><span class="boring">    let database = generate_database(DATABASE_SIZE);
</span><span class="boring">
</span><span class="boring">    let servers: Vec&lt;Arc&lt;Component&lt;QueryServer&gt;&gt;&gt; = (0..NUM_SERVERS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let db = database.clone();
</span><span class="boring">            system.create(move || QueryServer::new(db))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = servers
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, server)| {
</span><span class="boring">            system.register_by_alias(server, format!(&quot;{}/server-{}&quot;, BALANCER_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;server path&quot;);
</span><span class="boring">
</span><span class="boring">    let clients: Vec&lt;Arc&lt;Component&lt;Client&gt;&gt;&gt; = (0..NUM_CLIENTS)
</span><span class="boring">        .map(|_| {
</span><span class="boring">            let server_path = balancer_path.clone();
</span><span class="boring">            let client_path = broadcast_path.clone();
</span><span class="boring">            system.create(move || Client::new(server_path, client_path))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    let registration_futures: Vec&lt;KFuture&lt;RegistrationResult&gt;&gt; = clients
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .map(|(index, client)| {
</span><span class="boring">            system.register_by_alias(client, format!(&quot;{}/client-{}&quot;, CLIENT_PATH, index))
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">    // We don't actually need the paths,
</span><span class="boring">    // just need to be sure they finished registering
</span><span class="boring">    registration_futures.expect_ok(TIMEOUT, &quot;client path&quot;);
</span><span class="boring">
</span>    // Start everything
    servers
        .iter()
        .map(|s| system.start_notify(s))
        .expect_completion(TIMEOUT, &quot;server start&quot;);
    clients
        .iter()
        .map(|c| system.start_notify(c))
        .expect_completion(TIMEOUT, &quot;client start&quot;);

    // Let them work for a while
    std::thread::sleep(Duration::from_secs(5));

    // Shut down clients nicely.
    clients
        .into_iter()
        .map(|c| system.kill_notify(c))
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .expect_completion(TIMEOUT, &quot;client kill&quot;);

    // Shut down servers nicely.
    servers
        .into_iter()
        .map(|s| system.kill_notify(s))
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .expect_completion(TIMEOUT, &quot;server kill&quot;);

    system.shutdown().expect(&quot;shutdown&quot;);
<span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_load_balancer() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If we inspect the output in release mode, we can see that both clients and servers print some final statistics about their run. In particular the results of the servers show that the requests were very well balanced, thanks to our round-robin policy:</p>
<pre><code>Oct 23 18:15:58.869 INFO Shutting down a Client that ran 1060 requests with 6 cache hits (0.005660377358490566%), ctype: Client, cid: 07739284-1171-43c7-b547-198f9adf31e2, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.869 INFO Shutting down a Client that ran 1055 requests with 7 cache hits (0.006635071090047393%), ctype: Client, cid: 7a33e17c-042f-4271-95ea-a725ee471dae, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.869 INFO Shutting down a Client that ran 1052 requests with 4 cache hits (0.0038022813688212928%), ctype: Client, cid: 9b3c3c57-8246-4456-a7b8-0d200086df8d, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.869 INFO Shutting down a Client that ran 1050 requests with 3 cache hits (0.002857142857142857%), ctype: Client, cid: 1ecdef68-43af-46b4-8a40-a8ad4147b811, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.869 INFO Shutting down a Client that ran 1051 requests with 5 cache hits (0.004757373929590866%), ctype: Client, cid: 034f5dcc-a0ba-4bc2-aca0-6f1ab12be139, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.870 INFO Shutting down a Client that ran 1047 requests with 2 cache hits (0.0019102196752626551%), ctype: Client, cid: 59679577-6e9a-44ef-9739-08ca1b32b03f, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.870 INFO Shutting down a Client that ran 1048 requests with 3 cache hits (0.0028625954198473282%), ctype: Client, cid: ef76ddd0-e240-4ad6-8a10-b98da9ba41ff, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.870 INFO Shutting down a Client that ran 1044 requests with 0 cache hits (0%), ctype: Client, cid: ddf7d77a-4987-4411-81a5-bc4841200c32, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.870 INFO Shutting down a Client that ran 1051 requests with 7 cache hits (0.006660323501427212%), ctype: Client, cid: 12b65a83-c443-4853-8337-47ba5c45f60d, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.871 INFO Shutting down a Client that ran 1046 requests with 3 cache hits (0.0028680688336520078%), ctype: Client, cid: c7978b3f-9cf2-44d2-b93f-fc32ad90c941, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.872 INFO Shutting down a Client that ran 1049 requests with 6 cache hits (0.005719733079122974%), ctype: Client, cid: af389f4d-bc93-4f37-8f50-a70e054651e0, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.872 INFO Shutting down a Client that ran 1047 requests with 4 cache hits (0.0038204393505253103%), ctype: Client, cid: ad20509a-dbab-4dd3-a497-99a8488101b3, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:152
Oct 23 18:15:58.873 INFO Shutting down a Server that handled 4183 requests, ctype: QueryServer, cid: 35309404-a989-4b18-848f-5cc719b19a76, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:56
Oct 23 18:15:58.873 INFO Shutting down a Server that handled 4184 requests, ctype: QueryServer, cid: 2a2ed2cb-36bb-4df0-ac0e-0204e12417bd, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:56
Oct 23 18:15:58.873 INFO Shutting down a Server that handled 4183 requests, ctype: QueryServer, cid: a3d6d94a-ff9c-4749-9b6a-db2bfa2ac3e2, system: kompact-runtime-1, location: docs/examples/src/bin/load_balancer.rs:56
</code></pre>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin load_balancer
</code></pre>
<p>Note that running in debug mode will produce a lot of output as it will trace all the network messages.</p>
</blockquote>
<h1 id="serialisation"><a class="header" href="#serialisation">Serialisation</a></h1>
<p>In this section we are going take a closer look at the various serialisation options offered by Kompact. In particular, we will look at how to write different kinds of custom serialiser implementations, as well how to handle messages that are all but guaranteed to actually go over the network more efficiently.</p>
<h2 id="custom-serialisation"><a class="header" href="#custom-serialisation">Custom Serialisation</a></h2>
<p>At the centre of Kompact’s serialisation mechanisms are the <code>Serialisable</code> and <code>Deserialiser</code> traits, the signature of which looks roughtly like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub trait Serialisable: Send + Debug {
    /// The serialisation id for this serialisable
    fn ser_id(&amp;self) -&gt; SerId;

    /// An indicator how many bytes must be reserved in a buffer for a value to be
    /// serialsed into it with this serialiser
    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt;;

    /// Serialises this object (`self`) into `buf`
    fn serialise(&amp;self, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt;;

    /// Try move this object onto the heap for reflection, instead of serialising
    fn local(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;dyn Any + Send&gt;, Box&lt;dyn Serialisable&gt;&gt;;
}
</code></pre>
<pre><code class="language-rust edition2018 no_run noplaypen">pub trait Deserialiser&lt;T&gt;: Send {
    /// The serialisation id for which this deserialiser is to be invoked
    const SER_ID: SerId;

    /// Try to deserialise a `T` from the given `buf`
    fn deserialise(buf: &amp;mut dyn Buf) -&gt; Result&lt;T, SerError&gt;;
}
</code></pre>
<h3 id="outgoing-path"><a class="header" href="#outgoing-path">Outgoing Path</a></h3>
<p>When <code>ActorPath::tell(...)</code> is invoked with a type that is <code>Serialisable</code>, it will create a boxed trait object from the given instance and send it to the network layer. Only when the network layer has the determind that the destination must be accessed via a network channel, will the runtime serialise the instance into the network channel’s buffer. If it turns out the destination is on the same actor system as the source, it will simply call <code>Serialisable::local(...)</code> to get a boxed instance of the <code>Any</code> trait and then send it directly to the target component, without ever serialising. This approach is called <strong>lazy serialisation</strong>. For the vast majority of <code>Serialisable</code> implementations, <code>Serialisable::local(...)</code> is implemented simply as <code>Ok(self)</code>. However, for some more advanced usages (e.g., serialisation proxies) the implementation may have to call some additional code.</p>
<p>Once it is determined that an instance does indeed need to be serialised, the runtime will reserve some buffer memory for it to be serialised into. It does so by querying the <code>Serialisable::size_hint(...)</code> function for an estimate of how much space the type is likely going to take. For some types this is easy to know statically, but others it is not so clear. In any case, this is just an optimisation. Serialisation will proceed correctly even if the estimate is terribly wrong or no estimate is given at all.</p>
<p>The first thing in the new serialisation buffer is typically the serialisation id obtained via <code>Serialisable::ser_id(...)</code>. Typically, Kompact will only require a single serialisation id for the message to be written into the buffer, even if the message uses other serialisers internally, as long as all the internal types are statically known. This top-level serialisation id must match the <code>Deserialiser::SER_ID</code> for the deserialiser to be used for this instance. For types that implement both <code>Serialisable</code> and <code>Deserialiser</code>, as most do, it is recommended to simply use is <code>Self::SER_ID</code> as the implementation for <code>Serialisable::ser_id(...)</code> to make sure the ids match later.</p>
<p>The actual serialisation of the instance is handled by <code>Serialisable::serialise(...)</code>, which should use the functions provided by <a href="https://docs.rs/bytes/latest/bytes/trait.BufMut.html">BufMut</a> to serialise the individual parts of the instance into the buffer.</p>
<h4 id="serialiser"><a class="header" href="#serialiser">Serialiser</a></h4>
<p>Instead of implementing <code>Serialisable</code> we can also implement the <code>Serialiser</code> trait:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub trait Serialiser&lt;T&gt;: Send {
    /// The serialisation id for this serialiser
    fn ser_id(&amp;self) -&gt; SerId;

    /// An indicator how many bytes must be reserved in a buffer for a value to be
    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt;;

    /// Serialise `v` into `buf`.
    fn serialise(&amp;self, v: &amp;T, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt;;
}
</code></pre>
<p>This behaves essentually the same, except that it doesn’t serialise itself, but an instance of another type <code>T</code>. In order to use an instance <code>t: T</code> with a <code>Serialiser&lt;T&gt;</code> we can simply pass a pair of the two to the <code>ActorPath::tell(...)</code> function, as we have already seen in the previous section, for example with <code>Serde</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    convert::TryInto,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ZstSerialiser&lt;T&gt;(T)
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Serialiser&lt;T&gt; for &amp;ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        T::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        Some(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, _v: &amp;T, _buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deserialiser&lt;T&gt; for ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    const SER_ID: SerId = T::SER_ID;
</span><span class="boring">
</span><span class="boring">    fn deserialise(_buf: &amp;mut dyn Buf) -&gt; Result&lt;T, SerError&gt; {
</span><span class="boring">        Ok(T::default())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone, Copy, Default)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static CHECK_IN_SER: ZstSerialiser&lt;CheckIn&gt; = ZstSerialiser(CheckIn);
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">
</span><span class="boring">impl Serialisable for UpdateProcesses {
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        Self::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        let procs_size = self.0.len() * 23; // 23 bytes is the size of a unique actor path
</span><span class="boring">        Some(8 + procs_size)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        let len = self.0.len() as u64;
</span><span class="boring">        buf.put_u64(len);
</span><span class="boring">        for path in self.0.iter() {
</span><span class="boring">            path.serialise(buf)?;
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn local(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;dyn Any + Send&gt;, Box&lt;dyn Serialisable&gt;&gt; {
</span><span class="boring">        Ok(self)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Deserialiser&lt;UpdateProcesses&gt; for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">
</span><span class="boring">    fn deserialise(buf: &amp;mut dyn Buf) -&gt; Result&lt;UpdateProcesses, SerError&gt; {
</span><span class="boring">        let len_u64 = buf.get_u64();
</span><span class="boring">        let len: usize = len_u64.try_into().map_err(SerError::from_debug)?;
</span><span class="boring">        let mut data: Vec&lt;ActorPath&gt; = Vec::with_capacity(len);
</span><span class="boring">        for _i in 0..len {
</span><span class="boring">            let path = ActorPath::deserialise(buf)?;
</span><span class="boring">            data.push(path);
</span><span class="boring">        }
</span><span class="boring">        Ok(UpdateProcesses(data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; Handled {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process
</span><span class="boring">                .tell_serialised(msg.clone(), self)
</span><span class="boring">                .unwrap_or_else(|e| warn!(self.log(), &quot;Error during serialisation: {}&quot;, e));
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = ZstSerialiser&lt;CheckIn&gt;;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess()
</span><span class="boring">            } else {
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            Handled::Ok
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer = self.schedule_periodic(
</span><span class="boring">                        self.period,
</span><span class="boring">                        self.period,
</span><span class="boring">                        EventualLeaderElector::handle_timeout,
</span><span class="boring">                    );
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats()
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn send_heartbeats(&amp;self) -&gt; Handled {
        self.processes.iter().for_each(|process| {
            process.tell((Heartbeat, Serde), self);
        });
        Handled::Ok
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, &amp;CHECK_IN_SER), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(
</span><span class="boring">            self.period,
</span><span class="boring">            self.period,
</span><span class="boring">            EventualLeaderElector::handle_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(update): UpdateProcesses =&gt; {
</span><span class="boring">                    let UpdateProcesses(processes) = update;
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x - 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping_serialisation() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="incoming-path"><a class="header" href="#incoming-path">Incoming Path</a></h3>
<p>For any incoming network message the Kompact framework will buffer all data, and once it is complete, it will read out the serialisation id and create a <code>NetMessage</code> from it and the remaining buffer. It will then send the <code>NetMessage</code> directly to the destination component without any further processing. This approach is called <strong>lazy deserialisation</strong> and is quite different from most other actor/component frameworks, which tend to deserialise eagerly and then type match later at the destination component. However, in Rust the lazy approach is more efficient as it avoids unnecessary heap allocations for the deserialised instance.</p>
<p>When the <code>NetMessage::try_deserialise</code> function is called on the destination component, the serialisation ids of the message and the given <code>Deserialiser</code> will be checked and if they match up the <code>Deserialiser::deserialise(...)</code> function is called with the message’s data. For custom deserialisers, this method must use the <a href="https://docs.rs/bytes/latest/bytes/trait.Buf.html">Buf</a> API to implement essentially the inverse path of what the serialisable did before.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>To show how custom serialisers can be implemented, we will show two examples re-using the bootstrapping leader election from the previous sections.</p>
<h4 id="serialiser-1"><a class="header" href="#serialiser-1">Serialiser</a></h4>
<p>In our example, <code>CheckIn</code> is a <em>zero-sized type</em> (ZST), since we don’t really care about the message, only about the sender. Since ZSTs have no content, we can uniquely identify them by their serialisation id alone and all the serialisers for them are basically identical, in that their <code>serialise(...)</code> function consists simply of <code>Ok(())</code>. For this example, instead of using <code>Serde</code> for <code>CheckIn</code>, we will write our own <code>Serialiser</code> implementation for ZSTs and then use it for <code>CheckIn</code>. We could also use it for <code>Heartbeat</code>, but we won’t, so as to leave it as a reference for the other approach.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    convert::TryInto,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>struct ZstSerialiser&lt;T&gt;(T)
where
    T: Send + Sync + Default + Copy + SerialisationId;

impl&lt;T&gt; Serialiser&lt;T&gt; for &amp;ZstSerialiser&lt;T&gt;
where
    T: Send + Sync + Default + Copy + SerialisationId,
{
    fn ser_id(&amp;self) -&gt; SerId {
        T::SER_ID
    }

    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
        Some(0)
    }

    fn serialise(&amp;self, _v: &amp;T, _buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
        Ok(())
    }
}

impl&lt;T&gt; Deserialiser&lt;T&gt; for ZstSerialiser&lt;T&gt;
where
    T: Send + Sync + Default + Copy + SerialisationId,
{
    const SER_ID: SerId = T::SER_ID;

    fn deserialise(_buf: &amp;mut dyn Buf) -&gt; Result&lt;T, SerError&gt; {
        Ok(T::default())
    }
}

#[derive(Debug, Clone, Copy, Default)]
struct CheckIn;

impl SerialisationId for CheckIn {
    const SER_ID: SerId = 2345;
}

static CHECK_IN_SER: ZstSerialiser&lt;CheckIn&gt; = ZstSerialiser(CheckIn);
<span class="boring">
</span><span class="boring">#[derive(Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">
</span><span class="boring">impl Serialisable for UpdateProcesses {
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        Self::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        let procs_size = self.0.len() * 23; // 23 bytes is the size of a unique actor path
</span><span class="boring">        Some(8 + procs_size)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        let len = self.0.len() as u64;
</span><span class="boring">        buf.put_u64(len);
</span><span class="boring">        for path in self.0.iter() {
</span><span class="boring">            path.serialise(buf)?;
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn local(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;dyn Any + Send&gt;, Box&lt;dyn Serialisable&gt;&gt; {
</span><span class="boring">        Ok(self)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Deserialiser&lt;UpdateProcesses&gt; for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">
</span><span class="boring">    fn deserialise(buf: &amp;mut dyn Buf) -&gt; Result&lt;UpdateProcesses, SerError&gt; {
</span><span class="boring">        let len_u64 = buf.get_u64();
</span><span class="boring">        let len: usize = len_u64.try_into().map_err(SerError::from_debug)?;
</span><span class="boring">        let mut data: Vec&lt;ActorPath&gt; = Vec::with_capacity(len);
</span><span class="boring">        for _i in 0..len {
</span><span class="boring">            let path = ActorPath::deserialise(buf)?;
</span><span class="boring">            data.push(path);
</span><span class="boring">        }
</span><span class="boring">        Ok(UpdateProcesses(data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; Handled {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process
</span><span class="boring">                .tell_serialised(msg.clone(), self)
</span><span class="boring">                .unwrap_or_else(|e| warn!(self.log(), &quot;Error during serialisation: {}&quot;, e));
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = ZstSerialiser&lt;CheckIn&gt;;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess()
</span><span class="boring">            } else {
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            Handled::Ok
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer = self.schedule_periodic(
</span><span class="boring">                        self.period,
</span><span class="boring">                        self.period,
</span><span class="boring">                        EventualLeaderElector::handle_timeout,
</span><span class="boring">                    );
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats()
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; Handled {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, &amp;CHECK_IN_SER), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(
</span><span class="boring">            self.period,
</span><span class="boring">            self.period,
</span><span class="boring">            EventualLeaderElector::handle_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(update): UpdateProcesses =&gt; {
</span><span class="boring">                    let UpdateProcesses(processes) = update;
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x - 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping_serialisation() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We continue using the <code>SerialisationId</code> trait like we did for Serde, because we need to write id of the ZST not of the <code>ZstSerialiser</code>, which can serialise and deserialise many different ZSTs.</p>
<p>In order to create the correct type instance during deserialisation, we use the <code>Default</code> trait, which can be trivially derived for ZSTs.</p>
<p>It is clear that this serialiser is basically trivial. We can use it by creating a pair of <code>Checkin</code> with a reference to our static instance <code>CHECK_IN_SER</code>, which simply specialises the <code>ZstSerialiser</code> for <code>CheckIn</code>, as we did before: </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    convert::TryInto,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ZstSerialiser&lt;T&gt;(T)
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Serialiser&lt;T&gt; for &amp;ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        T::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        Some(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, _v: &amp;T, _buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deserialiser&lt;T&gt; for ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    const SER_ID: SerId = T::SER_ID;
</span><span class="boring">
</span><span class="boring">    fn deserialise(_buf: &amp;mut dyn Buf) -&gt; Result&lt;T, SerError&gt; {
</span><span class="boring">        Ok(T::default())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone, Copy, Default)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static CHECK_IN_SER: ZstSerialiser&lt;CheckIn&gt; = ZstSerialiser(CheckIn);
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">
</span><span class="boring">impl Serialisable for UpdateProcesses {
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        Self::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        let procs_size = self.0.len() * 23; // 23 bytes is the size of a unique actor path
</span><span class="boring">        Some(8 + procs_size)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        let len = self.0.len() as u64;
</span><span class="boring">        buf.put_u64(len);
</span><span class="boring">        for path in self.0.iter() {
</span><span class="boring">            path.serialise(buf)?;
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn local(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;dyn Any + Send&gt;, Box&lt;dyn Serialisable&gt;&gt; {
</span><span class="boring">        Ok(self)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Deserialiser&lt;UpdateProcesses&gt; for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">
</span><span class="boring">    fn deserialise(buf: &amp;mut dyn Buf) -&gt; Result&lt;UpdateProcesses, SerError&gt; {
</span><span class="boring">        let len_u64 = buf.get_u64();
</span><span class="boring">        let len: usize = len_u64.try_into().map_err(SerError::from_debug)?;
</span><span class="boring">        let mut data: Vec&lt;ActorPath&gt; = Vec::with_capacity(len);
</span><span class="boring">        for _i in 0..len {
</span><span class="boring">            let path = ActorPath::deserialise(buf)?;
</span><span class="boring">            data.push(path);
</span><span class="boring">        }
</span><span class="boring">        Ok(UpdateProcesses(data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; Handled {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process
</span><span class="boring">                .tell_serialised(msg.clone(), self)
</span><span class="boring">                .unwrap_or_else(|e| warn!(self.log(), &quot;Error during serialisation: {}&quot;, e));
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = ZstSerialiser&lt;CheckIn&gt;;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess()
</span><span class="boring">            } else {
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            Handled::Ok
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer = self.schedule_periodic(
</span><span class="boring">                        self.period,
</span><span class="boring">                        self.period,
</span><span class="boring">                        EventualLeaderElector::handle_timeout,
</span><span class="boring">                    );
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats()
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; Handled {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span>        self.bootstrap_server.tell((CheckIn, &amp;CHECK_IN_SER), self);
<span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(
</span><span class="boring">            self.period,
</span><span class="boring">            self.period,
</span><span class="boring">            EventualLeaderElector::handle_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(update): UpdateProcesses =&gt; {
</span><span class="boring">                    let UpdateProcesses(processes) = update;
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x - 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping_serialisation() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h4 id="serialisable"><a class="header" href="#serialisable">Serialisable</a></h4>
<p>Since the previous example was somewhat trivial, we will do a slightly trickier one for the <code>Serialisable</code> example. We will make the <code>UpdateProcesses</code> type both <code>Serialisable</code> and <code>Deserialiser&lt;UpdateProcesses&gt;</code>. This type contains a vector of <code>ActorPath</code> instances, which we must handle correctly. We will reuse the <code>Serialisable</code> and <code>Deserialiser&lt;ActorPath&gt;</code> implementations that are already provided for the <code>ActorPath</code> type.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    convert::TryInto,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ZstSerialiser&lt;T&gt;(T)
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Serialiser&lt;T&gt; for &amp;ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        T::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        Some(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, _v: &amp;T, _buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deserialiser&lt;T&gt; for ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    const SER_ID: SerId = T::SER_ID;
</span><span class="boring">
</span><span class="boring">    fn deserialise(_buf: &amp;mut dyn Buf) -&gt; Result&lt;T, SerError&gt; {
</span><span class="boring">        Ok(T::default())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone, Copy, Default)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static CHECK_IN_SER: ZstSerialiser&lt;CheckIn&gt; = ZstSerialiser(CheckIn);
</span><span class="boring">
</span>#[derive(Debug, Clone)]
struct UpdateProcesses(Vec&lt;ActorPath&gt;);

impl Serialisable for UpdateProcesses {
    fn ser_id(&amp;self) -&gt; SerId {
        Self::SER_ID
    }

    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
        let procs_size = self.0.len() * 23; // 23 bytes is the size of a unique actor path
        Some(8 + procs_size)
    }

    fn serialise(&amp;self, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
        let len = self.0.len() as u64;
        buf.put_u64(len);
        for path in self.0.iter() {
            path.serialise(buf)?;
        }
        Ok(())
    }

    fn local(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;dyn Any + Send&gt;, Box&lt;dyn Serialisable&gt;&gt; {
        Ok(self)
    }
}

impl Deserialiser&lt;UpdateProcesses&gt; for UpdateProcesses {
    const SER_ID: SerId = 3456;

    fn deserialise(buf: &amp;mut dyn Buf) -&gt; Result&lt;UpdateProcesses, SerError&gt; {
        let len_u64 = buf.get_u64();
        let len: usize = len_u64.try_into().map_err(SerError::from_debug)?;
        let mut data: Vec&lt;ActorPath&gt; = Vec::with_capacity(len);
        for _i in 0..len {
            let path = ActorPath::deserialise(buf)?;
            data.push(path);
        }
        Ok(UpdateProcesses(data))
    }
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn broadcast_processess(&amp;self) -&gt; Handled {
</span><span class="boring">        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
</span><span class="boring">        let msg = UpdateProcesses(procs);
</span><span class="boring">
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process
</span><span class="boring">                .tell_serialised(msg.clone(), self)
</span><span class="boring">                .unwrap_or_else(|e| warn!(self.log(), &quot;Error during serialisation: {}&quot;, e));
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = ZstSerialiser&lt;CheckIn&gt;;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess()
</span><span class="boring">            } else {
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            Handled::Ok
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer = self.schedule_periodic(
</span><span class="boring">                        self.period,
</span><span class="boring">                        self.period,
</span><span class="boring">                        EventualLeaderElector::handle_timeout,
</span><span class="boring">                    );
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats()
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; Handled {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, &amp;CHECK_IN_SER), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(
</span><span class="boring">            self.period,
</span><span class="boring">            self.period,
</span><span class="boring">            EventualLeaderElector::handle_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(update): UpdateProcesses =&gt; {
</span><span class="boring">                    let UpdateProcesses(processes) = update;
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x - 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping_serialisation() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>It would be easy to just iterate through the vector during serialisation and write one path at a time using its own <code>serialise(...)</code> implementation. But during deserialisation we need to know how many paths we have to take out of the buffer. We could simply try taking until the buffer refuses us, but this kind of approach often makes it difficult to detect bugs in one’s serialiser implementations. We will instead write the length of the vector before we serialise the actor paths, and during deserialisation we will read it first and allocate a vector of appropriate size. If we are concerned about the space the length wastes, we could try to use some better integer encoding like Protocol Buffers do, for example. But for now we don’t care so much and simply write a full <code>u64</code>. Those extra 8 bytes make little different compared to the sizes of a bunch of actor paths.</p>
<p>We don’t really have a good idea for <code>size_hint(...)</code> here. It’s basically 8 plus the sum of the size hints for each actor path. In this case, we actually know we are pretty much just going to send unique actor paths in this set, so we can assume each one is 23 bytes long. If that assumption turns out to be wrong in practice, it will simply cause some additional allocations during serialisation. In general, as a developer we have to decide on a trade-off between how much time we want to spend calculating accurate size hints, and how much time we want to spend on potential reallocations. We could also simply return a large number such as 1024 and accept that we may may often waste much of that allocated space. Application requirements (read: benchmarking) will determine which is the best choice in a particular scenario.</p>
<h2 id="eager-serialisation"><a class="header" href="#eager-serialisation">Eager Serialisation</a></h2>
<p>As mentioned above, using <code>ActorPath::tell(...)</code> may cause a stack-to-heap move of the data, as it is being converted into a boxed trait object for lazy serialisation. This approach optimises for avoiding expensive serialisations in the case where the <code>ActorPath</code> turns out to be local. However, this may not always be the appropriate approach, in particular if serialisation is quick compared to allocation, or most actor paths are not going to be local anyway. For these cases, Kompact also allows <strong>eager serialisation</strong>. To force an instance to be serialised eagerly, on the sending component’s thread, you can use <code>ActorPath::tell_serialised(...)</code>. It works essentially the same as <code>ActorPath::tell(...)</code> but uses a buffer pool local to the sending component to serialise the data into, before sending it off to the dispatcher. If then in the dispatcher it turns out that the actor path was actually local, the data simply has to be deserialised again, as if it had arrived remotely. If the target is remote, however, the data can be written directly into the appropriate channel.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<p>To show an easy usage for this approach, we use eager serialisation in the <code>BootstrapServer::broadcast_processess</code> function: </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::{prelude::*, serde_serialisers::*};
</span><span class="boring">use kompact_examples::trusting::*;
</span><span class="boring">use std::{
</span><span class="boring">    collections::HashSet,
</span><span class="boring">    convert::TryInto,
</span><span class="boring">    net::{IpAddr, Ipv4Addr, SocketAddr},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ZstSerialiser&lt;T&gt;(T)
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Serialiser&lt;T&gt; for &amp;ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        T::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        Some(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, _v: &amp;T, _buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deserialiser&lt;T&gt; for ZstSerialiser&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Send + Sync + Default + Copy + SerialisationId,
</span><span class="boring">{
</span><span class="boring">    const SER_ID: SerId = T::SER_ID;
</span><span class="boring">
</span><span class="boring">    fn deserialise(_buf: &amp;mut dyn Buf) -&gt; Result&lt;T, SerError&gt; {
</span><span class="boring">        Ok(T::default())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone, Copy, Default)]
</span><span class="boring">struct CheckIn;
</span><span class="boring">
</span><span class="boring">impl SerialisationId for CheckIn {
</span><span class="boring">    const SER_ID: SerId = 2345;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static CHECK_IN_SER: ZstSerialiser&lt;CheckIn&gt; = ZstSerialiser(CheckIn);
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone)]
</span><span class="boring">struct UpdateProcesses(Vec&lt;ActorPath&gt;);
</span><span class="boring">
</span><span class="boring">impl Serialisable for UpdateProcesses {
</span><span class="boring">    fn ser_id(&amp;self) -&gt; SerId {
</span><span class="boring">        Self::SER_ID
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn size_hint(&amp;self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        let procs_size = self.0.len() * 23; // 23 bytes is the size of a unique actor path
</span><span class="boring">        Some(8 + procs_size)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn serialise(&amp;self, buf: &amp;mut dyn BufMut) -&gt; Result&lt;(), SerError&gt; {
</span><span class="boring">        let len = self.0.len() as u64;
</span><span class="boring">        buf.put_u64(len);
</span><span class="boring">        for path in self.0.iter() {
</span><span class="boring">            path.serialise(buf)?;
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn local(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;dyn Any + Send&gt;, Box&lt;dyn Serialisable&gt;&gt; {
</span><span class="boring">        Ok(self)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Deserialiser&lt;UpdateProcesses&gt; for UpdateProcesses {
</span><span class="boring">    const SER_ID: SerId = 3456;
</span><span class="boring">
</span><span class="boring">    fn deserialise(buf: &amp;mut dyn Buf) -&gt; Result&lt;UpdateProcesses, SerError&gt; {
</span><span class="boring">        let len_u64 = buf.get_u64();
</span><span class="boring">        let len: usize = len_u64.try_into().map_err(SerError::from_debug)?;
</span><span class="boring">        let mut data: Vec&lt;ActorPath&gt; = Vec::with_capacity(len);
</span><span class="boring">        for _i in 0..len {
</span><span class="boring">            let path = ActorPath::deserialise(buf)?;
</span><span class="boring">            data.push(path);
</span><span class="boring">        }
</span><span class="boring">        Ok(UpdateProcesses(data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct BootstrapServer {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    processes: HashSet&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl BootstrapServer {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        BootstrapServer {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            processes: HashSet::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn broadcast_processess(&amp;self) -&gt; Handled {
        let procs: Vec&lt;ActorPath&gt; = self.processes.iter().cloned().collect();
        let msg = UpdateProcesses(procs);

        self.processes.iter().for_each(|process| {
            process
                .tell_serialised(msg.clone(), self)
                .unwrap_or_else(|e| warn!(self.log(), &quot;Error during serialisation: {}&quot;, e));
        });
        Handled::Ok
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(BootstrapServer);
</span><span class="boring">
</span><span class="boring">impl NetworkActor for BootstrapServer {
</span><span class="boring">    type Deserialiser = ZstSerialiser&lt;CheckIn&gt;;
</span><span class="boring">    type Message = CheckIn;
</span><span class="boring">
</span><span class="boring">    fn receive(&amp;mut self, source: Option&lt;ActorPath&gt;, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        if let Some(process) = source {
</span><span class="boring">            if self.processes.insert(process) {
</span><span class="boring">                self.broadcast_processess()
</span><span class="boring">            } else {
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            Handled::Ok
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct EventualLeaderElector {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    omega_port: ProvidedPort&lt;EventualLeaderDetection&gt;,
</span><span class="boring">    bootstrap_server: ActorPath,
</span><span class="boring">    processes: Box&lt;[ActorPath]&gt;,
</span><span class="boring">    candidates: HashSet&lt;ActorPath&gt;,
</span><span class="boring">    period: Duration,
</span><span class="boring">    delta: Duration,
</span><span class="boring">    timer_handle: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    leader: Option&lt;ActorPath&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl EventualLeaderElector {
</span><span class="boring">    fn new(bootstrap_server: ActorPath) -&gt; Self {
</span><span class="boring">        let minimal_period = Duration::from_millis(1);
</span><span class="boring">        EventualLeaderElector {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            omega_port: ProvidedPort::uninitialised(),
</span><span class="boring">            bootstrap_server,
</span><span class="boring">            processes: Vec::new().into_boxed_slice(),
</span><span class="boring">            candidates: HashSet::new(),
</span><span class="boring">            period: minimal_period,
</span><span class="boring">            delta: minimal_period,
</span><span class="boring">            timer_handle: None,
</span><span class="boring">            leader: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_leader(&amp;mut self) -&gt; Option&lt;ActorPath&gt; {
</span><span class="boring">        let mut candidates: Vec&lt;ActorPath&gt; = self.candidates.drain().collect();
</span><span class="boring">        candidates.sort_unstable();
</span><span class="boring">        candidates.reverse(); // pick smallest instead of largest
</span><span class="boring">        candidates.pop()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.timer_handle.take() {
</span><span class="boring">            Some(timeout) if timeout == timeout_id =&gt; {
</span><span class="boring">                let new_leader = self.select_leader();
</span><span class="boring">                if new_leader != self.leader {
</span><span class="boring">                    self.period += self.delta;
</span><span class="boring">                    self.leader = new_leader;
</span><span class="boring">                    if let Some(ref leader) = self.leader {
</span><span class="boring">                        self.omega_port.trigger(Trust(leader.clone()));
</span><span class="boring">                    }
</span><span class="boring">                    self.cancel_timer(timeout);
</span><span class="boring">                    let new_timer = self.schedule_periodic(
</span><span class="boring">                        self.period,
</span><span class="boring">                        self.period,
</span><span class="boring">                        EventualLeaderElector::handle_timeout,
</span><span class="boring">                    );
</span><span class="boring">                    self.timer_handle = Some(new_timer);
</span><span class="boring">                } else {
</span><span class="boring">                    // just put it back
</span><span class="boring">                    self.timer_handle = Some(timeout);
</span><span class="boring">                }
</span><span class="boring">                self.send_heartbeats()
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn send_heartbeats(&amp;self) -&gt; Handled {
</span><span class="boring">        self.processes.iter().for_each(|process| {
</span><span class="boring">            process.tell((Heartbeat, Serde), self);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for EventualLeaderElector {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.bootstrap_server.tell((CheckIn, &amp;CHECK_IN_SER), self);
</span><span class="boring">
</span><span class="boring">        self.period = self.ctx.config()[&quot;omega&quot;][&quot;initial-period&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;initial period&quot;);
</span><span class="boring">        self.delta = self.ctx.config()[&quot;omega&quot;][&quot;delta&quot;]
</span><span class="boring">            .as_duration()
</span><span class="boring">            .expect(&quot;delta&quot;);
</span><span class="boring">        let timeout = self.schedule_periodic(
</span><span class="boring">            self.period,
</span><span class="boring">            self.period,
</span><span class="boring">            EventualLeaderElector::handle_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.timer_handle = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.timer_handle.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">// Doesn't have any requests
</span><span class="boring">ignore_requests!(EventualLeaderDetection, EventualLeaderElector);
</span><span class="boring">
</span><span class="boring">impl Actor for EventualLeaderElector {
</span><span class="boring">    type Message = Never;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, _msg: Self::Message) -&gt; Handled {
</span><span class="boring">        unreachable!();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, msg: NetMessage) -&gt; Handled {
</span><span class="boring">        let sender = msg.sender;
</span><span class="boring">
</span><span class="boring">        match_deser! {
</span><span class="boring">            (msg.data) {
</span><span class="boring">                msg(_heartbeat): Heartbeat [using Serde] =&gt; {
</span><span class="boring">                    self.candidates.insert(sender);
</span><span class="boring">                },
</span><span class="boring">                msg(update): UpdateProcesses =&gt; {
</span><span class="boring">                    let UpdateProcesses(processes) = update;
</span><span class="boring">                    info!(
</span><span class="boring">                        self.log(),
</span><span class="boring">                        &quot;Received new process set with {} processes&quot;,
</span><span class="boring">                        processes.len()
</span><span class="boring">                    );
</span><span class="boring">                    self.processes = processes.into_boxed_slice();
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = std::env::args().collect();
</span><span class="boring">    match args.len() {
</span><span class="boring">        2 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let system = run_server(bootstrap_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        3 =&gt; {
</span><span class="boring">            let bootstrap_port: u16 = args[1].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let bootstrap_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), bootstrap_port);
</span><span class="boring">            let client_port: u16 = args[2].parse().expect(&quot;port number&quot;);
</span><span class="boring">            let client_socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
</span><span class="boring">            let system = run_client(bootstrap_socket, client_socket);
</span><span class="boring">            system.await_termination(); // gotta quit it from command line
</span><span class="boring">        }
</span><span class="boring">        x =&gt; panic!(&quot;Expected either 1 argument (the port for the bootstrap server to bind on) or 2 arguments (boostrap server and client port), but got {} instead!&quot;, x - 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const BOOTSTRAP_PATH: &amp;str = &quot;bootstrap&quot;;
</span><span class="boring">
</span><span class="boring">pub fn run_server(socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(DeadletterBox::new, NetworkConfig::new(socket).build());
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let (bootstrap, bootstrap_registration) = system.create_and_register(BootstrapServer::new);
</span><span class="boring">    let bootstrap_service_registration = system.register_by_alias(&amp;bootstrap, BOOTSTRAP_PATH);
</span><span class="boring">
</span><span class="boring">    let _bootstrap_unique = bootstrap_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    let bootstrap_service = bootstrap_service_registration
</span><span class="boring">        .wait_expect(Duration::from_millis(1000), &quot;bootstrap never registered&quot;);
</span><span class="boring">    system.start(&amp;bootstrap);
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run_client(bootstrap_socket: SocketAddr, client_socket: SocketAddr) -&gt; KompactSystem {
</span><span class="boring">    let mut cfg = KompactConfig::default();
</span><span class="boring">    cfg.load_config_file(&quot;./application.conf&quot;);
</span><span class="boring">    cfg.system_components(
</span><span class="boring">        DeadletterBox::new,
</span><span class="boring">        NetworkConfig::new(client_socket).build(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let system = cfg.build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">
</span><span class="boring">    let bootstrap_service: ActorPath = NamedPath::with_socket(
</span><span class="boring">        Transport::Tcp,
</span><span class="boring">        bootstrap_socket,
</span><span class="boring">        vec![BOOTSTRAP_PATH.into()],
</span><span class="boring">    )
</span><span class="boring">    .into();
</span><span class="boring">
</span><span class="boring">    let printer = system.create(TrustPrinter::new);
</span><span class="boring">    let (detector, registration) =
</span><span class="boring">        system.create_and_register(|| EventualLeaderElector::new(bootstrap_service));
</span><span class="boring">    biconnect_components::&lt;EventualLeaderDetection, _, _&gt;(&amp;detector, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let _path = registration.wait_expect(Duration::from_millis(1000), &quot;detector never registered&quot;);
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;detector);
</span><span class="boring">
</span><span class="boring">    system
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    const SERVER_SOCKET: &amp;str = &quot;127.0.0.1:12345&quot;;
</span><span class="boring">    const CLIENT_SOCKET: &amp;str = &quot;127.0.0.1:0&quot;;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_bootstrapping_serialisation() {
</span><span class="boring">        let server_socket: SocketAddr = SERVER_SOCKET.parse().unwrap();
</span><span class="boring">        let server_system = run_server(server_socket);
</span><span class="boring">        let client_socket: SocketAddr = CLIENT_SOCKET.parse().unwrap();
</span><span class="boring">        let mut clients_systems: Vec&lt;KompactSystem&gt; = (0..3)
</span><span class="boring">            .map(|_i| run_client(server_socket, client_socket))
</span><span class="boring">            .collect();
</span><span class="boring">        // let them settle
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        // shut down systems one by one
</span><span class="boring">        for sys in clients_systems.drain(..) {
</span><span class="boring">            std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">            sys.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">        }
</span><span class="boring">        std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">        server_system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>As you can see above, another feature of eager serialisation is that you can (and must) deal with serialisaition errors, which you have no control over using lazy serialisation. In particular, your memory allocation may prevent your local buffer pool from allocating a buffer large enough to fit your data at the time of serialisation. In this case you will get a <code>SerError::BufferError</code> and must decide how to handle that. You could either retry at a later time, or switch to <em>lazy serialisation</em> and hope the network’s buffers still have capacity (assuming they likely have priority over component local buffer pools).</p>
<h1 id="network-buffers"><a class="header" href="#network-buffers">Network Buffers</a></h1>
<p>Kompact uses a BufferPool system to serialize network messages. This section describes the BufferPools briefly and how they can be configured with different parameters.</p>
<p>Before we begin describing the Network Buffers we remind the reader that there are two different methods for sending messages over the network in Kompact:</p>
<ol>
<li><strong>Lazy serialisation</strong> <code>dst.tell(msg: M, from: S);</code></li>
<li><strong>Eager serialisation</strong> <code>dst.tell_serialised(msg: M, from: &amp;self);</code></li>
</ol>
<p>With lazy serialisation the Actor moves the data to the heap, and transfers it unserialised to the <code>NetworkDispatcher</code>, which later serialises the message into its (the <code>NetworkDispatcher</code>‘s) own buffers.<br />
Eager serialisation serialises the data immediately into the Actor’s buffers, and then transfers ownership of the serialised the data to the <code>NetworkDispatcher</code>.</p>
<p>Lazy serialisation may fail due to two reasons: A serialisation error, or there are no available buffers. Both will be
unnoticeable to the actor initiating the message sending, and both will lead to the message being lost.</p>
<h2 id="how-the-buffer-pools-work"><a class="header" href="#how-the-buffer-pools-work">How the Buffer Pools work</a></h2>
<h3 id="buffer-pool-locations"><a class="header" href="#buffer-pool-locations">Buffer Pool locations</a></h3>
<p>In a Kompact system where many actors use eager serialisation there will be many <code>BufferPool</code> instances. If the actors in the system only use lazy serialisation there will be a single pool, owned by the <code>NetworkThread</code> for serialising and receiving data.</p>
<h3 id="bufferpool-bufferchunk-and-chunklease"><a class="header" href="#bufferpool-bufferchunk-and-chunklease">BufferPool, BufferChunk, and ChunkLease</a></h3>
<p>Each <code>BufferPool</code> (pool) consists of more than one <code>BufferChunk</code> (chunks). A chunk is the concrete memory area used for serialising data into. There may be many messages serialised into a single chunk, and discrete slices of the chunks (i.e. individual messages) can be extracted and sent to other threads/actors through the smart-pointer <code>ChunkLease</code> (lease). When a chunk runs out of space it will be locked and returned to the pool. If and only if all outstanding leases created from a chunk have been dropped may the chunk be unlocked and reused, or deallocated.</p>
<p>When a pool is created it will pre-allocate a configurable amount of chunks, and will attempt to reuse those as long as possible, and only when it needs to will it allocate more chunks, up to a configurable maximum number of chunks. </p>
<h3 id="bufferpool-interface"><a class="header" href="#bufferpool-interface">BufferPool interface</a></h3>
<p>Actors access their pool through the <code>EncodeBuffer</code> wrapper which maintains a single active chunk at a time, and automatically swaps the active buffer with the local <code>BufferPool</code> when necessary.</p>
<p>The method <code>tell_serialised(msg, &amp;self)</code> automatically uses the <code>EncodeBuffer</code> interface such that users of Kompact do not need to use the interfaces of the pool (which is why the method requires a <code>self</code> reference). </p>
<h3 id="bufferpool-initialization"><a class="header" href="#bufferpool-initialization">BufferPool initialization</a></h3>
<p>Actors initialize their local buffers automatically when the first invocation of <code>tell_serialised(...)</code> occurs. If an Actor never invokes the method it will not allocate any buffers.</p>
<p>An actor may call the initialization method through the call <code>self.ctx.borrow().init_buffers(None, None);</code><sup class="footnote-reference"><a href="#1">1</a></sup> to explicitly initialize the local <code>BufferPool</code> without sending a message.</p>
<h2 id="bufferconfig"><a class="header" href="#bufferconfig">BufferConfig</a></h2>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>There are four configurable parameters in the BufferConfig:</p>
<ol>
<li><code>chunk_size</code>: The size (in bytes) of the <code>BufferChunks</code>. Default value is 128KB.</li>
<li><code>initial_chunk_count</code>: How many <code>BufferChunks</code> the <code>BufferPool</code> will pre-allocate. Default value is 2.</li>
<li><code>max_chunk_count</code>: The maximum number of <code>BufferChunks</code> the <code>BufferPool</code> may have allocated simultaneously. Default value is 1000.</li>
<li><code>encode_buf_min_free_space</code>: When an Actor begins serialising a message the <code>EncodeBuffer</code> will compare how much space (in bytes) is left in the active chunk and compare it to this parameter, if there is less free space the active chunk will be replaced with a new one from the pool before continuing the serialisation. Default value is 64 bytes.</li>
</ol>
<h3 id="configuring-the-buffers"><a class="header" href="#configuring-the-buffers">Configuring the Buffers</a></h3>
<h4 id="individual-actor-configuration"><a class="header" href="#individual-actor-configuration">Individual Actor Configuration</a></h4>
<p>If no <code>BufferConfig</code> is specified Kompact will use the default settings for all <code>BufferPools</code>. Actors may be configured with individual <code>BufferConfigs</code> through the <code>init_buffer(Some(config), None)</code><sup class="footnote-reference"><a href="#1">1</a></sup> config. It is important that the call is made before any calls to <code>tell_serialised(...)</code>. For example, the <code>on_start()</code> function of the <code>ComponentLifecycle</code> may be used to ensure this, as in the following example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">impl ComponentLifecycle for CustomBufferConfigActor {
    fn on_start(&amp;mut self) -&gt; Handled {
        let mut buffer_config = BufferConfig::default();
        buffer_config.encode_buf_min_free_space(128);
        buffer_config.max_chunk_count(5);
        buffer_config.initial_chunk_count(4);
        buffer_config.chunk_size(256*1024);
        
        self.ctx.borrow().init_buffers(Some(buffer_config), None);
        Handled::Ok
    }
    ...
}
</code></pre>
<h4 id="configuring-all-actors"><a class="header" href="#configuring-all-actors">Configuring All Actors</a></h4>
<p>If a programmer wishes for all actors to use the same <code>BufferConfig</code> configuration, a Hocon string can be inserted into the <code>KompactConfig</code> or loaded from a Hocon-file (<a href="distributed/./../local/configuration.html">see configuration chapter on loading configurations</a>), for example: </p>
<pre><code class="language-rust edition2018 no_run noplaypen">let mut cfg = KompactConfig::new();
cfg.load_config_str(
    r#&quot;{
        buffer_config {
            chunk_size: &quot;256KB&quot;,
            initial_chunk_count: 3,
            max_chunk_count: 4,
            encode_min_remaining: &quot;20B&quot;,
        }
        }&quot;#,
);
...
let system = cfg.build().expect(&quot;KompactSystem&quot;);
</code></pre>
<p>If a <code>BufferConfig</code> is loaded into the systems <code>KompactConfig</code> then all actors will use that configuration instead of the default <code>BufferConfig</code>, however individual actors may still override the configuration by using the <code>init_buffers(...)</code> method.</p>
<h4 id="configuring-the-networkdispatcher-and-networkthread"><a class="header" href="#configuring-the-networkdispatcher-and-networkthread">Configuring the NetworkDispatcher and NetworkThread</a></h4>
<p>The <code>NetworkDispatcher</code> and <code>NetworkThread</code> are configured separately from the Actors and use their buffers for lazy serialisation and receiving data from the network. To configure their buffers the <code>NetworkConfig</code> may be created using the method <code>::with_buffer_config(...)</code> as in the example below:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let mut cfg = KompactConfig::new();
let mut network_buffer_config = BufferConfig::default();
network_buffer_config.chunk_size(512);
network_buffer_config.initial_chunk_count(2);
network_buffer_config.max_chunk_count(3);
network_buffer_config.encode_buf_min_free_space(10);
cfg.system_components(DeadletterBox::new, {
    NetworkConfig::with_buffer_config(
        &quot;127.0.0.1:0&quot;.parse().expect(&quot;Address should work&quot;),
        network_buffer_config,
    )
    .build()
});
let system = cfg.build().expect(&quot;KompactSystem&quot;);
</code></pre>
<h4 id="bufferconfig-validation"><a class="header" href="#bufferconfig-validation">BufferConfig Validation</a></h4>
<p><code>BufferConfig</code> implements the method <code>validate()</code> which causes a panic if the set of parameters is invalid. It is invoked whenever a <code>BufferPool</code> is created from the given configuration. The validation checks that the following conditions hold true:</p>
<ul>
<li><code>chunk_size &gt; encode_buf_min_free_space</code></li>
<li><code>chunk_size &gt; 127</code></li>
<li><code>max_chunk_count &gt;= initial_chunk_count</code></li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The method <code>init_buffers(...)</code> takes two <code>Option</code> arguments, of which the second argument has not been covered. The second argument allows users of Kompact to specify a <code>CustomAllocator</code>: a poorly tested, experimental feature which is left undocumented for the time being. </p>
</div>
<h1 id="network-status-port"><a class="header" href="#network-status-port">Network Status Port</a></h1>
<p>The <code>NetworkDispatcher</code> provides a <code>NetworkStatusPort</code> which any Component may use to subscribe to information about the 
Network, or make requests to the Network Layer.</p>
<h2 id="using-the-network-status-port"><a class="header" href="#using-the-network-status-port">Using the Network Status Port</a></h2>
<p>To subscribe to the import a component must implement <code>Require</code> for <code>NetworkStatusPort</code>. The system must be set-up with 
a <code>NetworkingConfig</code> to enable Networking. When the component is instantiated it must be explicitly connected to the 
<code>NetworkStatusPort</code>. <code>KompactSystem</code> exposes the convenience method 
<code>connect_network_status_port&lt;C&gt;(&amp;self, required: &amp;mut RequiredPort&lt;NetworkStatusPort&gt;)</code> to subscribe a component to the 
port, and may be used as in the example below.</p>
<pre><code># use kompact::prelude::*;
# use kompact::net::net_test_helpers::NetworkStatusCounter;
let mut cfg = KompactConfig::new();
cfg.system_components(DeadletterBox::new, {
    let net_config = NetworkConfig::new(&quot;127.0.0.1:0&quot;.parse().expect(&quot;&quot;));
    net_config.build()
});
let system = cfg.build().expect(&quot;KompactSystem&quot;);
let status_counter = system.create(NetworkStatusCounter::new);
status_counter.on_definition(|c|{
  system.connect_network_status_port(&amp;mut c.network_status_port);
})
</code></pre>
<h2 id="network-status-indications"><a class="header" href="#network-status-indications">Network Status Indications</a></h2>
<p><code>NetworkStatus</code> events are the <code>Indications</code> sent by the dispatcher to the subscribed components. 
The Event is an <code>enum</code> with the following variants:</p>
<ul>
<li><code>ConnectionEstablished(SystemPath)</code> Indicates that a connection has been established to the remote system</li>
<li><code>ConnectionLost(SystemPath)</code> Indicates that a connection has been lost to the remote system. The system will 
automatically try to recover the connection for a configurable amount of retries. The end of the automatic retries is 
signalled by a <code>ConnectionDropped</code> message.</li>
<li><code>ConnectionDropped(SystemPath)</code> Indicates that a connection has been dropped and no more automatic retries to 
re-establish the connection will be attempted and all queued messages have been dropped.</li>
<li><code>ConnectionClosed(SystemPath)</code> Indicates that a connection has been gracefully closed, no automatic retries will be
attempted.</li>
<li><code>SoftConnectionLimitReached</code> Indicates that the <code>SoftConnectionLimit</code> has been reached, the <code>NetworkThread</code> will 
gracefully close the least-recently-used connection, and will continuously evict (gracefully) the LRU-connection when new 
connection attempts (incoming or outgoing) are made.</li>
<li><code>HardConnectionLimitReached</code> Indicates that the <code>HardConnectionLimit</code> has been reached. New connection attempts will
be discarded immediately until the number of connections are lower.</li>
<li><code>CriticalNetworkFailure</code> The <code>NetworkThread</code> has Panicked and will be restarted, any number of incoming and outgoing 
messages may have been lost.</li>
<li><code>BlockedSystem(SystemPath)</code> Indicates that a system has been blocked.</li>
<li><code>BlockedIp(IpAddr)</code> Indicates that an IpAddr has been blocked.</li>
<li><code>BlockedIpNet(IpNet)</code> Indicates that an IpAddr has been blocked.</li>
<li><code>AllowedSystem(SystemPath)</code> Indicates that a system has been unblocked after previously being blocked.</li>
<li><code>AllowedIp(IpAddr)</code> Indicates that an IpAddr has been unblocked after previously being blocked.</li>
<li><code>AllowedIpNet(IpNet)</code> Indicates that an IpNet has been unblocked after previously being blocked.</li>
</ul>
<p>The Networking layer distinguishes between gracefully closed connections and lost connections. 
A lost connection will trigger reconnection attempts for a configurable amount of times, before it is completely dropped. 
It will also retain outgoing messages for lost connections until the connection is dropped. </p>
<h2 id="network-status-requests"><a class="header" href="#network-status-requests">Network Status Requests</a></h2>
<p>The <code>NetworkDispatcher</code> may respond to <code>NetworkStatusRequest</code> sent by Components onto the channel. 
The event is an <code>enum</code> with the following variants:</p>
<ul>
<li><code>DisconnectSystem(SystemPath)</code> Request that the connection to the given system is closed gracefully. The 
<code>NetworkDispatcher</code>will immediately start a graceful shutdown of the channel if it is currently active.</li>
<li><code>ConnectSystem(SystemPath)</code> Request that a connection is (re-)established to the given system. Sending this message is
the only way a connection may be re-established between systems previously disconnected by a <code>DisconnectSystem</code> request.</li>
<li><code>BlockSystem(SystemPath)</code> Request that a SystemPath to be blocked from this system. An established connection
will be dropped and future attempts to establish a connection by that given SystemPath will be dropped.</li>
<li><code>BlockIp(IpAddr)</code> Request an IpAddr to be blocked. Established connections which become blocked
will be dropped and future attempts to establish a connection by that given IpAddr will be dropped.</li>
<li><code>BlockIpNet(IpNet)</code> Request an IpNet to be blocked. Established connections which become blocked
will be dropped and future attempts to establish connections to the IpNet be dropped.</li>
<li><code>AllowSystem(SystemPath)</code> This acts as an allow-list for SystemPaths. Allowed SystemPaths will always take precedence
over Blocked Ips or IpNets. This is the only way to undo a previously blocked SystemPath.</li>
<li><code>AllowIp(IpAddr)</code> Request an IpAddr to be unblocked after previously being blocked.</li>
</ul>
<h2 id="blocking-and-allowing"><a class="header" href="#blocking-and-allowing">Blocking and Allowing</a></h2>
<p>A component that requires <code>NetworkStatusPort</code> can block a specific IP address, Network or SystemPath. 
By triggering the request <code>BlockIp(IpAddr)</code> or <code>BlockIpNet(IpNet)</code> on <code>NetworkStatusPort</code>, all connections to <code>IpAddr</code>
will be dropped and future attempts to establish a connection will also be ignored.</p>
<p>The <code>BlockIp(IpAddr)</code> / <code>AllowIp(IpAddr)</code> / <code>BlockIpNet(IpNet)</code> / <code>AllowIpNet(IpNet)</code> are applied in the <code>NetworkThread</code>
in the order they are received and produce a single block-list. For example, allowing the <code>IpAddr</code> <code>10.0.0.1</code> and then
blocking the <code>IpNet</code> <code>10.0.0.0/24</code> means that the <code>IpAddr</code> will effectively become blocked. However, applying the same 
two operations in the reverse order means that the <code>IpAddr</code> will be allowed.</p>
<p>The <code>AllowSystem(SystemPath)</code> / <code>BlockSystem(SystemPath)</code> are somewhat different, as the <code>AllowSystem()</code> maintains a 
separate allow-list which takes precedence over the <code>IpAddr</code>/<code>IpNet</code> block-list. So if the user first calls 
<code>AllowSystem(10.0.0.1:8080)</code> and then calls <code>BlockIpNet(10.0.0.0/24)</code> the first <code>AllowSystem</code> will take precedence and
connections to the System with the <em>canonical address</em> (listening ip:port) <code>10.0.0.1:8080</code> will remain unaffected.
To undo a previously allowed system, or to block a specific <code>SystemPath</code>, one can use <code>BlockSystem(SystemPath)</code>.</p>
<p>When the network thread has successfully blocked or unblocked an <code>IpAddr</code> / <code>IpNet</code> / <code>SystemPath</code>, a <code>BlockedIp</code> /
<code>BlockedIpNet</code> / <code>BlockedSystem</code> or <code>AllowedIp</code> / <code>AllowedIpnet</code> / <code>AllowedSystem</code> indication will be triggered on the 
<code>NetworkStatusPort</code>.</p>
<h1 id="asyncawait-interaction"><a class="header" href="#asyncawait-interaction">Async/Await Interaction</a></h1>
<p>In addition to providing its own asynchronous APIs as described in the previous sections, Kompact also allows components to interact with Rust’s async/await features in a variety of manners.
In particular, Kompact provides three different semantics for this interaction:</p>
<ol>
<li>A component can “block” on a future, suspending all other processing until the result of the future is available.</li>
<li>A component can run a number of futures concurrently with other messages and events, allowing each future safe mutable access to its internal state whenever it is polled.</li>
<li>A component or Kompact system can spawn futures to run on its executor pool.</li>
</ol>
<p>The third variant is unremarkable and works like any other futures executor. It is invoked via <code>KompactSystem::spawn(...)</code> or via <code>ComponentDefinition::spawn_off(...)</code>. Variants 1 and 2, however, provide novel interactions between an asychronous API and an actor/component system, and so we will describe in more detail using an example below.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>In order to show off interaction between Kompact components and asynchronous calls, we use the asynchronous DNS resolution API provided by the <a href="https://crates.io/crates/async-std-resolver">async-std-resolver</a> crate to build a DNS lookup component. In order to tell the component what to look up, we will read domain names from stdin, send them via <code>ask(...)</code> to the component and wait for the result to come in, which we then print out. In fact, we will allow multiple concurrent queries to be specified as comma-separated list, to show off concurrent future interaction in Kompact components.</p>
<h3 id="messages-5"><a class="header" href="#messages-5">Messages</a></h3>
<p>The messages we need a very simple, we simply pass a <code>String</code> representing a single domain name as a request, and we return an already preformatted string with the resolved IPs as a response.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use async_std_resolver::{config, resolver, AsyncStdResolver};
</span><span class="boring">use dialoguer::Input;
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use trust_dns_proto::{rr::record_type::RecordType, xfer::dns_request::DnsRequestOptions};
</span><span class="boring">
</span>#[derive(Debug)]
struct DnsRequest(String);
#[derive(Debug)]
struct DnsResponse(String);
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DnsComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    resolver: Option&lt;AsyncStdResolver&gt;,
</span><span class="boring">}
</span><span class="boring">impl DnsComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DnsComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            resolver: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for DnsComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Starting...&quot;);
</span><span class="boring">        Handled::block_on(self, move |mut async_self| async move {
</span><span class="boring">            let resolver = resolver(
</span><span class="boring">                config::ResolverConfig::default(),
</span><span class="boring">                config::ResolverOpts::default(),
</span><span class="boring">            )
</span><span class="boring">            .await
</span><span class="boring">            .expect(&quot;failed to connect resolver&quot;);
</span><span class="boring">            async_self.resolver = Some(resolver);
</span><span class="boring">            debug!(async_self.log(), &quot;Started!&quot;);
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        drop(self.resolver.take());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DnsComponent {
</span><span class="boring">    type Message = Ask&lt;DnsRequest, DnsResponse&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Got request for domain: {}&quot;, msg.request().0);
</span><span class="boring">        if let Some(ref resolver) = self.resolver {
</span><span class="boring">            let query_result_future = resolver.lookup(
</span><span class="boring">                msg.request().0.clone(),
</span><span class="boring">                RecordType::A,
</span><span class="boring">                DnsRequestOptions::default(),
</span><span class="boring">            );
</span><span class="boring">            self.spawn_local(move |async_self| async move {
</span><span class="boring">                let query_result = query_result_future.await.expect(&quot;dns query result&quot;);
</span><span class="boring">                debug!(
</span><span class="boring">                    async_self.log(),
</span><span class="boring">                    &quot;Got reply for domain: {}&quot;,
</span><span class="boring">                    msg.request().0
</span><span class="boring">                );
</span><span class="boring">                let mut results: Vec&lt;String&gt; = Vec::new();
</span><span class="boring">                for (index, ip) in query_result.iter().enumerate() {
</span><span class="boring">                    results.push(format!(&quot;{}. {:?}&quot;, index, ip));
</span><span class="boring">                }
</span><span class="boring">                let result_string = format!(&quot;{}:\n   {}&quot;, msg.request().0, results.join(&quot;\n    &quot;));
</span><span class="boring">                msg.reply(DnsResponse(result_string)).expect(&quot;reply&quot;);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            });
</span><span class="boring">            Handled::Ok
</span><span class="boring">        } else {
</span><span class="boring">            panic!(&quot;Component should have been initialised first!&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;ignore networking&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let dns_comp = system.create(DnsComponent::new);
</span><span class="boring">    let dns_comp_ref = dns_comp.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">    system.start_notify(&amp;dns_comp).wait();
</span><span class="boring">    println!(&quot;System is ready, enter your queries.&quot;);
</span><span class="boring">    loop {
</span><span class="boring">        let command = Input::&lt;String&gt;::new().with_prompt(&quot;&gt;&quot;).interact();
</span><span class="boring">        match command {
</span><span class="boring">            Ok(s) =&gt; match s.as_ref() {
</span><span class="boring">                &quot;stop&quot; =&gt; break,
</span><span class="boring">                _ =&gt; {
</span><span class="boring">                    let mut outstanding = Vec::new();
</span><span class="boring">                    for domain in s.split(',') {
</span><span class="boring">                        let domain = domain.trim();
</span><span class="boring">                        info!(system.logger(), &quot;Sending request for {}&quot;, domain);
</span><span class="boring">                        let query_f = dns_comp_ref.ask(DnsRequest(domain.to_string()));
</span><span class="boring">                        outstanding.push(query_f);
</span><span class="boring">                    }
</span><span class="boring">                    for query_f in outstanding {
</span><span class="boring">                        let result = query_f.wait();
</span><span class="boring">                        info!(system.logger(), &quot;Got:\n    {}\n&quot;, result.0);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; error!(system.logger(), &quot;Error with input: {}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    system.kill_notify(dns_comp).wait();
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span></code></pre>
<h3 id="state-4"><a class="header" href="#state-4">State</a></h3>
<p>The component’s state is almost as simple, we simply require the usual component context and an instance of the asynchronous dns resolver. Since creation of that instance is performed asynchronously by the async-std-resolver library, we won’t have the instance we need available during component creation, and thus use an option indicating whether our component has already been properly initialised or not.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use async_std_resolver::{config, resolver, AsyncStdResolver};
</span><span class="boring">use dialoguer::Input;
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use trust_dns_proto::{rr::record_type::RecordType, xfer::dns_request::DnsRequestOptions};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsRequest(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsResponse(String);
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct DnsComponent {
    ctx: ComponentContext&lt;Self&gt;,
    resolver: Option&lt;AsyncStdResolver&gt;,
}
impl DnsComponent {
    pub fn new() -&gt; Self {
        DnsComponent {
            ctx: ComponentContext::uninitialised(),
            resolver: None,
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for DnsComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Starting...&quot;);
</span><span class="boring">        Handled::block_on(self, move |mut async_self| async move {
</span><span class="boring">            let resolver = resolver(
</span><span class="boring">                config::ResolverConfig::default(),
</span><span class="boring">                config::ResolverOpts::default(),
</span><span class="boring">            )
</span><span class="boring">            .await
</span><span class="boring">            .expect(&quot;failed to connect resolver&quot;);
</span><span class="boring">            async_self.resolver = Some(resolver);
</span><span class="boring">            debug!(async_self.log(), &quot;Started!&quot;);
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        drop(self.resolver.take());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DnsComponent {
</span><span class="boring">    type Message = Ask&lt;DnsRequest, DnsResponse&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Got request for domain: {}&quot;, msg.request().0);
</span><span class="boring">        if let Some(ref resolver) = self.resolver {
</span><span class="boring">            let query_result_future = resolver.lookup(
</span><span class="boring">                msg.request().0.clone(),
</span><span class="boring">                RecordType::A,
</span><span class="boring">                DnsRequestOptions::default(),
</span><span class="boring">            );
</span><span class="boring">            self.spawn_local(move |async_self| async move {
</span><span class="boring">                let query_result = query_result_future.await.expect(&quot;dns query result&quot;);
</span><span class="boring">                debug!(
</span><span class="boring">                    async_self.log(),
</span><span class="boring">                    &quot;Got reply for domain: {}&quot;,
</span><span class="boring">                    msg.request().0
</span><span class="boring">                );
</span><span class="boring">                let mut results: Vec&lt;String&gt; = Vec::new();
</span><span class="boring">                for (index, ip) in query_result.iter().enumerate() {
</span><span class="boring">                    results.push(format!(&quot;{}. {:?}&quot;, index, ip));
</span><span class="boring">                }
</span><span class="boring">                let result_string = format!(&quot;{}:\n   {}&quot;, msg.request().0, results.join(&quot;\n    &quot;));
</span><span class="boring">                msg.reply(DnsResponse(result_string)).expect(&quot;reply&quot;);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            });
</span><span class="boring">            Handled::Ok
</span><span class="boring">        } else {
</span><span class="boring">            panic!(&quot;Component should have been initialised first!&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;ignore networking&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let dns_comp = system.create(DnsComponent::new);
</span><span class="boring">    let dns_comp_ref = dns_comp.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">    system.start_notify(&amp;dns_comp).wait();
</span><span class="boring">    println!(&quot;System is ready, enter your queries.&quot;);
</span><span class="boring">    loop {
</span><span class="boring">        let command = Input::&lt;String&gt;::new().with_prompt(&quot;&gt;&quot;).interact();
</span><span class="boring">        match command {
</span><span class="boring">            Ok(s) =&gt; match s.as_ref() {
</span><span class="boring">                &quot;stop&quot; =&gt; break,
</span><span class="boring">                _ =&gt; {
</span><span class="boring">                    let mut outstanding = Vec::new();
</span><span class="boring">                    for domain in s.split(',') {
</span><span class="boring">                        let domain = domain.trim();
</span><span class="boring">                        info!(system.logger(), &quot;Sending request for {}&quot;, domain);
</span><span class="boring">                        let query_f = dns_comp_ref.ask(DnsRequest(domain.to_string()));
</span><span class="boring">                        outstanding.push(query_f);
</span><span class="boring">                    }
</span><span class="boring">                    for query_f in outstanding {
</span><span class="boring">                        let result = query_f.wait();
</span><span class="boring">                        info!(system.logger(), &quot;Got:\n    {}\n&quot;, result.0);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; error!(system.logger(), &quot;Error with input: {}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    system.kill_notify(dns_comp).wait();
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span></code></pre>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>When we create a resolver instance via <code>async_std_resolver::resolver</code>, we actually get a future back that we need to wait for. But our DNS component can’t perform any lookups until this future completed. Normally, we would have to manually queue up all requests received during that period until the future completed and then replay them. Instead, we can “block” on the provided future, causing the component itself to enter into a <code>blocked</code> lifecycle state, during which it handles no messages or events. Only when the future’s result is available will the component enter the <code>active</code> state and process other events and messages as normal again.</p>
<p>In order to enter the <code>blocked</code> state, we must return a a special variant of the <code>Handled</code> enum, which is obtained from the <code>Handled::block_on(...)</code> method. This method takes the <code>self</code> reference to the component and an asynchronous closure, that is a closure that produces a future when invoked. This closure is given a single parameter by the Kompact API, which is an access guard object to a mutable component reference. In order words, a special owned struct that can be mutably dereferenced to the current component definition type. This guard object ensures safe mutable access to the current component instance, whenever the resulting future is polled, but prevents holding on to actual references over <code>await</code> calls (which are illegal). It is very important that this guard object is <strong>never</strong> sent to another thread from within the future. The async closure can not directly close over the component’s <code>self</code> reference, as the correct lifetime for it can not be guaranteed. Only the references obtained from the special guard object are safe in between <code>await</code> calls.</p>
<p>Having said all that, in our case the async closure very simply <code>await</code>s the result of the resolver creation and then stores it locally, after which the component unblocks.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use async_std_resolver::{config, resolver, AsyncStdResolver};
</span><span class="boring">use dialoguer::Input;
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use trust_dns_proto::{rr::record_type::RecordType, xfer::dns_request::DnsRequestOptions};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsRequest(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsResponse(String);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DnsComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    resolver: Option&lt;AsyncStdResolver&gt;,
</span><span class="boring">}
</span><span class="boring">impl DnsComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DnsComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            resolver: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for DnsComponent {
    fn on_start(&amp;mut self) -&gt; Handled {
        debug!(self.log(), &quot;Starting...&quot;);
        Handled::block_on(self, move |mut async_self| async move {
            let resolver = resolver(
                config::ResolverConfig::default(),
                config::ResolverOpts::default(),
            )
            .await
            .expect(&quot;failed to connect resolver&quot;);
            async_self.resolver = Some(resolver);
            debug!(async_self.log(), &quot;Started!&quot;);
        })
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        drop(self.resolver.take());
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">impl Actor for DnsComponent {
</span><span class="boring">    type Message = Ask&lt;DnsRequest, DnsResponse&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Got request for domain: {}&quot;, msg.request().0);
</span><span class="boring">        if let Some(ref resolver) = self.resolver {
</span><span class="boring">            let query_result_future = resolver.lookup(
</span><span class="boring">                msg.request().0.clone(),
</span><span class="boring">                RecordType::A,
</span><span class="boring">                DnsRequestOptions::default(),
</span><span class="boring">            );
</span><span class="boring">            self.spawn_local(move |async_self| async move {
</span><span class="boring">                let query_result = query_result_future.await.expect(&quot;dns query result&quot;);
</span><span class="boring">                debug!(
</span><span class="boring">                    async_self.log(),
</span><span class="boring">                    &quot;Got reply for domain: {}&quot;,
</span><span class="boring">                    msg.request().0
</span><span class="boring">                );
</span><span class="boring">                let mut results: Vec&lt;String&gt; = Vec::new();
</span><span class="boring">                for (index, ip) in query_result.iter().enumerate() {
</span><span class="boring">                    results.push(format!(&quot;{}. {:?}&quot;, index, ip));
</span><span class="boring">                }
</span><span class="boring">                let result_string = format!(&quot;{}:\n   {}&quot;, msg.request().0, results.join(&quot;\n    &quot;));
</span><span class="boring">                msg.reply(DnsResponse(result_string)).expect(&quot;reply&quot;);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            });
</span><span class="boring">            Handled::Ok
</span><span class="boring">        } else {
</span><span class="boring">            panic!(&quot;Component should have been initialised first!&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;ignore networking&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let dns_comp = system.create(DnsComponent::new);
</span><span class="boring">    let dns_comp_ref = dns_comp.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">    system.start_notify(&amp;dns_comp).wait();
</span><span class="boring">    println!(&quot;System is ready, enter your queries.&quot;);
</span><span class="boring">    loop {
</span><span class="boring">        let command = Input::&lt;String&gt;::new().with_prompt(&quot;&gt;&quot;).interact();
</span><span class="boring">        match command {
</span><span class="boring">            Ok(s) =&gt; match s.as_ref() {
</span><span class="boring">                &quot;stop&quot; =&gt; break,
</span><span class="boring">                _ =&gt; {
</span><span class="boring">                    let mut outstanding = Vec::new();
</span><span class="boring">                    for domain in s.split(',') {
</span><span class="boring">                        let domain = domain.trim();
</span><span class="boring">                        info!(system.logger(), &quot;Sending request for {}&quot;, domain);
</span><span class="boring">                        let query_f = dns_comp_ref.ask(DnsRequest(domain.to_string()));
</span><span class="boring">                        outstanding.push(query_f);
</span><span class="boring">                    }
</span><span class="boring">                    for query_f in outstanding {
</span><span class="boring">                        let result = query_f.wait();
</span><span class="boring">                        info!(system.logger(), &quot;Got:\n    {}\n&quot;, result.0);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; error!(system.logger(), &quot;Error with input: {}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    system.kill_notify(dns_comp).wait();
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> The complicated looking <code>move |async_self| async move {...}</code> syntax is currently only necessary on stable Rust. On nightly, the much easier <code>async move |async_self| {...}</code> syntax is already available.</p>
</blockquote>
<h3 id="queries"><a class="header" href="#queries">Queries</a></h3>
<p>To handle queries we must call <code>lookup(...)</code> on the resolver, which returns a future of a dns lookup result, which we must await before replying to the actual request. As we want to handle multiple such outstanding lookups in parallel, we can’t simply block on this future as we did before. Instead we want to spawn the future, to run locally on the component whenever it is polled, via <code>ComponentDefinition::spawn_local(...)</code>. In this way, we have the same advantages as during blocking, but we can handle mutliple outstanding requests in parallel. Technically, except for some logging, we do not really need access to the component’s state in this particular case, but we will use it anyway to showcase the API.</p>
<p>Since the result of a DNS query can consist of multiple IP addresses, we construct a single string by formatting them together with the domain into an enumerated list. We then return that string a reply to the original request.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use async_std_resolver::{config, resolver, AsyncStdResolver};
</span><span class="boring">use dialoguer::Input;
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use trust_dns_proto::{rr::record_type::RecordType, xfer::dns_request::DnsRequestOptions};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsRequest(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsResponse(String);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DnsComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    resolver: Option&lt;AsyncStdResolver&gt;,
</span><span class="boring">}
</span><span class="boring">impl DnsComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DnsComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            resolver: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for DnsComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Starting...&quot;);
</span><span class="boring">        Handled::block_on(self, move |mut async_self| async move {
</span><span class="boring">            let resolver = resolver(
</span><span class="boring">                config::ResolverConfig::default(),
</span><span class="boring">                config::ResolverOpts::default(),
</span><span class="boring">            )
</span><span class="boring">            .await
</span><span class="boring">            .expect(&quot;failed to connect resolver&quot;);
</span><span class="boring">            async_self.resolver = Some(resolver);
</span><span class="boring">            debug!(async_self.log(), &quot;Started!&quot;);
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        drop(self.resolver.take());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Actor for DnsComponent {
    type Message = Ask&lt;DnsRequest, DnsResponse&gt;;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        debug!(self.log(), &quot;Got request for domain: {}&quot;, msg.request().0);
        if let Some(ref resolver) = self.resolver {
            let query_result_future = resolver.lookup(
                msg.request().0.clone(),
                RecordType::A,
                DnsRequestOptions::default(),
            );
            self.spawn_local(move |async_self| async move {
                let query_result = query_result_future.await.expect(&quot;dns query result&quot;);
                debug!(
                    async_self.log(),
                    &quot;Got reply for domain: {}&quot;,
                    msg.request().0
                );
                let mut results: Vec&lt;String&gt; = Vec::new();
                for (index, ip) in query_result.iter().enumerate() {
                    results.push(format!(&quot;{}. {:?}&quot;, index, ip));
                }
                let result_string = format!(&quot;{}:\n   {}&quot;, msg.request().0, results.join(&quot;\n    &quot;));
                msg.reply(DnsResponse(result_string)).expect(&quot;reply&quot;);
                Handled::Ok
            });
            Handled::Ok
        } else {
            panic!(&quot;Component should have been initialised first!&quot;)
        }
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;ignore networking&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let dns_comp = system.create(DnsComponent::new);
</span><span class="boring">    let dns_comp_ref = dns_comp.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">    system.start_notify(&amp;dns_comp).wait();
</span><span class="boring">    println!(&quot;System is ready, enter your queries.&quot;);
</span><span class="boring">    loop {
</span><span class="boring">        let command = Input::&lt;String&gt;::new().with_prompt(&quot;&gt;&quot;).interact();
</span><span class="boring">        match command {
</span><span class="boring">            Ok(s) =&gt; match s.as_ref() {
</span><span class="boring">                &quot;stop&quot; =&gt; break,
</span><span class="boring">                _ =&gt; {
</span><span class="boring">                    let mut outstanding = Vec::new();
</span><span class="boring">                    for domain in s.split(',') {
</span><span class="boring">                        let domain = domain.trim();
</span><span class="boring">                        info!(system.logger(), &quot;Sending request for {}&quot;, domain);
</span><span class="boring">                        let query_f = dns_comp_ref.ask(DnsRequest(domain.to_string()));
</span><span class="boring">                        outstanding.push(query_f);
</span><span class="boring">                    }
</span><span class="boring">                    for query_f in outstanding {
</span><span class="boring">                        let result = query_f.wait();
</span><span class="boring">                        info!(system.logger(), &quot;Got:\n    {}\n&quot;, result.0);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; error!(system.logger(), &quot;Error with input: {}&quot;, e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    system.kill_notify(dns_comp).wait();
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span></code></pre>
<h3 id="running-1"><a class="header" href="#running-1">Running</a></h3>
<p>In our <code>main</code> function we want to set up the component, and then read from the command line over and over until the user enters <code>&quot;stop&quot;</code> to end the loop. For each line we read that is not <code>&quot;stop&quot;</code>, we will simply assume that it a comma-separated list of domain names. We split them apart, remove unnecessary spaces and then send them one by one to the <code>DNSComponent</code> via <code>ask(...)</code>. Instead of waiting for each future immediately, we store the response futures until all requests have been sent, and only <em>then</em> do we wait for each of them in order. We could also have waited for them in the order they are replied to, instead, it doesn’t really matter in this case. Only when the last of them has been completed, do we read input again.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use async_std_resolver::{config, resolver, AsyncStdResolver};
</span><span class="boring">use dialoguer::Input;
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use trust_dns_proto::{rr::record_type::RecordType, xfer::dns_request::DnsRequestOptions};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsRequest(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DnsResponse(String);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct DnsComponent {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    resolver: Option&lt;AsyncStdResolver&gt;,
</span><span class="boring">}
</span><span class="boring">impl DnsComponent {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DnsComponent {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            resolver: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for DnsComponent {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Starting...&quot;);
</span><span class="boring">        Handled::block_on(self, move |mut async_self| async move {
</span><span class="boring">            let resolver = resolver(
</span><span class="boring">                config::ResolverConfig::default(),
</span><span class="boring">                config::ResolverOpts::default(),
</span><span class="boring">            )
</span><span class="boring">            .await
</span><span class="boring">            .expect(&quot;failed to connect resolver&quot;);
</span><span class="boring">            async_self.resolver = Some(resolver);
</span><span class="boring">            debug!(async_self.log(), &quot;Started!&quot;);
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        drop(self.resolver.take());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for DnsComponent {
</span><span class="boring">    type Message = Ask&lt;DnsRequest, DnsResponse&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        debug!(self.log(), &quot;Got request for domain: {}&quot;, msg.request().0);
</span><span class="boring">        if let Some(ref resolver) = self.resolver {
</span><span class="boring">            let query_result_future = resolver.lookup(
</span><span class="boring">                msg.request().0.clone(),
</span><span class="boring">                RecordType::A,
</span><span class="boring">                DnsRequestOptions::default(),
</span><span class="boring">            );
</span><span class="boring">            self.spawn_local(move |async_self| async move {
</span><span class="boring">                let query_result = query_result_future.await.expect(&quot;dns query result&quot;);
</span><span class="boring">                debug!(
</span><span class="boring">                    async_self.log(),
</span><span class="boring">                    &quot;Got reply for domain: {}&quot;,
</span><span class="boring">                    msg.request().0
</span><span class="boring">                );
</span><span class="boring">                let mut results: Vec&lt;String&gt; = Vec::new();
</span><span class="boring">                for (index, ip) in query_result.iter().enumerate() {
</span><span class="boring">                    results.push(format!(&quot;{}. {:?}&quot;, index, ip));
</span><span class="boring">                }
</span><span class="boring">                let result_string = format!(&quot;{}:\n   {}&quot;, msg.request().0, results.join(&quot;\n    &quot;));
</span><span class="boring">                msg.reply(DnsResponse(result_string)).expect(&quot;reply&quot;);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            });
</span><span class="boring">            Handled::Ok
</span><span class="boring">        } else {
</span><span class="boring">            panic!(&quot;Component should have been initialised first!&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;ignore networking&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let dns_comp = system.create(DnsComponent::new);
    let dns_comp_ref = dns_comp.actor_ref().hold().expect(&quot;live&quot;);
    system.start_notify(&amp;dns_comp).wait();
    println!(&quot;System is ready, enter your queries.&quot;);
    loop {
        let command = Input::&lt;String&gt;::new().with_prompt(&quot;&gt;&quot;).interact();
        match command {
            Ok(s) =&gt; match s.as_ref() {
                &quot;stop&quot; =&gt; break,
                _ =&gt; {
                    let mut outstanding = Vec::new();
                    for domain in s.split(',') {
                        let domain = domain.trim();
                        info!(system.logger(), &quot;Sending request for {}&quot;, domain);
                        let query_f = dns_comp_ref.ask(DnsRequest(domain.to_string()));
                        outstanding.push(query_f);
                    }
                    for query_f in outstanding {
                        let result = query_f.wait();
                        info!(system.logger(), &quot;Got:\n    {}\n&quot;, result.0);
                    }
                }
            },
            Err(e) =&gt; error!(system.logger(), &quot;Error with input: {}&quot;, e),
        }
    }
    system.kill_notify(dns_comp).wait();
    system.shutdown().expect(&quot;shutdown&quot;);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> If you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> and are trying to run from there, you need to specify the concrete binary with:</p>
<pre><code class="language-bash">cargo run --bin dns_resolver
</code></pre>
</blockquote>
<h1 id="project-info"><a class="header" href="#project-info">Project Info</a></h1>
<p>While Kompact is primarily being developed at the <a href="https://www.kth.se/en">KTH Royal Institute of Technology</a> and at <a href="https://www.ri.se/en">RISE Research Institutes of Sweden</a> in Stockholm, Sweden, we do wish to thank all <a href="https://github.com/kompics/kompact/graphs/contributors">contributors</a>.</p>
<h2 id="releases"><a class="header" href="#releases">Releases</a></h2>
<p>Kompact releases are hosted on <a href="https://crates.io/crates/kompact">crates.io</a>.</p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>Kompact API docs are hosted on <a href="https://docs.rs/kompact/latest/kompact/">docs.rs</a>.</p>
<h2 id="sources--issues"><a class="header" href="#sources--issues">Sources &amp; Issues</a></h2>
<p>The sources for Kompact can be found on <a href="https://github.com/kompics/kompact">Github</a>.</p>
<p>All issues and requests related to Kompact should be posted there.</p>
<h2 id="bleeding-edge"><a class="header" href="#bleeding-edge">Bleeding Edge</a></h2>
<p>This tutorial is built off the <code>master</code> branch on github and thus tends to be a bit ahead of what is available in a release.
If you would like to try out new features before they are released, you can add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">kompact = { git = &quot;https://github.com/kompics/kompact&quot;, branch = &quot;master&quot; }
</code></pre>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p>If you need the API docs for the latest master run the following at an appropriate location (e.g., outside another local git repository):</p>
<pre><code class="language-bash">git checkout https://github.com/kompics/kompact
cd kompact/core/
cargo doc --open --no-deps
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
