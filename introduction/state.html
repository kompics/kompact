<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Internal State - The Kompact Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the Kompact actor-component-hybrid systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="../getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="../introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/components.html"><strong aria-hidden="true">1.1.</strong> Components</a></li><li class="chapter-item expanded "><a href="../introduction/actors.html"><strong aria-hidden="true">1.2.</strong> Actors</a></li><li class="chapter-item expanded "><a href="../introduction/state.html" class="active"><strong aria-hidden="true">1.3.</strong> Internal State</a></li></ol></li><li class="chapter-item expanded "><a href="../local/index.html"><strong aria-hidden="true">2.</strong> Local Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../local/communication/index.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../local/communication/messagesandevents.html"><strong aria-hidden="true">2.1.1.</strong> Messages and Events</a></li><li class="chapter-item expanded "><a href="../local/communication/state.html"><strong aria-hidden="true">2.1.2.</strong> State</a></li><li class="chapter-item expanded "><a href="../local/communication/handlers.html"><strong aria-hidden="true">2.1.3.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="../local/communication/ask.html"><strong aria-hidden="true">2.1.4.</strong> Ask</a></li><li class="chapter-item expanded "><a href="../local/communication/system.html"><strong aria-hidden="true">2.1.5.</strong> System</a></li><li class="chapter-item expanded "><a href="../local/communication/senders.html"><strong aria-hidden="true">2.1.6.</strong> Senders</a></li></ol></li><li class="chapter-item expanded "><a href="../local/timers.html"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../local/schedulers.html"><strong aria-hidden="true">2.3.</strong> Schedulers</a></li><li class="chapter-item expanded "><a href="../local/logging.html"><strong aria-hidden="true">2.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../local/configuration.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../local/faultrecovery.html"><strong aria-hidden="true">2.6.</strong> Fault Recovery</a></li><li class="chapter-item expanded "><a href="../local/dynamic-components.html"><strong aria-hidden="true">2.7.</strong> Dynamic Components</a></li></ol></li><li class="chapter-item expanded "><a href="../distributed/index.html"><strong aria-hidden="true">3.</strong> Distributed Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../distributed/basiccommunication.html"><strong aria-hidden="true">3.1.</strong> Basic Communication</a></li><li class="chapter-item expanded "><a href="../distributed/namedservices.html"><strong aria-hidden="true">3.2.</strong> Named Services</a></li><li class="chapter-item expanded "><a href="../distributed/pathrouting.html"><strong aria-hidden="true">3.3.</strong> Path Routing</a></li><li class="chapter-item expanded "><a href="../distributed/serialisation.html"><strong aria-hidden="true">3.4.</strong> Serialisation</a></li><li class="chapter-item expanded "><a href="../distributed/networkbuffers.html"><strong aria-hidden="true">3.5.</strong> Configuring Buffers</a></li><li class="chapter-item expanded "><a href="../distributed/networkstatusport.html"><strong aria-hidden="true">3.6.</strong> Network Status Port</a></li></ol></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">4.</strong> Async/Await Interaction</a></li><li class="chapter-item expanded affix "><a href="../project.html">Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Kompact Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/kompics/kompact" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="internal-state"><a class="header" href="#internal-state">Internal State</a></h1>
<p>Now that we have looked at the fundamental ideas of components and actors in isolation, let us look at something both our models share: The idea that every component/actor has its own internal state, which it has exclusive access to, without the need for synchronisation.</p>
<p>Access to internal state is what separates our components from being simple producers and consumers of messages and events, and makes them a powerful abstraction to build complicated systems, services, and applications with. But so far, our examples have not used any internal state at all – they simply terminated after the first event or message. In this chapter we will build something slightly less boring: a “Counter”.</p>
<h2 id="a-counter-example"><a class="header" href="#a-counter-example">A Counter Example</a></h2>
<p>(The pun in the title is mostly intended ;)</p>
<p>In this example we will make use of the simplest of state variables, that is integer counters. We count both messages and events separately, to see how the models work together. Since state that is never read is totally useless, we will also allow the counters to be queried. In fact, we will simply consider any update also a query and always respond with the current count.</p>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>First we need to set up the message types and ports:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>#[derive(Clone, Debug, PartialEq, Eq)]
struct CurrentCount {
    messages: u64,
    events: u64,
}
#[derive(Clone, Debug, PartialEq, Eq)]
struct CountMe;

struct CounterPort;
impl Port for CounterPort {
    type Indication = CurrentCount;
    type Request = CountMe;
}
<span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We will use the same types both for the port and actor communication, so <code>CountMe</code> and <code>CurrentCount</code> are both events and messages.
Since we want to provide a counter <em>service</em>, we’ll say that <code>CountMe</code> is going to be a <em>request</em> on the <code>CounterPort</code>, and <code>CurrentCount</code> is considered an <em>indication</em>. We could also design things the other way around, but this way it matches better with our “service” metaphor.</p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>Our internal state is going to be the two counters, plus the component context and a <em>provided</em> port instance for <code>CounterPort</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Counter {
    ctx: ComponentContext&lt;Self&gt;,
    counter_port: ProvidedPort&lt;CounterPort&gt;,
    msg_count: u64,
    event_count: u64,
}
impl Counter {
    pub fn new() -&gt; Self {
        Counter {
            ctx: ComponentContext::uninitialised(),
            counter_port: ProvidedPort::uninitialised(),
            msg_count: 0u64,
            event_count: 0u64,
        }
    }

    fn current_count(&amp;self) -&gt; CurrentCount {
        CurrentCount {
            messages: self.msg_count,
            events: self.event_count,
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also added a quick <code>current_count()</code> function, which access our internal state constructs a <code>CurrentCount</code> instance from it. This way, we can reuse the function for both event and message handling.</p>
<h3 id="counting-stuff"><a class="header" href="#counting-stuff">Counting Stuff</a></h3>
<p>In addition to counting the <code>CountMe</code> events and messages, we will also count control events incoming at the <code>ControlPort</code>. However, we will not respond to those. As mentioned previously, control events are handled indirectly via the <code>ComponentLifecycle</code> trait. On the other hand, for every <code>CountMe</code> event we will respond with the current state of both counters.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Counter {
    fn on_start(&amp;mut self) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a start event!&quot;);
        self.event_count += 1u64;
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
        self.event_count += 1u64;
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
        self.event_count += 1u64;
        Handled::Ok
    }
}

impl Provide&lt;CounterPort&gt; for Counter {
    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
        self.event_count += 1u64;
        self.counter_port.trigger(self.current_count());
        Handled::Ok
    }
}

impl Actor for Counter {
    type Message = Ask&lt;CountMe, CurrentCount&gt;;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        msg.complete(|_request| {
            info!(self.ctx.log(), &quot;Got a message!&quot;);
            self.msg_count += 1u64;
            self.current_count()
        })
        .expect(&quot;complete&quot;);
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;We are still ignoring network messages.&quot;);
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let counter = system.create(Counter::new);
</span><span class="boring">    system.start(&amp;counter);
</span><span class="boring">    let actor_ref = counter.actor_ref();
</span><span class="boring">    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
</span><span class="boring">    }
</span><span class="boring">    for _i in 0..100 {
</span><span class="boring">        system.trigger_r(CountMe, &amp;port_ref);
</span><span class="boring">        // Where do the answers go?
</span><span class="boring">    }
</span><span class="boring">    std::thread::sleep(Duration::from_millis(1000));
</span><span class="boring">    let current_count = actor_ref.ask(CountMe).wait();
</span><span class="boring">    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
</span><span class="boring">    std::thread::sleep(Duration::from_millis(10));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In the Kompics-style communication, we reply by simply triggering the <code>CurrentCount</code> event on our <code>counter_port</code> to whoever may listen. In the Actor-style, we need to know some reference to respond to. Since we are not responding to another component, but to the main-thread, we will use the <code>Ask</code>-pattern provided by Kompact, which converts our response message into a future that can be blocked on, until the result is available. We will describe this pattern in more detail in a <a href="../local/communication/ask.html">later section</a>.</p>
<h3 id="sending-stuff"><a class="header" href="#sending-stuff">Sending Stuff</a></h3>
<p>In order to count something, we must of course send some events and messages. We could do so in Actor-style by using <code>tell(...)</code> as before, but this time we want to wait for a response as well. So instead we will use <code>ask(...)</code> to automatically wrap our <code>CountMe</code> into an <code>Ask</code> instance as required by our actor’s implementation. In the Kompics-style, we can trigger on a port reference using <code>system.trigger_r(...)</code> instead. Whenever we get a response, we print it using the system’s logger:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CurrentCount {
</span><span class="boring">    messages: u64,
</span><span class="boring">    events: u64,
</span><span class="boring">}
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">struct CountMe;
</span><span class="boring">
</span><span class="boring">struct CounterPort;
</span><span class="boring">impl Port for CounterPort {
</span><span class="boring">    type Indication = CurrentCount;
</span><span class="boring">    type Request = CountMe;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Counter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    counter_port: ProvidedPort&lt;CounterPort&gt;,
</span><span class="boring">    msg_count: u64,
</span><span class="boring">    event_count: u64,
</span><span class="boring">}
</span><span class="boring">impl Counter {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Counter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            counter_port: ProvidedPort::uninitialised(),
</span><span class="boring">            msg_count: 0u64,
</span><span class="boring">            event_count: 0u64,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_count(&amp;self) -&gt; CurrentCount {
</span><span class="boring">        CurrentCount {
</span><span class="boring">            messages: self.msg_count,
</span><span class="boring">            events: self.event_count,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Counter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a start event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a stop event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a kill event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;CounterPort&gt; for Counter {
</span><span class="boring">    fn handle(&amp;mut self, _event: CountMe) -&gt; Handled {
</span><span class="boring">        info!(self.ctx.log(), &quot;Got a counter event!&quot;);
</span><span class="boring">        self.event_count += 1u64;
</span><span class="boring">        self.counter_port.trigger(self.current_count());
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Actor for Counter {
</span><span class="boring">    type Message = Ask&lt;CountMe, CurrentCount&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        msg.complete(|_request| {
</span><span class="boring">            info!(self.ctx.log(), &quot;Got a message!&quot;);
</span><span class="boring">            self.msg_count += 1u64;
</span><span class="boring">            self.current_count()
</span><span class="boring">        })
</span><span class="boring">        .expect(&quot;complete&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;We are still ignoring network messages.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let counter = system.create(Counter::new);
    system.start(&amp;counter);
    let actor_ref = counter.actor_ref();
    let port_ref: ProvidedRef&lt;CounterPort&gt; = counter.provided_ref();
    for _i in 0..100 {
        let current_count = actor_ref.ask(CountMe).wait();
        info!(system.logger(), &quot;The current count is: {:?}&quot;, current_count);
    }
    for _i in 0..100 {
        system.trigger_r(CountMe, &amp;port_ref);
        // Where do the answers go?
    }
    std::thread::sleep(Duration::from_millis(1000));
    let current_count = actor_ref.ask(CountMe).wait();
    info!(system.logger(), &quot;The final count is: {:?}&quot;, current_count);
    system.shutdown().expect(&quot;shutdown&quot;);
    // Wait a bit longer, so all output is logged (asynchronously) before shutting down
    std::thread::sleep(Duration::from_millis(10));
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_counters() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>There are two things worth noting here:</p>
<ol>
<li>We are never getting any responses from the Kompics-style communication. There simply isn’t anything subscribed to our port, so the responses we are sending are simply dropped immediately. Kompact does not provide an <code>Ask</code>-equivalent for ports, since maintaining two mechanisms to achieve the same effect is inefficient, and this communication pattern is very unusual for the Kompics model.</li>
<li>We are also not getting any feedback when the events sent to the port are being handled. In order to see them being handled at all, we added a <code>thread::sleep(...)</code> invocation there. Events and messages in Kompact do <strong>not</strong> share the same queues and there are no ordering guarantees between them. Quite the opposite, in fact: Kompact ensures a certain amount of fairness between the two mechanisms and by the default will try to handle one message for every event it handles. Thus, without the sleep, we would see between one (the start event) and 101 events being counted when the final <code>Ask</code> returns. Even like this, it’s not guaranteed that any or all events are handled before the sleep expires. It’s just very likely, if your computer isn’t terribly slow.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin counters
</code></pre>
</blockquote>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>We have shown how Kompact handles internal state, and that it is automatically shared between the two different communication styles Kompact provides.</p>
<p>We have also seen, that there are no ordering guarantees between ports and message communication, something that is also true among different ports on the same component. It is thus important to remember that for applications, that require a certain sequence of events to be processed before proceeding, verifying completion must happen through the same communication style and even through the same port.</p>
<p>We will go through all the new parts introduced in this chapter again in detail in the following sections.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../introduction/actors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../local/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../introduction/actors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../local/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
