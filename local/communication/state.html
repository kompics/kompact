<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>State - The Kompact Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the Kompact actor-component-hybrid systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="../../getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="../../introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../introduction/components.html"><strong aria-hidden="true">1.1.</strong> Components</a></li><li class="chapter-item expanded "><a href="../../introduction/actors.html"><strong aria-hidden="true">1.2.</strong> Actors</a></li><li class="chapter-item expanded "><a href="../../introduction/state.html"><strong aria-hidden="true">1.3.</strong> Internal State</a></li></ol></li><li class="chapter-item expanded "><a href="../../local/index.html"><strong aria-hidden="true">2.</strong> Local Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../local/communication/index.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../local/communication/messagesandevents.html"><strong aria-hidden="true">2.1.1.</strong> Messages and Events</a></li><li class="chapter-item expanded "><a href="../../local/communication/state.html" class="active"><strong aria-hidden="true">2.1.2.</strong> State</a></li><li class="chapter-item expanded "><a href="../../local/communication/handlers.html"><strong aria-hidden="true">2.1.3.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="../../local/communication/ask.html"><strong aria-hidden="true">2.1.4.</strong> Ask</a></li><li class="chapter-item expanded "><a href="../../local/communication/system.html"><strong aria-hidden="true">2.1.5.</strong> System</a></li><li class="chapter-item expanded "><a href="../../local/communication/senders.html"><strong aria-hidden="true">2.1.6.</strong> Senders</a></li></ol></li><li class="chapter-item expanded "><a href="../../local/timers.html"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../local/schedulers.html"><strong aria-hidden="true">2.3.</strong> Schedulers</a></li><li class="chapter-item expanded "><a href="../../local/logging.html"><strong aria-hidden="true">2.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../../local/configuration.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../../local/faultrecovery.html"><strong aria-hidden="true">2.6.</strong> Fault Recovery</a></li><li class="chapter-item expanded "><a href="../../local/dynamic-components.html"><strong aria-hidden="true">2.7.</strong> Dynamic Components</a></li></ol></li><li class="chapter-item expanded "><a href="../../distributed/index.html"><strong aria-hidden="true">3.</strong> Distributed Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../distributed/basiccommunication.html"><strong aria-hidden="true">3.1.</strong> Basic Communication</a></li><li class="chapter-item expanded "><a href="../../distributed/namedservices.html"><strong aria-hidden="true">3.2.</strong> Named Services</a></li><li class="chapter-item expanded "><a href="../../distributed/pathrouting.html"><strong aria-hidden="true">3.3.</strong> Path Routing</a></li><li class="chapter-item expanded "><a href="../../distributed/serialisation.html"><strong aria-hidden="true">3.4.</strong> Serialisation</a></li><li class="chapter-item expanded "><a href="../../distributed/networkbuffers.html"><strong aria-hidden="true">3.5.</strong> Configuring Buffers</a></li><li class="chapter-item expanded "><a href="../../distributed/networkstatusport.html"><strong aria-hidden="true">3.6.</strong> Network Status Port</a></li></ol></li><li class="chapter-item expanded "><a href="../../async/index.html"><strong aria-hidden="true">4.</strong> Async/Await Interaction</a></li><li class="chapter-item expanded affix "><a href="../../project.html">Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Kompact Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/kompics/kompact" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="state"><a class="header" href="#state">State</a></h1>
<p>Of course, we are going to need some component state to make this aggregation pool work out correctly.</p>
<h2 id="worker"><a class="header" href="#worker">Worker</a></h2>
<p>Our workers are pretty much stateless, apart from the component context and the <em>provided</em> <code>WorkerPort</code> instance. Both of these fields, we always simply initialise with the <code>new()</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Worker {
    ctx: ComponentContext&lt;Self&gt;,
    worker_port: ProvidedPort&lt;WorkerPort&gt;,
}
impl Worker {
    fn new() -&gt; Self {
        Worker {
            ctx: ComponentContext::uninitialised(),
            worker_port: ProvidedPort::uninitialised(),
        }
    }
}
<span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="manager"><a class="header" href="#manager">Manager</a></h2>
<p>The manager is a bit more complicated, of course. First of all it needs to know how many workers to start in the first place, and then keep track of all their instances (<code>Arc&lt;Component&lt;Worker&gt;&gt;</code>), so it can shut them down again later. We will also have the manager hang on to some actor references for each worker, so we don’t have to create a new one from the instances later. In fact, we will hold on to strong references (<code>ActorRefStrong&lt;WorkPart&gt;</code>), since we know the workers are not going to be deallocated anyway until we remove them from our vector of instances. </p>
<blockquote>
<p><strong>Note:</strong> Strong actor references are a bit more efficient than weak ones (<code>ActorRef&lt;_&gt;</code>), as they avoid upgrading some internal <code>std::sync::Weak</code> instances to <code>std::sync::Arc</code> instances on every message. However, they prevent deallocation of the target components, and should thus be used with care in dynamic Kompact systems.</p>
</blockquote>
<p>Additionally, we need to keep track of which request, if any, we are currently working on, so we can answer it later. We’ll make our lives easy for now, and only deal with one request at a time, but this mechanism can easily be extended for multiple outstanding requests with some additional bookkeeping.</p>
<p>We also need to put the partial results from each worker somewhere and figure out when we have seen all results, so we can combine them and reply to the request. We could simply keep a single <code>u64</code> accumulator value around, into which we always merge as soon as we get a result from a worker. In that case, we would also need a field to keep track of how many responses we have already received, so we know when we are done. Since we won’t have too many workers, however, we will simply put all results into a vector, and consider ourselves to be done when the vector contains <code>number_of_workers + 1</code> entries (we’ll get back to the <code>+1</code> part later).</p>
<p>And finally, of course, we also need a component context and we need to <em>require</em> the <code>WorkerPort</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ComponentDefinition)]
struct Manager {
    ctx: ComponentContext&lt;Self&gt;,
    worker_port: RequiredPort&lt;WorkerPort&gt;,
    num_workers: usize,
    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
    result_accumulator: Vec&lt;u64&gt;,
}
impl Manager {
    fn new(num_workers: usize) -&gt; Self {
        Manager {
            ctx: ComponentContext::uninitialised(),
            worker_port: RequiredPort::uninitialised(),
            num_workers,
            workers: Vec::with_capacity(num_workers),
            worker_refs: Vec::with_capacity(num_workers),
            outstanding_request: None,
            result_accumulator: Vec::with_capacity(num_workers + 1),
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(work).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../local/communication/messagesandevents.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../local/communication/handlers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../local/communication/messagesandevents.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../local/communication/handlers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
