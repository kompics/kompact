<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Timers - The Kompact Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the Kompact actor-component-hybrid systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="../getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="../introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/components.html"><strong aria-hidden="true">1.1.</strong> Components</a></li><li class="chapter-item expanded "><a href="../introduction/actors.html"><strong aria-hidden="true">1.2.</strong> Actors</a></li><li class="chapter-item expanded "><a href="../introduction/state.html"><strong aria-hidden="true">1.3.</strong> Internal State</a></li></ol></li><li class="chapter-item expanded "><a href="../local/index.html"><strong aria-hidden="true">2.</strong> Local Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../local/communication/index.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../local/communication/messagesandevents.html"><strong aria-hidden="true">2.1.1.</strong> Messages and Events</a></li><li class="chapter-item expanded "><a href="../local/communication/state.html"><strong aria-hidden="true">2.1.2.</strong> State</a></li><li class="chapter-item expanded "><a href="../local/communication/handlers.html"><strong aria-hidden="true">2.1.3.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="../local/communication/ask.html"><strong aria-hidden="true">2.1.4.</strong> Ask</a></li><li class="chapter-item expanded "><a href="../local/communication/system.html"><strong aria-hidden="true">2.1.5.</strong> System</a></li><li class="chapter-item expanded "><a href="../local/communication/senders.html"><strong aria-hidden="true">2.1.6.</strong> Senders</a></li></ol></li><li class="chapter-item expanded "><a href="../local/timers.html" class="active"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../local/schedulers.html"><strong aria-hidden="true">2.3.</strong> Schedulers</a></li><li class="chapter-item expanded "><a href="../local/logging.html"><strong aria-hidden="true">2.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../local/configuration.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../local/faultrecovery.html"><strong aria-hidden="true">2.6.</strong> Fault Recovery</a></li><li class="chapter-item expanded "><a href="../local/dynamic-components.html"><strong aria-hidden="true">2.7.</strong> Dynamic Components</a></li></ol></li><li class="chapter-item expanded "><a href="../distributed/index.html"><strong aria-hidden="true">3.</strong> Distributed Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../distributed/basiccommunication.html"><strong aria-hidden="true">3.1.</strong> Basic Communication</a></li><li class="chapter-item expanded "><a href="../distributed/namedservices.html"><strong aria-hidden="true">3.2.</strong> Named Services</a></li><li class="chapter-item expanded "><a href="../distributed/pathrouting.html"><strong aria-hidden="true">3.3.</strong> Path Routing</a></li><li class="chapter-item expanded "><a href="../distributed/serialisation.html"><strong aria-hidden="true">3.4.</strong> Serialisation</a></li><li class="chapter-item expanded "><a href="../distributed/networkbuffers.html"><strong aria-hidden="true">3.5.</strong> Configuring Buffers</a></li><li class="chapter-item expanded "><a href="../distributed/networkstatusport.html"><strong aria-hidden="true">3.6.</strong> Network Status Port</a></li></ol></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">4.</strong> Async/Await Interaction</a></li><li class="chapter-item expanded affix "><a href="../project.html">Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Kompact Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/kompics/kompact" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>Kompact comes with build-in support for scheduling some execution to happen in the future. Such scheduled execution can be either one-off or periodically repeating. Concretely, the scheduling API allows developers to subscribe a handler closure to the firing of a timeout after some <code>Duration</code>. This closure takes two arguments: </p>
<ol>
<li>A new mutable reference to the scheduling component, so that its state can be accessed safely from within the closure, and</li>
<li>a handle to the timeout being triggered, so that different timeouts can be differentiated. The handle is an opaque type named <code>ScheduledTimer</code>, but currently is simply a wrapper around a <code>Uuid</code> instance assigned (and returned) when the timeout is originally scheduled.</li>
</ol>
<h2 id="batching-example"><a class="header" href="#batching-example">Batching Example</a></h2>
<p>In order to show the scheduling API, we will develop a batching component, called a <code>Buncher</code>, that collects received events locally until either a pre-configured batch size is reached or a defined timeout expires, whichever happens first. Once the batch is closed by either condition, a new <code>Batch</code> event is triggered on the port containing all the collected events.</p>
<p>Since there are two variants of scheduled execution, we will also implement two variants of the batching component:</p>
<ol>
<li>The <em>regular</em> variant simply schedules a periodic timeout once, and then fires a batch whenever the timeout expires, no matter how long ago the last batch was triggered (which could be fairly recently if it was triggered by the batch size condition).</li>
<li>The <em>adaptive</em> variant schedules a new one-off timeout for every batch. If a batch is triggered by size instead of time, this variant will cancel the current timeout and schedule a new one with the full duration again. This approach is more practical, as it results in more evenly sized batches than the <em>regular</em> variant.</li>
</ol>
<h3 id="shared-code"><a class="header" href="#shared-code">Shared Code</a></h3>
<p>Both implementations share the basic events and ports involved. They also both use a printer component for <code>Batch</code> events, which simply logs the size of each batch so we can see it during execution.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use kompact::prelude::*;

#[derive(Clone, Debug)]
pub struct Ping(pub u64);

#[derive(Clone, Debug)]
pub struct Batch(pub Vec&lt;Ping&gt;);

pub struct Batching;
impl Port for Batching {
    type Indication = Batch;
    type Request = Ping;
}

#[derive(ComponentDefinition, Actor)]
pub struct BatchPrinter {
    ctx: ComponentContext&lt;Self&gt;,
    batch_port: RequiredPort&lt;Batching&gt;,
}
impl BatchPrinter {
    pub fn new() -&gt; Self {
        BatchPrinter {
            ctx: ComponentContext::uninitialised(),
            batch_port: RequiredPort::uninitialised(),
        }
    }
}

ignore_lifecycle!(BatchPrinter);

impl Require&lt;Batching&gt; for BatchPrinter {
    fn handle(&amp;mut self, batch: Batch) -&gt; Handled {
        info!(self.log(), &quot;Got a batch with {} Pings.&quot;, batch.0.len());
        Handled::Ok
    }
}
</code></pre>
<p>They’ll also really use the same running code, even though its repeated in each file so it picks the correct implementation. In either case, we set up the <code>Buncher</code> and the <code>BatchPrinter</code> in a default system, connect them via <code>biconnect_components(...)</code> and then send them two waves of <code>Ping</code> events. The first wave comes around every millisecond, depending on concrete thread scheduling by the OS, while the second comes around every second millisecond.
With a batch size of 100 and a timeout of 150ms we will see mostly full batches in the first wave, while we usually see time-triggered waves in the second wave.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let printer = system.create(BatchPrinter::new);
    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
    let batching = buncher.on_definition(|cd| cd.batch_port.share());

    system.start(&amp;printer);
    system.start(&amp;buncher);

    // these should usually trigger due to full batches
    let sleep_dur = Duration::from_millis(1);
    for i in 0..500 {
        let ping = Ping(i);
        system.trigger_r(ping, &amp;batching);
        std::thread::sleep(sleep_dur);
    }

    // these should usually trigger due to timeout
    let sleep_dur = Duration::from_millis(2);
    for i in 0..500 {
        let ping = Ping(i);
        system.trigger_r(ping, &amp;batching);
        std::thread::sleep(sleep_dur);
    }

    system.shutdown().expect(&quot;shutdown&quot;);
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3 id="regular-buncher"><a class="header" href="#regular-buncher">Regular Buncher</a></h3>
<p>The state of the <code>Buncher</code> consists of the two configuration values, batch size and timeout, as well as the <code>Vec</code> storing the currently collecting batch and the handle for the currently scheduled timeout (<code>ScheduledTimer</code>).</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
struct Buncher {
    ctx: ComponentContext&lt;Self&gt;,
    batch_port: ProvidedPort&lt;Batching&gt;,
    batch_size: usize,
    timeout: Duration,
    current_batch: Vec&lt;Ping&gt;,
    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
}
<span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>As part of the lifecyle we must set up the timer, but also make sure to clean it up after we are done. To be able to do so, we must store the <code>ScheduledTimer</code> handle that the <code>schedule_periodic(...)</code> function returns in a local field, so we can access it when we are paused or killed and pass it as a parameter to <code>cancel_timer(...)</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Buncher {
    fn on_start(&amp;mut self) -&gt; Handled {
        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
        self.outstanding_timeout = Some(timeout);
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.outstanding_timeout.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Warning:</strong> Not cleaning up timeouts will cause them to be triggered over and over again. Not only will it slow down the timer facilities, but may also cause a lot of logging, depending on the logging level you are compiling with. Make sure to always clean up scheduled timeouts, especially periodic ones.</p>
</blockquote>
<p>The first parameter of the <code>schedule_periodic(...)</code> function is the time until the timeout is triggered the first time. The second parameters gives the periodicity. We’ll use the same value for both here.
The actual code we want to call whenever our periodic timeout is triggered is a private function called <code>handle_timeout(...)</code> which has the signature expected by the <code>schedule_periodic(...)</code> function. It checks that the timeout we got is actually an expected timeout, before invoking the actual <code>trigger_batch(...)</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn trigger_batch(&amp;mut self) -&gt; () {
        let mut new_batch = Vec::with_capacity(self.batch_size);
        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
        self.batch_port.trigger(Batch(new_batch))
    }

    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
        match self.outstanding_timeout {
            Some(ref timeout) if *timeout == timeout_id =&gt; {
                self.trigger_batch();
                Handled::Ok
            }
            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
            None =&gt; {
                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
                Handled::Ok
            } // can happen during restart or teardown
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The actual handler for the <code>Ping</code> events on the <code>Buncher</code> is pretty straight forward. We simply add the event to our active batch. Then we check if the batch is full, and if it is we again call <code>trigger_batch(...)</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_periodic(self.timeout, self.timeout, Self::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Provide&lt;Batching&gt; for Buncher {
    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
        self.current_batch.push(event);
        if self.current_batch.len() &gt;= self.batch_size {
            self.trigger_batch();
        }
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If we go and run this implementation with the main function from above, we will see that for the first wave we often get a full batch followed by a very small batch, e.g.:</p>
<pre><code class="language-bash">Mar 10 15:42:03.734 INFO Got a batch with 100 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
Mar 10 15:42:03.762 INFO Got a batch with 22 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
Mar 10 15:42:03.890 INFO Got a batch with 100 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
Mar 10 15:42:03.912 INFO Got a batch with 16 Pings., ctype: BatchPrinter, cid: 4c79e0b1-1d74-455b-987a-14f66bcd4025, system: kompact-runtime-1, location: docs/examples/src/batching.rs:33
</code></pre>
<p>This happens because we hit 100 Pings somewhere around 120ms into the timeout, and then there is only around 30ms left to collect events for the next batch. This, of course, isn’t particularly great behaviour for a batching abstraction. We would much rather have regular batches if the input is coming in regularly.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin buncher_regular
</code></pre>
</blockquote>
<h3 id="adaptive-buncher"><a class="header" href="#adaptive-buncher">Adaptive Buncher</a></h3>
<p>In order to get more regular sized batches, we need to reset our timeout whenever we trigger a batch based on size. Since this will cause our timeouts to be very irregular anyway, we will just skip periodic timeouts altogether and always schedule a new timer whenever we trigger a batch, no matter which condition triggered it.</p>
<p>To do so, we must first change the handler for lifecycle events to use <code>schedule_once(...)</code> instead of <code>schedule_periodic(...)</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Buncher {
    fn on_start(&amp;mut self) -&gt; Handled {
        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
        self.outstanding_timeout = Some(timeout);
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.outstanding_timeout.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We must also remember to reschedule a new timeout when we handle a current one. It’s important to correctly replace the handle for the timeout so we never accidentally trigger on an outdated timeout.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span>    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
        match self.outstanding_timeout {
            Some(ref timeout) if *timeout == timeout_id =&gt; {
                self.trigger_batch();
                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
                self.outstanding_timeout = Some(new_timeout);
                Handled::Ok
            }
            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
            None =&gt; {
                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
                Handled::Ok
            } // can happen during restart or teardown
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Provide&lt;Batching&gt; for Buncher {
</span><span class="boring">    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
</span><span class="boring">        self.current_batch.push(event);
</span><span class="boring">        if self.current_batch.len() &gt;= self.batch_size {
</span><span class="boring">            self.trigger_batch();
</span><span class="boring">            if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">                self.cancel_timer(timeout);
</span><span class="boring">            }
</span><span class="boring">            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">            self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Finally, when we trigger a batch based on size, we must proactively cancel the current timeout and schedule a new one. Note that this cancellation API is asychronous, so it can very well happen that an already cancelled timeout will still be invoked because it was already queued up. That is why we must always check for a matching timeout handle before executing a received timeout.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use kompact_examples::batching::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct Buncher {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    batch_port: ProvidedPort&lt;Batching&gt;,
</span><span class="boring">    batch_size: usize,
</span><span class="boring">    timeout: Duration,
</span><span class="boring">    current_batch: Vec&lt;Ping&gt;,
</span><span class="boring">    outstanding_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Buncher {
</span><span class="boring">    fn new(batch_size: usize, timeout: Duration) -&gt; Buncher {
</span><span class="boring">        Buncher {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            batch_port: ProvidedPort::uninitialised(),
</span><span class="boring">            batch_size,
</span><span class="boring">            timeout,
</span><span class="boring">            current_batch: Vec::with_capacity(batch_size),
</span><span class="boring">            outstanding_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn trigger_batch(&amp;mut self) -&gt; () {
</span><span class="boring">        let mut new_batch = Vec::with_capacity(self.batch_size);
</span><span class="boring">        std::mem::swap(&amp;mut new_batch, &amp;mut self.current_batch);
</span><span class="boring">        self.batch_port.trigger(Batch(new_batch))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(&amp;mut self, timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        match self.outstanding_timeout {
</span><span class="boring">            Some(ref timeout) if *timeout == timeout_id =&gt; {
</span><span class="boring">                self.trigger_batch();
</span><span class="boring">                let new_timeout = self.schedule_once(self.timeout, Self::handle_timeout);
</span><span class="boring">                self.outstanding_timeout = Some(new_timeout);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            }
</span><span class="boring">            Some(_) =&gt; Handled::Ok, // just ignore outdated timeouts
</span><span class="boring">            None =&gt; {
</span><span class="boring">                warn!(self.log(), &quot;Got unexpected timeout: {:?}&quot;, timeout_id);
</span><span class="boring">                Handled::Ok
</span><span class="boring">            } // can happen during restart or teardown
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Buncher {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
</span><span class="boring">        self.outstanding_timeout = Some(timeout);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.outstanding_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Provide&lt;Batching&gt; for Buncher {
    fn handle(&amp;mut self, event: Ping) -&gt; Handled {
        self.current_batch.push(event);
        if self.current_batch.len() &gt;= self.batch_size {
            self.trigger_batch();
            if let Some(timeout) = self.outstanding_timeout.take() {
                self.cancel_timer(timeout);
            }
            let new_timeout = self.schedule_once(self.timeout, Buncher::handle_timeout);
            self.outstanding_timeout = Some(new_timeout);
        }
        Handled::Ok
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let printer = system.create(BatchPrinter::new);
</span><span class="boring">    let buncher = system.create(move || Buncher::new(100, Duration::from_millis(150)));
</span><span class="boring">    biconnect_components::&lt;Batching, _, _&gt;(&amp;buncher, &amp;printer).expect(&quot;connection&quot;);
</span><span class="boring">    let batching = buncher.on_definition(|cd| cd.batch_port.share());
</span><span class="boring">
</span><span class="boring">    system.start(&amp;printer);
</span><span class="boring">    system.start(&amp;buncher);
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to full batches
</span><span class="boring">    let sleep_dur = Duration::from_millis(1);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // these should usually trigger due to timeout
</span><span class="boring">    let sleep_dur = Duration::from_millis(2);
</span><span class="boring">    for i in 0..500 {
</span><span class="boring">        let ping = Ping(i);
</span><span class="boring">        system.trigger_r(ping, &amp;batching);
</span><span class="boring">        std::thread::sleep(sleep_dur);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_buncher() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If we run again now, we can see that the first wave of pings is pretty much always triggered based on size, while the second wave is always triggered based on timeout, giving us much more regular batches.</p>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin buncher_adaptive
</code></pre>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../local/communication/senders.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../local/schedulers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../local/communication/senders.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../local/schedulers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
